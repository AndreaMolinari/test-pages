/* tslint:disable */
/* eslint-disable */
/**
 * ToBe - API
 * Get Swagger in json OAS3 format <a target=\"_blank\" href=\"/api-json\" rel=\"noopener noreferrer\">here</a>        Esempio del formato GeoJSON utilizzato per la gestione delle aree di interesse:        {         \"type\": \"Point\",         \"coordinates\": [           35.859375,           35.17380831799959         ]       }
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'road'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'village'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'municipality'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'province'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @interface AssignUserDto
 */
export interface AssignUserDto {
    /**
     * 
     * @type {string}
     * @memberof AssignUserDto
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof AssignUserDto
     */
    'level': AssignUserDtoLevelEnum;
}

export const AssignUserDtoLevelEnum = {
    Owner: 'Owner',
    Manager: 'Manager'
} as const;

export type AssignUserDtoLevelEnum = typeof AssignUserDtoLevelEnum[keyof typeof AssignUserDtoLevelEnum];

/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'oldPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'passwordConfirm': string;
}
/**
 * 
 * @export
 * @interface ContentAttachment
 */
export interface ContentAttachment {
    /**
     * 
     * @type {string}
     * @memberof ContentAttachment
     */
    'link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContentAttachment
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContentAttachment
     */
    'accessibility'?: ContentAttachmentAccessibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof ContentAttachment
     */
    'mediaType'?: ContentAttachmentMediaTypeEnum;
}

export const ContentAttachmentAccessibilityEnum = {
    Ipovedente: 'ipovedente'
} as const;

export type ContentAttachmentAccessibilityEnum = typeof ContentAttachmentAccessibilityEnum[keyof typeof ContentAttachmentAccessibilityEnum];
export const ContentAttachmentMediaTypeEnum = {
    Image: 'image',
    Video: 'video',
    Audio: 'audio'
} as const;

export type ContentAttachmentMediaTypeEnum = typeof ContentAttachmentMediaTypeEnum[keyof typeof ContentAttachmentMediaTypeEnum];

/**
 * 
 * @export
 * @interface CreateAddressDto
 */
export interface CreateAddressDto {
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'road': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'village': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'municipality': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'province': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'postcode': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressDto
     */
    'country_code': string;
}
/**
 * 
 * @export
 * @interface CreateFaqDto
 */
export interface CreateFaqDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFaqDto
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFaqDto
     */
    'answer'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateFaqDto
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateLifiAppDto
 */
export interface CreateLifiAppDto {
    /**
     * 
     * @type {string}
     * @memberof CreateLifiAppDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLifiAppDto
     */
    'sector': CreateLifiAppDtoSectorEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateLifiAppDto
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLifiAppDto
     */
    'redirectUri'?: string;
}

export const CreateLifiAppDtoSectorEnum = {
    Arte: 'Arte',
    Sanit: 'Sanit√†',
    Verticale: 'Verticale'
} as const;

export type CreateLifiAppDtoSectorEnum = typeof CreateLifiAppDtoSectorEnum[keyof typeof CreateLifiAppDtoSectorEnum];

/**
 * 
 * @export
 * @interface CreateLifiComponentDto
 */
export interface CreateLifiComponentDto {
    /**
     * 
     * @type {string}
     * @memberof CreateLifiComponentDto
     */
    'componentId'?: string;
    /**
     * 
     * @type {LocateLifiSiteDto}
     * @memberof CreateLifiComponentDto
     */
    'position'?: LocateLifiSiteDto;
    /**
     * 
     * @type {number}
     * @memberof CreateLifiComponentDto
     */
    'range'?: number;
}
/**
 * 
 * @export
 * @interface CreateLifiContentDto
 */
export interface CreateLifiContentDto {
    /**
     * 
     * @type {string}
     * @memberof CreateLifiContentDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLifiContentDto
     */
    'date_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateLifiContentDto
     */
    'date_to'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateLifiContentDto
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateLifiContentDto
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLifiContentDto
     */
    'details'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateLifiContentDto
     */
    'public'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateLifiContentDto
     */
    'offline'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateLifiHotspotDto
 */
export interface CreateLifiHotspotDto {
    /**
     * 
     * @type {string}
     * @memberof CreateLifiHotspotDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CreateLifiSiteDto
 */
export interface CreateLifiSiteDto {
    /**
     * 
     * @type {string}
     * @memberof CreateLifiSiteDto
     */
    'name': string;
    /**
     * 
     * @type {LocateLifiSiteDto}
     * @memberof CreateLifiSiteDto
     */
    'location': LocateLifiSiteDto;
    /**
     * 
     * @type {number}
     * @memberof CreateLifiSiteDto
     */
    'locateRange'?: number;
    /**
     * 
     * @type {CreateSignifyInfoDto}
     * @memberof CreateLifiSiteDto
     */
    'signify': CreateSignifyInfoDto;
    /**
     * 
     * @type {string}
     * @memberof CreateLifiSiteDto
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateLifiSiteDto
     */
    'sector': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateLifiSiteDto
     */
    'loghi': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateRegistryDto
 */
export interface CreateRegistryDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRegistryDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRegistryDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRegistryDto
     */
    'birthday': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRegistryDto
     */
    'gender': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRegistryDto
     */
    'phone'?: string;
    /**
     * 
     * @type {CreateAddressDto}
     * @memberof CreateRegistryDto
     */
    'address'?: CreateAddressDto;
}
/**
 * 
 * @export
 * @interface CreateSignifyInfoDto
 */
export interface CreateSignifyInfoDto {
    /**
     * 
     * @type {string}
     * @memberof CreateSignifyInfoDto
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'passwordConfirm': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'role': CreateUserDtoRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserDto
     */
    'privacy': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserDto
     */
    'privacyThirdParty': boolean;
}

export const CreateUserDtoRoleEnum = {
    Developer: 'developer',
    Admin: 'admin',
    Creator: 'creator',
    User: 'user'
} as const;

export type CreateUserDtoRoleEnum = typeof CreateUserDtoRoleEnum[keyof typeof CreateUserDtoRoleEnum];

/**
 * 
 * @export
 * @interface Faq
 */
export interface Faq {
    /**
     * 
     * @type {string}
     * @memberof Faq
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Faq
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof Faq
     */
    'answer'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Faq
     */
    'visible': boolean;
    /**
     * 
     * @type {string}
     * @memberof Faq
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Faq
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Faq
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {FaqExclusiveTo}
     * @memberof Faq
     */
    'exclusiveTo'?: FaqExclusiveTo | null;
}
/**
 * App to which this faq is exclusive to
 * @export
 * @interface FaqExclusiveTo
 */
export interface FaqExclusiveTo {
    /**
     * 
     * @type {string}
     * @memberof FaqExclusiveTo
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FaqExclusiveTo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FaqExclusiveTo
     */
    'sector': FaqExclusiveToSectorEnum;
    /**
     * 
     * @type {string}
     * @memberof FaqExclusiveTo
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof FaqExclusiveTo
     */
    'redirectUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof FaqExclusiveTo
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FaqExclusiveTo
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof FaqExclusiveTo
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {Array<Faq>}
     * @memberof FaqExclusiveTo
     */
    'faqs': Array<Faq>;
    /**
     * 
     * @type {Array<LifiSite>}
     * @memberof FaqExclusiveTo
     */
    'sites': Array<LifiSite>;
}

export const FaqExclusiveToSectorEnum = {
    Arte: 'Arte',
    Sanit: 'Sanit√†',
    Verticale: 'Verticale'
} as const;

export type FaqExclusiveToSectorEnum = typeof FaqExclusiveToSectorEnum[keyof typeof FaqExclusiveToSectorEnum];

/**
 * 
 * @export
 * @interface LifiApp
 */
export interface LifiApp {
    /**
     * 
     * @type {string}
     * @memberof LifiApp
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof LifiApp
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LifiApp
     */
    'sector': LifiAppSectorEnum;
    /**
     * 
     * @type {string}
     * @memberof LifiApp
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof LifiApp
     */
    'redirectUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof LifiApp
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LifiApp
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof LifiApp
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {Array<Faq>}
     * @memberof LifiApp
     */
    'faqs': Array<Faq>;
    /**
     * 
     * @type {Array<LifiSite>}
     * @memberof LifiApp
     */
    'sites': Array<LifiSite>;
}

export const LifiAppSectorEnum = {
    Arte: 'Arte',
    Sanit: 'Sanit√†',
    Verticale: 'Verticale'
} as const;

export type LifiAppSectorEnum = typeof LifiAppSectorEnum[keyof typeof LifiAppSectorEnum];

/**
 * 
 * @export
 * @interface LifiComponent
 */
export interface LifiComponent {
    /**
     * 
     * @type {string}
     * @memberof LifiComponent
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof LifiComponent
     */
    'componentId'?: string;
    /**
     * 
     * @type {object}
     * @memberof LifiComponent
     */
    'position'?: object;
    /**
     * 
     * @type {number}
     * @memberof LifiComponent
     */
    'range': number;
    /**
     * 
     * @type {string}
     * @memberof LifiComponent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LifiComponent
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof LifiComponent
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {LifiHotspot}
     * @memberof LifiComponent
     */
    'hotspot'?: LifiHotspot;
}
/**
 * 
 * @export
 * @interface LifiContent
 */
export interface LifiContent {
    /**
     * 
     * @type {string}
     * @memberof LifiContent
     */
    'uuid': string;
    /**
     * 
     * @type {LifiHotspot}
     * @memberof LifiContent
     */
    'hotspot'?: LifiHotspot;
    /**
     * 
     * @type {LifiSite}
     * @memberof LifiContent
     */
    'networkSite'?: LifiSite;
    /**
     * 
     * @type {string}
     * @memberof LifiContent
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof LifiContent
     */
    'date_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof LifiContent
     */
    'date_to'?: string;
    /**
     * 
     * @type {string}
     * @memberof LifiContent
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof LifiContent
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof LifiContent
     */
    'details'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LifiContent
     */
    'public': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LifiContent
     */
    'offline': boolean;
    /**
     * 
     * @type {Array<ContentAttachment>}
     * @memberof LifiContent
     */
    'attachments': Array<ContentAttachment>;
    /**
     * 
     * @type {string}
     * @memberof LifiContent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LifiContent
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof LifiContent
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface LifiHotspot
 */
export interface LifiHotspot {
    /**
     * 
     * @type {string}
     * @memberof LifiHotspot
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof LifiHotspot
     */
    'code': string;
    /**
     * 
     * @type {LifiSite}
     * @memberof LifiHotspot
     */
    'site': LifiSite;
    /**
     * 
     * @type {Array<LifiComponent>}
     * @memberof LifiHotspot
     */
    'components': Array<LifiComponent>;
    /**
     * 
     * @type {Array<LifiContent>}
     * @memberof LifiHotspot
     */
    'contents': Array<LifiContent>;
}
/**
 * 
 * @export
 * @interface LifiSite
 */
export interface LifiSite {
    /**
     * 
     * @type {string}
     * @memberof LifiSite
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof LifiSite
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof LifiSite
     */
    'location': object;
    /**
     * 
     * @type {number}
     * @memberof LifiSite
     */
    'locateRange': number;
    /**
     * 
     * @type {SignifyInfo}
     * @memberof LifiSite
     */
    'signify'?: SignifyInfo;
    /**
     * 
     * @type {string}
     * @memberof LifiSite
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof LifiSite
     */
    'sector': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LifiSite
     */
    'loghi': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LifiSite
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LifiSite
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof LifiSite
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {Array<LifiApp>}
     * @memberof LifiSite
     */
    'apps': Array<LifiApp>;
    /**
     * 
     * @type {Array<LifiContent>}
     * @memberof LifiSite
     */
    'networkContents': Array<LifiContent>;
    /**
     * 
     * @type {Array<LifiSiteUserAbility>}
     * @memberof LifiSite
     */
    'enabledUserAbilities': Array<LifiSiteUserAbility>;
    /**
     * 
     * @type {Array<LifiHotspot>}
     * @memberof LifiSite
     */
    'hotspots': Array<LifiHotspot>;
}
/**
 * 
 * @export
 * @interface LifiSiteUserAbility
 */
export interface LifiSiteUserAbility {
    /**
     * 
     * @type {string}
     * @memberof LifiSiteUserAbility
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof LifiSiteUserAbility
     */
    'level': LifiSiteUserAbilityLevelEnum;
    /**
     * 
     * @type {User}
     * @memberof LifiSiteUserAbility
     */
    'user': User;
    /**
     * 
     * @type {LifiSite}
     * @memberof LifiSiteUserAbility
     */
    'site': LifiSite;
}

export const LifiSiteUserAbilityLevelEnum = {
    Owner: 'Owner',
    Manager: 'Manager'
} as const;

export type LifiSiteUserAbilityLevelEnum = typeof LifiSiteUserAbilityLevelEnum[keyof typeof LifiSiteUserAbilityLevelEnum];

/**
 * 
 * @export
 * @interface LocateLifiSiteDto
 */
export interface LocateLifiSiteDto {
    /**
     * 
     * @type {number}
     * @memberof LocateLifiSiteDto
     */
    'latitude': number;
    /**
     * 
     * @type {number}
     * @memberof LocateLifiSiteDto
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface Registry
 */
export interface Registry {
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    'birthday': string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    'gender': string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    'phone'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Registry
     */
    'address': Address;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {User}
     * @memberof Registry
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface SignInDto
 */
export interface SignInDto {
    /**
     * 
     * @type {string}
     * @memberof SignInDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignInDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface SignifyInfo
 */
export interface SignifyInfo {
    /**
     * 
     * @type {boolean}
     * @memberof SignifyInfo
     */
    'hasMap'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SignifyInfo
     */
    'map'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignifyInfo
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAddressDto
 */
export interface UpdateAddressDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'road'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'village'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'municipality'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'province'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'postcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    'country_code'?: string;
}
/**
 * 
 * @export
 * @interface UpdateFaqDto
 */
export interface UpdateFaqDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateFaqDto
     */
    'question'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFaqDto
     */
    'answer'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateFaqDto
     */
    'visible'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateLifiAppDto
 */
export interface UpdateLifiAppDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiAppDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiAppDto
     */
    'sector'?: UpdateLifiAppDtoSectorEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiAppDto
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiAppDto
     */
    'redirectUri'?: string;
}

export const UpdateLifiAppDtoSectorEnum = {
    Arte: 'Arte',
    Sanit: 'Sanit√†',
    Verticale: 'Verticale'
} as const;

export type UpdateLifiAppDtoSectorEnum = typeof UpdateLifiAppDtoSectorEnum[keyof typeof UpdateLifiAppDtoSectorEnum];

/**
 * 
 * @export
 * @interface UpdateLifiComponentDto
 */
export interface UpdateLifiComponentDto {
    /**
     * 
     * @type {LocateLifiSiteDto}
     * @memberof UpdateLifiComponentDto
     */
    'position'?: LocateLifiSiteDto;
    /**
     * 
     * @type {number}
     * @memberof UpdateLifiComponentDto
     */
    'range'?: number;
}
/**
 * 
 * @export
 * @interface UpdateLifiContentDto
 */
export interface UpdateLifiContentDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiContentDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiContentDto
     */
    'date_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiContentDto
     */
    'date_to'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiContentDto
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiContentDto
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiContentDto
     */
    'details'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateLifiContentDto
     */
    'public'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateLifiContentDto
     */
    'offline'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateLifiHotspotDto
 */
export interface UpdateLifiHotspotDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiHotspotDto
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface UpdateLifiSiteDto
 */
export interface UpdateLifiSiteDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiSiteDto
     */
    'name'?: string;
    /**
     * 
     * @type {LocateLifiSiteDto}
     * @memberof UpdateLifiSiteDto
     */
    'location'?: LocateLifiSiteDto;
    /**
     * 
     * @type {number}
     * @memberof UpdateLifiSiteDto
     */
    'locateRange'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiSiteDto
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLifiSiteDto
     */
    'sector'?: string;
    /**
     * 
     * @type {UpdateSignifyInfoDto}
     * @memberof UpdateLifiSiteDto
     */
    'signify'?: UpdateSignifyInfoDto;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateLifiSiteDto
     */
    'loghi'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateRegistryDto
 */
export interface UpdateRegistryDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateRegistryDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRegistryDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRegistryDto
     */
    'birthday'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRegistryDto
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRegistryDto
     */
    'phone'?: string;
    /**
     * 
     * @type {UpdateAddressDto}
     * @memberof UpdateRegistryDto
     */
    'address'?: UpdateAddressDto;
}
/**
 * 
 * @export
 * @interface UpdateSignifyInfoDto
 */
export interface UpdateSignifyInfoDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSignifyInfoDto
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'passwordConfirm'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'privacy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'privacyThirdParty'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'role'?: UpdateUserDtoRoleEnum;
}

export const UpdateUserDtoRoleEnum = {
    Developer: 'developer',
    Admin: 'admin',
    Creator: 'creator',
    User: 'user'
} as const;

export type UpdateUserDtoRoleEnum = typeof UpdateUserDtoRoleEnum[keyof typeof UpdateUserDtoRoleEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * True if the user has an extended access to any site
     * @type {boolean}
     * @memberof User
     */
    'hasManagerAccess': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profilePicture'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'privacy': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'privacyThirdParty': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'googleUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'facebookUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'appleUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {Registry}
     * @memberof User
     */
    'registry'?: Registry;
    /**
     * 
     * @type {Array<LifiSiteUserAbility>}
     * @memberof User
     */
    'enabledSiteAbilities': Array<LifiSiteUserAbility>;
}

export const UserRoleEnum = {
    Developer: 'developer',
    Admin: 'admin',
    Creator: 'creator',
    User: 'user'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];


/**
 * AdminRegistryManagementApi - axios parameter creator
 * @export
 */
export const AdminRegistryManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create the registry for the user
         * @param {string} user 
         * @param {CreateRegistryDto} createRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegistryControllerCreate: async (user: string, createRegistryDto: CreateRegistryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('adminRegistryControllerCreate', 'user', user)
            // verify required parameter 'createRegistryDto' is not null or undefined
            assertParamExists('adminRegistryControllerCreate', 'createRegistryDto', createRegistryDto)
            const localVarPath = `/users/{user}/registry`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRegistryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the user\'s registry
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegistryControllerFindAll: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('adminRegistryControllerFindAll', 'user', user)
            const localVarPath = `/users/{user}/registry`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the registry for the user
         * @param {string} registry 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegistryControllerRemove: async (registry: string, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registry' is not null or undefined
            assertParamExists('adminRegistryControllerRemove', 'registry', registry)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('adminRegistryControllerRemove', 'user', user)
            const localVarPath = `/users/{user}/registry/{registry}`
                .replace(`{${"registry"}}`, encodeURIComponent(String(registry)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the registry for the user
         * @param {string} registry 
         * @param {string} user 
         * @param {UpdateRegistryDto} updateRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegistryControllerUpdate: async (registry: string, user: string, updateRegistryDto: UpdateRegistryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registry' is not null or undefined
            assertParamExists('adminRegistryControllerUpdate', 'registry', registry)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('adminRegistryControllerUpdate', 'user', user)
            // verify required parameter 'updateRegistryDto' is not null or undefined
            assertParamExists('adminRegistryControllerUpdate', 'updateRegistryDto', updateRegistryDto)
            const localVarPath = `/users/{user}/registry/{registry}`
                .replace(`{${"registry"}}`, encodeURIComponent(String(registry)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRegistryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminRegistryManagementApi - functional programming interface
 * @export
 */
export const AdminRegistryManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminRegistryManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create the registry for the user
         * @param {string} user 
         * @param {CreateRegistryDto} createRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminRegistryControllerCreate(user: string, createRegistryDto: CreateRegistryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRegistryControllerCreate(user, createRegistryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the user\'s registry
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminRegistryControllerFindAll(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRegistryControllerFindAll(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the registry for the user
         * @param {string} registry 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminRegistryControllerRemove(registry: string, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRegistryControllerRemove(registry, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the registry for the user
         * @param {string} registry 
         * @param {string} user 
         * @param {UpdateRegistryDto} updateRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminRegistryControllerUpdate(registry: string, user: string, updateRegistryDto: UpdateRegistryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRegistryControllerUpdate(registry, user, updateRegistryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminRegistryManagementApi - factory interface
 * @export
 */
export const AdminRegistryManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminRegistryManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create the registry for the user
         * @param {string} user 
         * @param {CreateRegistryDto} createRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegistryControllerCreate(user: string, createRegistryDto: CreateRegistryDto, options?: any): AxiosPromise<Registry> {
            return localVarFp.adminRegistryControllerCreate(user, createRegistryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the user\'s registry
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegistryControllerFindAll(user: string, options?: any): AxiosPromise<Registry> {
            return localVarFp.adminRegistryControllerFindAll(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the registry for the user
         * @param {string} registry 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegistryControllerRemove(registry: string, user: string, options?: any): AxiosPromise<Registry> {
            return localVarFp.adminRegistryControllerRemove(registry, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the registry for the user
         * @param {string} registry 
         * @param {string} user 
         * @param {UpdateRegistryDto} updateRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRegistryControllerUpdate(registry: string, user: string, updateRegistryDto: UpdateRegistryDto, options?: any): AxiosPromise<Registry> {
            return localVarFp.adminRegistryControllerUpdate(registry, user, updateRegistryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminRegistryManagementApi - object-oriented interface
 * @export
 * @class AdminRegistryManagementApi
 * @extends {BaseAPI}
 */
export class AdminRegistryManagementApi extends BaseAPI {
    /**
     * 
     * @summary Create the registry for the user
     * @param {string} user 
     * @param {CreateRegistryDto} createRegistryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRegistryManagementApi
     */
    public adminRegistryControllerCreate(user: string, createRegistryDto: CreateRegistryDto, options?: AxiosRequestConfig) {
        return AdminRegistryManagementApiFp(this.configuration).adminRegistryControllerCreate(user, createRegistryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the user\'s registry
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRegistryManagementApi
     */
    public adminRegistryControllerFindAll(user: string, options?: AxiosRequestConfig) {
        return AdminRegistryManagementApiFp(this.configuration).adminRegistryControllerFindAll(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the registry for the user
     * @param {string} registry 
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRegistryManagementApi
     */
    public adminRegistryControllerRemove(registry: string, user: string, options?: AxiosRequestConfig) {
        return AdminRegistryManagementApiFp(this.configuration).adminRegistryControllerRemove(registry, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the registry for the user
     * @param {string} registry 
     * @param {string} user 
     * @param {UpdateRegistryDto} updateRegistryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRegistryManagementApi
     */
    public adminRegistryControllerUpdate(registry: string, user: string, updateRegistryDto: UpdateRegistryDto, options?: AxiosRequestConfig) {
        return AdminRegistryManagementApiFp(this.configuration).adminRegistryControllerUpdate(registry, user, updateRegistryDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AppsManagementApi - axios parameter creator
 * @export
 */
export const AppsManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign an accessible site to an app
         * @param {string} app 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerAssign: async (app: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            assertParamExists('lifiAppsControllerAssign', 'app', app)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiAppsControllerAssign', 'site', site)
            const localVarPath = `/lifi-apps/{app}/sites/{site}`
                .replace(`{${"app"}}`, encodeURIComponent(String(app)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new app
         * @param {CreateLifiAppDto} createLifiAppDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerCreate: async (createLifiAppDto: CreateLifiAppDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLifiAppDto' is not null or undefined
            assertParamExists('lifiAppsControllerCreate', 'createLifiAppDto', createLifiAppDto)
            const localVarPath = `/lifi-apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLifiAppDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a site assignation from an app
         * @param {string} app 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerDismiss: async (app: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            assertParamExists('lifiAppsControllerDismiss', 'app', app)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiAppsControllerDismiss', 'site', site)
            const localVarPath = `/lifi-apps/{app}/sites/{site}`
                .replace(`{${"app"}}`, encodeURIComponent(String(app)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lifi-apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an app
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerFindOne: async (app: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            assertParamExists('lifiAppsControllerFindOne', 'app', app)
            const localVarPath = `/lifi-apps/{app}`
                .replace(`{${"app"}}`, encodeURIComponent(String(app)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all sites this app is assigned to.
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerGetAllSites: async (app: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            assertParamExists('lifiAppsControllerGetAllSites', 'app', app)
            const localVarPath = `/lifi-apps/{app}/sites`
                .replace(`{${"app"}}`, encodeURIComponent(String(app)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an app
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerRemove: async (app: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            assertParamExists('lifiAppsControllerRemove', 'app', app)
            const localVarPath = `/lifi-apps/{app}`
                .replace(`{${"app"}}`, encodeURIComponent(String(app)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an app
         * @param {string} app 
         * @param {UpdateLifiAppDto} updateLifiAppDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerUpdate: async (app: string, updateLifiAppDto: UpdateLifiAppDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            assertParamExists('lifiAppsControllerUpdate', 'app', app)
            // verify required parameter 'updateLifiAppDto' is not null or undefined
            assertParamExists('lifiAppsControllerUpdate', 'updateLifiAppDto', updateLifiAppDto)
            const localVarPath = `/lifi-apps/{app}`
                .replace(`{${"app"}}`, encodeURIComponent(String(app)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiAppDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsManagementApi - functional programming interface
 * @export
 */
export const AppsManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign an accessible site to an app
         * @param {string} app 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiAppsControllerAssign(app: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiApp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerAssign(app, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new app
         * @param {CreateLifiAppDto} createLifiAppDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiAppsControllerCreate(createLifiAppDto: CreateLifiAppDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerCreate(createLifiAppDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a site assignation from an app
         * @param {string} app 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiAppsControllerDismiss(app: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiApp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerDismiss(app, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find all apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiAppsControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an app
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiAppsControllerFindOne(app: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerFindOne(app, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all sites this app is assigned to.
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiAppsControllerGetAllSites(app: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiSite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerGetAllSites(app, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an app
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiAppsControllerRemove(app: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerRemove(app, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an app
         * @param {string} app 
         * @param {UpdateLifiAppDto} updateLifiAppDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiAppsControllerUpdate(app: string, updateLifiAppDto: UpdateLifiAppDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerUpdate(app, updateLifiAppDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppsManagementApi - factory interface
 * @export
 */
export const AppsManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign an accessible site to an app
         * @param {string} app 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerAssign(app: string, site: string, options?: any): AxiosPromise<LifiApp> {
            return localVarFp.lifiAppsControllerAssign(app, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new app
         * @param {CreateLifiAppDto} createLifiAppDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerCreate(createLifiAppDto: CreateLifiAppDto, options?: any): AxiosPromise<void> {
            return localVarFp.lifiAppsControllerCreate(createLifiAppDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a site assignation from an app
         * @param {string} app 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerDismiss(app: string, site: string, options?: any): AxiosPromise<LifiApp> {
            return localVarFp.lifiAppsControllerDismiss(app, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find all apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerFindAll(options?: any): AxiosPromise<void> {
            return localVarFp.lifiAppsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an app
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerFindOne(app: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiAppsControllerFindOne(app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all sites this app is assigned to.
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerGetAllSites(app: string, options?: any): AxiosPromise<Array<LifiSite>> {
            return localVarFp.lifiAppsControllerGetAllSites(app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an app
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerRemove(app: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiAppsControllerRemove(app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an app
         * @param {string} app 
         * @param {UpdateLifiAppDto} updateLifiAppDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiAppsControllerUpdate(app: string, updateLifiAppDto: UpdateLifiAppDto, options?: any): AxiosPromise<void> {
            return localVarFp.lifiAppsControllerUpdate(app, updateLifiAppDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppsManagementApi - object-oriented interface
 * @export
 * @class AppsManagementApi
 * @extends {BaseAPI}
 */
export class AppsManagementApi extends BaseAPI {
    /**
     * 
     * @summary Assign an accessible site to an app
     * @param {string} app 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsManagementApi
     */
    public lifiAppsControllerAssign(app: string, site: string, options?: AxiosRequestConfig) {
        return AppsManagementApiFp(this.configuration).lifiAppsControllerAssign(app, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new app
     * @param {CreateLifiAppDto} createLifiAppDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsManagementApi
     */
    public lifiAppsControllerCreate(createLifiAppDto: CreateLifiAppDto, options?: AxiosRequestConfig) {
        return AppsManagementApiFp(this.configuration).lifiAppsControllerCreate(createLifiAppDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a site assignation from an app
     * @param {string} app 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsManagementApi
     */
    public lifiAppsControllerDismiss(app: string, site: string, options?: AxiosRequestConfig) {
        return AppsManagementApiFp(this.configuration).lifiAppsControllerDismiss(app, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find all apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsManagementApi
     */
    public lifiAppsControllerFindAll(options?: AxiosRequestConfig) {
        return AppsManagementApiFp(this.configuration).lifiAppsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an app
     * @param {string} app 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsManagementApi
     */
    public lifiAppsControllerFindOne(app: string, options?: AxiosRequestConfig) {
        return AppsManagementApiFp(this.configuration).lifiAppsControllerFindOne(app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all sites this app is assigned to.
     * @param {string} app 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsManagementApi
     */
    public lifiAppsControllerGetAllSites(app: string, options?: AxiosRequestConfig) {
        return AppsManagementApiFp(this.configuration).lifiAppsControllerGetAllSites(app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an app
     * @param {string} app 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsManagementApi
     */
    public lifiAppsControllerRemove(app: string, options?: AxiosRequestConfig) {
        return AppsManagementApiFp(this.configuration).lifiAppsControllerRemove(app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an app
     * @param {string} app 
     * @param {UpdateLifiAppDto} updateLifiAppDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsManagementApi
     */
    public lifiAppsControllerUpdate(app: string, updateLifiAppDto: UpdateLifiAppDto, options?: AxiosRequestConfig) {
        return AppsManagementApiFp(this.configuration).lifiAppsControllerUpdate(app, updateLifiAppDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change the user password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword: async (changePasswordDto: ChangePasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('authControllerChangePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a CSRF token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetCsrfToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/csrf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch the signed user\'s profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a presigned url to a user\'s profile picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerPresignedProfileImage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/presignedProfileImage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s profile picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerProfileImage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/profileImage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh the access token using the refresh token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken: async (refreshTokenDto: RefreshTokenDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDto' is not null or undefined
            assertParamExists('authControllerRefreshToken', 'refreshTokenDto', refreshTokenDto)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset the user password
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authControllerResetPassword', 'token', token)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign in an account
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignIn: async (signInDto: SignInDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInDto' is not null or undefined
            assertParamExists('authControllerSignIn', 'signInDto', signInDto)
            const localVarPath = `/auth/signIn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign out from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignOut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/signOut`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign up a new account
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUp: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('authControllerSignUp', 'createUserDto', createUserDto)
            const localVarPath = `/auth/signUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a profile picture
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUploadFile: async (file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify the user email
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authControllerVerifyEmail', 'token', token)
            const localVarPath = `/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change the user password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerChangePassword(changePasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a CSRF token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetCsrfToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetCsrfToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch the signed user\'s profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a presigned url to a user\'s profile picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerPresignedProfileImage(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerPresignedProfileImage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user\'s profile picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerProfileImage(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerProfileImage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh the access token using the refresh token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshToken(refreshTokenDto: RefreshTokenDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshToken(refreshTokenDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset the user password
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPassword(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPassword(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sign in an account
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignIn(signInDto: SignInDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignIn(signInDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sign out from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignOut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignOut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sign up a new account
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignUp(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignUp(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload a profile picture
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerUploadFile(file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerUploadFile(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Verify the user email
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyEmail(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyEmail(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Change the user password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerChangePassword(changePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a CSRF token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetCsrfToken(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerGetCsrfToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch the signed user\'s profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: any): AxiosPromise<User> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a presigned url to a user\'s profile picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerPresignedProfileImage(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerPresignedProfileImage(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s profile picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerProfileImage(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerProfileImage(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh the access token using the refresh token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshToken(refreshTokenDto: RefreshTokenDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerRefreshToken(refreshTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset the user password
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword(token: string, options?: any): AxiosPromise<object> {
            return localVarFp.authControllerResetPassword(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign in an account
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignIn(signInDto: SignInDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSignIn(signInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign out from account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignOut(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSignOut(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign up a new account
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUp(createUserDto: CreateUserDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSignUp(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a profile picture
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUploadFile(file?: File, options?: any): AxiosPromise<object> {
            return localVarFp.authControllerUploadFile(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify the user email
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail(token: string, options?: any): AxiosPromise<User> {
            return localVarFp.authControllerVerifyEmail(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Change the user password
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerChangePassword(changePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a CSRF token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetCsrfToken(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetCsrfToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch the signed user\'s profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetProfile(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a presigned url to a user\'s profile picture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerPresignedProfileImage(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerPresignedProfileImage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s profile picture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerProfileImage(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerProfileImage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh the access token using the refresh token
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefreshToken(refreshTokenDto: RefreshTokenDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefreshToken(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset the user password
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResetPassword(token: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResetPassword(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign in an account
     * @param {SignInDto} signInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignIn(signInDto: SignInDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignIn(signInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign out from account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignOut(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignOut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign up a new account
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignUp(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignUp(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a profile picture
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerUploadFile(file?: File, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerUploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify the user email
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerVerifyEmail(token: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerVerifyEmail(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ComponentManagementApi - axios parameter creator
 * @export
 */
export const ComponentManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a component
         * @param {CreateLifiComponentDto} createLifiComponentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiComponentsControllerCreate: async (createLifiComponentDto: CreateLifiComponentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLifiComponentDto' is not null or undefined
            assertParamExists('lifiComponentsControllerCreate', 'createLifiComponentDto', createLifiComponentDto)
            const localVarPath = `/lifi-components`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLifiComponentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all components
         * @param {boolean} [assigned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiComponentsControllerFindAll: async (assigned?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lifi-components`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a component
         * @param {string} component 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiComponentsControllerFindOne: async (component: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'component' is not null or undefined
            assertParamExists('lifiComponentsControllerFindOne', 'component', component)
            const localVarPath = `/lifi-components/{component}`
                .replace(`{${"component"}}`, encodeURIComponent(String(component)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a component
         * @param {string} component 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiComponentsControllerRemove: async (component: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'component' is not null or undefined
            assertParamExists('lifiComponentsControllerRemove', 'component', component)
            const localVarPath = `/lifi-components/{component}`
                .replace(`{${"component"}}`, encodeURIComponent(String(component)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a component
         * @param {string} component 
         * @param {UpdateLifiComponentDto} updateLifiComponentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiComponentsControllerUpdate: async (component: string, updateLifiComponentDto: UpdateLifiComponentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'component' is not null or undefined
            assertParamExists('lifiComponentsControllerUpdate', 'component', component)
            // verify required parameter 'updateLifiComponentDto' is not null or undefined
            assertParamExists('lifiComponentsControllerUpdate', 'updateLifiComponentDto', updateLifiComponentDto)
            const localVarPath = `/lifi-components/{component}`
                .replace(`{${"component"}}`, encodeURIComponent(String(component)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiComponentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComponentManagementApi - functional programming interface
 * @export
 */
export const ComponentManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ComponentManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a component
         * @param {CreateLifiComponentDto} createLifiComponentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiComponentsControllerCreate(createLifiComponentDto: CreateLifiComponentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiComponentsControllerCreate(createLifiComponentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all components
         * @param {boolean} [assigned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiComponentsControllerFindAll(assigned?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiComponent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiComponentsControllerFindAll(assigned, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a component
         * @param {string} component 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiComponentsControllerFindOne(component: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiComponentsControllerFindOne(component, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a component
         * @param {string} component 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiComponentsControllerRemove(component: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiComponentsControllerRemove(component, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a component
         * @param {string} component 
         * @param {UpdateLifiComponentDto} updateLifiComponentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiComponentsControllerUpdate(component: string, updateLifiComponentDto: UpdateLifiComponentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiComponentsControllerUpdate(component, updateLifiComponentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ComponentManagementApi - factory interface
 * @export
 */
export const ComponentManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ComponentManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a component
         * @param {CreateLifiComponentDto} createLifiComponentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiComponentsControllerCreate(createLifiComponentDto: CreateLifiComponentDto, options?: any): AxiosPromise<void> {
            return localVarFp.lifiComponentsControllerCreate(createLifiComponentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all components
         * @param {boolean} [assigned] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiComponentsControllerFindAll(assigned?: boolean, options?: any): AxiosPromise<Array<LifiComponent>> {
            return localVarFp.lifiComponentsControllerFindAll(assigned, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a component
         * @param {string} component 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiComponentsControllerFindOne(component: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiComponentsControllerFindOne(component, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a component
         * @param {string} component 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiComponentsControllerRemove(component: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiComponentsControllerRemove(component, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a component
         * @param {string} component 
         * @param {UpdateLifiComponentDto} updateLifiComponentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiComponentsControllerUpdate(component: string, updateLifiComponentDto: UpdateLifiComponentDto, options?: any): AxiosPromise<void> {
            return localVarFp.lifiComponentsControllerUpdate(component, updateLifiComponentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComponentManagementApi - object-oriented interface
 * @export
 * @class ComponentManagementApi
 * @extends {BaseAPI}
 */
export class ComponentManagementApi extends BaseAPI {
    /**
     * 
     * @summary Create a component
     * @param {CreateLifiComponentDto} createLifiComponentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentManagementApi
     */
    public lifiComponentsControllerCreate(createLifiComponentDto: CreateLifiComponentDto, options?: AxiosRequestConfig) {
        return ComponentManagementApiFp(this.configuration).lifiComponentsControllerCreate(createLifiComponentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all components
     * @param {boolean} [assigned] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentManagementApi
     */
    public lifiComponentsControllerFindAll(assigned?: boolean, options?: AxiosRequestConfig) {
        return ComponentManagementApiFp(this.configuration).lifiComponentsControllerFindAll(assigned, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a component
     * @param {string} component 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentManagementApi
     */
    public lifiComponentsControllerFindOne(component: string, options?: AxiosRequestConfig) {
        return ComponentManagementApiFp(this.configuration).lifiComponentsControllerFindOne(component, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a component
     * @param {string} component 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentManagementApi
     */
    public lifiComponentsControllerRemove(component: string, options?: AxiosRequestConfig) {
        return ComponentManagementApiFp(this.configuration).lifiComponentsControllerRemove(component, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a component
     * @param {string} component 
     * @param {UpdateLifiComponentDto} updateLifiComponentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentManagementApi
     */
    public lifiComponentsControllerUpdate(component: string, updateLifiComponentDto: UpdateLifiComponentDto, options?: AxiosRequestConfig) {
        return ComponentManagementApiFp(this.configuration).lifiComponentsControllerUpdate(component, updateLifiComponentDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContentManagementApi - axios parameter creator
 * @export
 */
export const ContentManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a content in an hotspot
         * @param {string} hotspot 
         * @param {string} site 
         * @param {CreateLifiContentDto} createLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerCreate: async (hotspot: string, site: string, createLifiContentDto: CreateLifiContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiContentsControllerCreate', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiContentsControllerCreate', 'site', site)
            // verify required parameter 'createLifiContentDto' is not null or undefined
            assertParamExists('lifiContentsControllerCreate', 'createLifiContentDto', createLifiContentDto)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents`
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLifiContentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download an attachment from a content
         * @param {string} attachment 
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerDownloadAttachment: async (attachment: string, content: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('lifiContentsControllerDownloadAttachment', 'attachment', attachment)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiContentsControllerDownloadAttachment', 'content', content)
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiContentsControllerDownloadAttachment', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiContentsControllerDownloadAttachment', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}/attachments/{attachment}`
                .replace(`{${"attachment"}}`, encodeURIComponent(String(attachment)))
                .replace(`{${"content"}}`, encodeURIComponent(String(content)))
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all contents in an hotspot
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerFindAll: async (hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiContentsControllerFindAll', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiContentsControllerFindAll', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents`
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a content in an hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerFindOne: async (content: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiContentsControllerFindOne', 'content', content)
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiContentsControllerFindOne', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiContentsControllerFindOne', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)))
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a content from an hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerRemove: async (content: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiContentsControllerRemove', 'content', content)
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiContentsControllerRemove', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiContentsControllerRemove', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)))
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an attachment from a content
         * @param {string} attachment 
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerRemoveAttachment: async (attachment: string, content: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('lifiContentsControllerRemoveAttachment', 'attachment', attachment)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiContentsControllerRemoveAttachment', 'content', content)
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiContentsControllerRemoveAttachment', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiContentsControllerRemoveAttachment', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}/attachments/{attachment}`
                .replace(`{${"attachment"}}`, encodeURIComponent(String(attachment)))
                .replace(`{${"content"}}`, encodeURIComponent(String(content)))
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a content in an hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {UpdateLifiContentDto} updateLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerUpdate: async (content: string, hotspot: string, site: string, updateLifiContentDto: UpdateLifiContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiContentsControllerUpdate', 'content', content)
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiContentsControllerUpdate', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiContentsControllerUpdate', 'site', site)
            // verify required parameter 'updateLifiContentDto' is not null or undefined
            assertParamExists('lifiContentsControllerUpdate', 'updateLifiContentDto', updateLifiContentDto)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)))
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiContentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an attachment to a content
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {string} name 
         * @param {File} file 
         * @param {string} [accessibility] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerUploadAttachment: async (content: string, hotspot: string, site: string, name: string, file: File, accessibility?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiContentsControllerUploadAttachment', 'content', content)
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiContentsControllerUploadAttachment', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiContentsControllerUploadAttachment', 'site', site)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('lifiContentsControllerUploadAttachment', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('lifiContentsControllerUploadAttachment', 'file', file)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}/attachments`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)))
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (accessibility !== undefined) { 
                localVarFormParams.append('accessibility', accessibility as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentManagementApi - functional programming interface
 * @export
 */
export const ContentManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a content in an hotspot
         * @param {string} hotspot 
         * @param {string} site 
         * @param {CreateLifiContentDto} createLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiContentsControllerCreate(hotspot: string, site: string, createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerCreate(hotspot, site, createLifiContentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download an attachment from a content
         * @param {string} attachment 
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiContentsControllerDownloadAttachment(attachment: string, content: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerDownloadAttachment(attachment, content, hotspot, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all contents in an hotspot
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiContentsControllerFindAll(hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerFindAll(hotspot, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a content in an hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiContentsControllerFindOne(content: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerFindOne(content, hotspot, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a content from an hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiContentsControllerRemove(content: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerRemove(content, hotspot, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an attachment from a content
         * @param {string} attachment 
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiContentsControllerRemoveAttachment(attachment: string, content: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerRemoveAttachment(attachment, content, hotspot, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a content in an hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {UpdateLifiContentDto} updateLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiContentsControllerUpdate(content: string, hotspot: string, site: string, updateLifiContentDto: UpdateLifiContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerUpdate(content, hotspot, site, updateLifiContentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload an attachment to a content
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {string} name 
         * @param {File} file 
         * @param {string} [accessibility] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiContentsControllerUploadAttachment(content: string, hotspot: string, site: string, name: string, file: File, accessibility?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerUploadAttachment(content, hotspot, site, name, file, accessibility, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentManagementApi - factory interface
 * @export
 */
export const ContentManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a content in an hotspot
         * @param {string} hotspot 
         * @param {string} site 
         * @param {CreateLifiContentDto} createLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerCreate(hotspot: string, site: string, createLifiContentDto: CreateLifiContentDto, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.lifiContentsControllerCreate(hotspot, site, createLifiContentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download an attachment from a content
         * @param {string} attachment 
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerDownloadAttachment(attachment: string, content: string, hotspot: string, site: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiContentsControllerDownloadAttachment(attachment, content, hotspot, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all contents in an hotspot
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerFindAll(hotspot: string, site: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiContentsControllerFindAll(hotspot, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a content in an hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerFindOne(content: string, hotspot: string, site: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiContentsControllerFindOne(content, hotspot, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a content from an hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerRemove(content: string, hotspot: string, site: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiContentsControllerRemove(content, hotspot, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an attachment from a content
         * @param {string} attachment 
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerRemoveAttachment(attachment: string, content: string, hotspot: string, site: string, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.lifiContentsControllerRemoveAttachment(attachment, content, hotspot, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a content in an hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {UpdateLifiContentDto} updateLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerUpdate(content: string, hotspot: string, site: string, updateLifiContentDto: UpdateLifiContentDto, options?: any): AxiosPromise<void> {
            return localVarFp.lifiContentsControllerUpdate(content, hotspot, site, updateLifiContentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload an attachment to a content
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {string} name 
         * @param {File} file 
         * @param {string} [accessibility] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiContentsControllerUploadAttachment(content: string, hotspot: string, site: string, name: string, file: File, accessibility?: string, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.lifiContentsControllerUploadAttachment(content, hotspot, site, name, file, accessibility, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentManagementApi - object-oriented interface
 * @export
 * @class ContentManagementApi
 * @extends {BaseAPI}
 */
export class ContentManagementApi extends BaseAPI {
    /**
     * 
     * @summary Create a content in an hotspot
     * @param {string} hotspot 
     * @param {string} site 
     * @param {CreateLifiContentDto} createLifiContentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentManagementApi
     */
    public lifiContentsControllerCreate(hotspot: string, site: string, createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig) {
        return ContentManagementApiFp(this.configuration).lifiContentsControllerCreate(hotspot, site, createLifiContentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download an attachment from a content
     * @param {string} attachment 
     * @param {string} content 
     * @param {string} hotspot 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentManagementApi
     */
    public lifiContentsControllerDownloadAttachment(attachment: string, content: string, hotspot: string, site: string, options?: AxiosRequestConfig) {
        return ContentManagementApiFp(this.configuration).lifiContentsControllerDownloadAttachment(attachment, content, hotspot, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all contents in an hotspot
     * @param {string} hotspot 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentManagementApi
     */
    public lifiContentsControllerFindAll(hotspot: string, site: string, options?: AxiosRequestConfig) {
        return ContentManagementApiFp(this.configuration).lifiContentsControllerFindAll(hotspot, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a content in an hotspot
     * @param {string} content 
     * @param {string} hotspot 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentManagementApi
     */
    public lifiContentsControllerFindOne(content: string, hotspot: string, site: string, options?: AxiosRequestConfig) {
        return ContentManagementApiFp(this.configuration).lifiContentsControllerFindOne(content, hotspot, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a content from an hotspot
     * @param {string} content 
     * @param {string} hotspot 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentManagementApi
     */
    public lifiContentsControllerRemove(content: string, hotspot: string, site: string, options?: AxiosRequestConfig) {
        return ContentManagementApiFp(this.configuration).lifiContentsControllerRemove(content, hotspot, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an attachment from a content
     * @param {string} attachment 
     * @param {string} content 
     * @param {string} hotspot 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentManagementApi
     */
    public lifiContentsControllerRemoveAttachment(attachment: string, content: string, hotspot: string, site: string, options?: AxiosRequestConfig) {
        return ContentManagementApiFp(this.configuration).lifiContentsControllerRemoveAttachment(attachment, content, hotspot, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a content in an hotspot
     * @param {string} content 
     * @param {string} hotspot 
     * @param {string} site 
     * @param {UpdateLifiContentDto} updateLifiContentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentManagementApi
     */
    public lifiContentsControllerUpdate(content: string, hotspot: string, site: string, updateLifiContentDto: UpdateLifiContentDto, options?: AxiosRequestConfig) {
        return ContentManagementApiFp(this.configuration).lifiContentsControllerUpdate(content, hotspot, site, updateLifiContentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload an attachment to a content
     * @param {string} content 
     * @param {string} hotspot 
     * @param {string} site 
     * @param {string} name 
     * @param {File} file 
     * @param {string} [accessibility] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentManagementApi
     */
    public lifiContentsControllerUploadAttachment(content: string, hotspot: string, site: string, name: string, file: File, accessibility?: string, options?: AxiosRequestConfig) {
        return ContentManagementApiFp(this.configuration).lifiContentsControllerUploadAttachment(content, hotspot, site, name, file, accessibility, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FAQsManagementApi - axios parameter creator
 * @export
 */
export const FAQsManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a FAQ
         * @param {CreateFaqDto} createFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerCreate: async (createFaqDto: CreateFaqDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFaqDto' is not null or undefined
            assertParamExists('faqControllerCreate', 'createFaqDto', createFaqDto)
            const localVarPath = `/faq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFaqDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all FAQs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/faq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a FAQ
         * @param {string} faq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerFindOne: async (faq: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faq' is not null or undefined
            assertParamExists('faqControllerFindOne', 'faq', faq)
            const localVarPath = `/faq/{faq}`
                .replace(`{${"faq"}}`, encodeURIComponent(String(faq)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a FAQ
         * @param {string} faq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerRemove: async (faq: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faq' is not null or undefined
            assertParamExists('faqControllerRemove', 'faq', faq)
            const localVarPath = `/faq/{faq}`
                .replace(`{${"faq"}}`, encodeURIComponent(String(faq)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a FAQ
         * @param {string} faq 
         * @param {UpdateFaqDto} updateFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerUpdate: async (faq: string, updateFaqDto: UpdateFaqDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faq' is not null or undefined
            assertParamExists('faqControllerUpdate', 'faq', faq)
            // verify required parameter 'updateFaqDto' is not null or undefined
            assertParamExists('faqControllerUpdate', 'updateFaqDto', updateFaqDto)
            const localVarPath = `/faq/{faq}`
                .replace(`{${"faq"}}`, encodeURIComponent(String(faq)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFaqDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FAQsManagementApi - functional programming interface
 * @export
 */
export const FAQsManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FAQsManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a FAQ
         * @param {CreateFaqDto} createFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqControllerCreate(createFaqDto: CreateFaqDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerCreate(createFaqDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all FAQs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Faq>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a FAQ
         * @param {string} faq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqControllerFindOne(faq: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Faq>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerFindOne(faq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a FAQ
         * @param {string} faq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqControllerRemove(faq: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerRemove(faq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a FAQ
         * @param {string} faq 
         * @param {UpdateFaqDto} updateFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqControllerUpdate(faq: string, updateFaqDto: UpdateFaqDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Faq>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerUpdate(faq, updateFaqDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FAQsManagementApi - factory interface
 * @export
 */
export const FAQsManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FAQsManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a FAQ
         * @param {CreateFaqDto} createFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerCreate(createFaqDto: CreateFaqDto, options?: any): AxiosPromise<void> {
            return localVarFp.faqControllerCreate(createFaqDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all FAQs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerFindAll(options?: any): AxiosPromise<Array<Faq>> {
            return localVarFp.faqControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a FAQ
         * @param {string} faq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerFindOne(faq: string, options?: any): AxiosPromise<Faq> {
            return localVarFp.faqControllerFindOne(faq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a FAQ
         * @param {string} faq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerRemove(faq: string, options?: any): AxiosPromise<void> {
            return localVarFp.faqControllerRemove(faq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a FAQ
         * @param {string} faq 
         * @param {UpdateFaqDto} updateFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerUpdate(faq: string, updateFaqDto: UpdateFaqDto, options?: any): AxiosPromise<Faq> {
            return localVarFp.faqControllerUpdate(faq, updateFaqDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FAQsManagementApi - object-oriented interface
 * @export
 * @class FAQsManagementApi
 * @extends {BaseAPI}
 */
export class FAQsManagementApi extends BaseAPI {
    /**
     * 
     * @summary Create a FAQ
     * @param {CreateFaqDto} createFaqDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FAQsManagementApi
     */
    public faqControllerCreate(createFaqDto: CreateFaqDto, options?: AxiosRequestConfig) {
        return FAQsManagementApiFp(this.configuration).faqControllerCreate(createFaqDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all FAQs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FAQsManagementApi
     */
    public faqControllerFindAll(options?: AxiosRequestConfig) {
        return FAQsManagementApiFp(this.configuration).faqControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a FAQ
     * @param {string} faq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FAQsManagementApi
     */
    public faqControllerFindOne(faq: string, options?: AxiosRequestConfig) {
        return FAQsManagementApiFp(this.configuration).faqControllerFindOne(faq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a FAQ
     * @param {string} faq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FAQsManagementApi
     */
    public faqControllerRemove(faq: string, options?: AxiosRequestConfig) {
        return FAQsManagementApiFp(this.configuration).faqControllerRemove(faq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a FAQ
     * @param {string} faq 
     * @param {UpdateFaqDto} updateFaqDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FAQsManagementApi
     */
    public faqControllerUpdate(faq: string, updateFaqDto: UpdateFaqDto, options?: AxiosRequestConfig) {
        return FAQsManagementApiFp(this.configuration).faqControllerUpdate(faq, updateFaqDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GuestAreaApi - axios parameter creator
 * @export
 */
export const GuestAreaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a FAQ
         * @param {CreateFaqDto} createFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerCreate: async (createFaqDto: CreateFaqDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFaqDto' is not null or undefined
            assertParamExists('faqControllerCreate', 'createFaqDto', createFaqDto)
            const localVarPath = `/faq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFaqDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a FAQ
         * @param {string} faq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerFindOne: async (faq: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faq' is not null or undefined
            assertParamExists('faqControllerFindOne', 'faq', faq)
            const localVarPath = `/faq/{faq}`
                .replace(`{${"faq"}}`, encodeURIComponent(String(faq)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuestAreaApi - functional programming interface
 * @export
 */
export const GuestAreaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuestAreaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a FAQ
         * @param {CreateFaqDto} createFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqControllerCreate(createFaqDto: CreateFaqDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerCreate(createFaqDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a FAQ
         * @param {string} faq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faqControllerFindOne(faq: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Faq>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerFindOne(faq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GuestAreaApi - factory interface
 * @export
 */
export const GuestAreaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuestAreaApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a FAQ
         * @param {CreateFaqDto} createFaqDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerCreate(createFaqDto: CreateFaqDto, options?: any): AxiosPromise<void> {
            return localVarFp.faqControllerCreate(createFaqDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a FAQ
         * @param {string} faq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faqControllerFindOne(faq: string, options?: any): AxiosPromise<Faq> {
            return localVarFp.faqControllerFindOne(faq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuestAreaApi - object-oriented interface
 * @export
 * @class GuestAreaApi
 * @extends {BaseAPI}
 */
export class GuestAreaApi extends BaseAPI {
    /**
     * 
     * @summary Create a FAQ
     * @param {CreateFaqDto} createFaqDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestAreaApi
     */
    public faqControllerCreate(createFaqDto: CreateFaqDto, options?: AxiosRequestConfig) {
        return GuestAreaApiFp(this.configuration).faqControllerCreate(createFaqDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a FAQ
     * @param {string} faq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestAreaApi
     */
    public faqControllerFindOne(faq: string, options?: AxiosRequestConfig) {
        return GuestAreaApiFp(this.configuration).faqControllerFindOne(faq, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GuestsAreaApi - axios parameter creator
 * @export
 */
export const GuestsAreaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all hotspots in site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindAllHotspots: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('guestLifiContentsControllerFindAllHotspots', 'site', site)
            const localVarPath = `/contents/{site}`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all active public contents from hotspot
         * @param {string} hotspot 
         * @param {string} site 
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindAllPublicContents: async (hotspot: string, site: string, offline?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('guestLifiContentsControllerFindAllPublicContents', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('guestLifiContentsControllerFindAllPublicContents', 'site', site)
            const localVarPath = `/contents/{site}/{hotspot}`
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offline !== undefined) {
                localVarQueryParameter['offline'] = offline;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all network type active public contents
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindAllPublicNetworkContents: async (offline?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contents/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offline !== undefined) {
                localVarQueryParameter['offline'] = offline;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all network type active public contents for specified site
         * @param {string} site 
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindAllPublicNetworkContentsFromSite: async (site: string, offline?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('guestLifiContentsControllerFindAllPublicNetworkContentsFromSite', 'site', site)
            const localVarPath = `/contents/{site}/network`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offline !== undefined) {
                localVarQueryParameter['offline'] = offline;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get single active public content from hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindOnePublicContent: async (content: string, hotspot: string, site: string, offline?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('guestLifiContentsControllerFindOnePublicContent', 'content', content)
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('guestLifiContentsControllerFindOnePublicContent', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('guestLifiContentsControllerFindOnePublicContent', 'site', site)
            const localVarPath = `/contents/{site}/{hotspot}/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)))
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offline !== undefined) {
                localVarQueryParameter['offline'] = offline;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get single network type active public content
         * @param {string} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindOnePublicNetworkContent: async (content: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('guestLifiContentsControllerFindOnePublicNetworkContent', 'content', content)
            const localVarPath = `/contents/network/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get single network type active public content for specified site
         * @param {string} content 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindOnePublicNetworkContentFromSite: async (content: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('guestLifiContentsControllerFindOnePublicNetworkContentFromSite', 'content', content)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('guestLifiContentsControllerFindOnePublicNetworkContentFromSite', 'site', site)
            const localVarPath = `/contents/{site}/network/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Locate a hotspot in a site
         * @param {string} site 
         * @param {string} [componentId] 
         * @param {string} [lookup] 
         * @param {number} [latitude] 
         * @param {number} [longitude] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerLocate: async (site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiHotspotControllerLocate', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/locate`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (componentId !== undefined) {
                localVarQueryParameter['componentId'] = componentId;
            }

            if (lookup !== undefined) {
                localVarQueryParameter['lookup'] = lookup;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Locate a site near a given position
         * @param {number} latitude 
         * @param {number} longitude 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerLocate: async (latitude: number, longitude: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('lifiSitesControllerLocate', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('lifiSitesControllerLocate', 'longitude', longitude)
            const localVarPath = `/lifi-sites/locate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuestsAreaApi - functional programming interface
 * @export
 */
export const GuestsAreaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuestsAreaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all hotspots in site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestLifiContentsControllerFindAllHotspots(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiHotspot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindAllHotspots(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all active public contents from hotspot
         * @param {string} hotspot 
         * @param {string} site 
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestLifiContentsControllerFindAllPublicContents(hotspot: string, site: string, offline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiContent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindAllPublicContents(hotspot, site, offline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all network type active public contents
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestLifiContentsControllerFindAllPublicNetworkContents(offline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiContent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindAllPublicNetworkContents(offline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all network type active public contents for specified site
         * @param {string} site 
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site: string, offline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiContent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site, offline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get single active public content from hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestLifiContentsControllerFindOnePublicContent(content: string, hotspot: string, site: string, offline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindOnePublicContent(content, hotspot, site, offline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get single network type active public content
         * @param {string} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestLifiContentsControllerFindOnePublicNetworkContent(content: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindOnePublicNetworkContent(content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get single network type active public content for specified site
         * @param {string} content 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Locate a hotspot in a site
         * @param {string} site 
         * @param {string} [componentId] 
         * @param {string} [lookup] 
         * @param {number} [latitude] 
         * @param {number} [longitude] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiHotspot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Locate a site near a given position
         * @param {number} latitude 
         * @param {number} longitude 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerLocate(latitude: number, longitude: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerLocate(latitude, longitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GuestsAreaApi - factory interface
 * @export
 */
export const GuestsAreaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuestsAreaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all hotspots in site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindAllHotspots(site: string, options?: any): AxiosPromise<Array<LifiHotspot>> {
            return localVarFp.guestLifiContentsControllerFindAllHotspots(site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all active public contents from hotspot
         * @param {string} hotspot 
         * @param {string} site 
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindAllPublicContents(hotspot: string, site: string, offline?: boolean, options?: any): AxiosPromise<Array<LifiContent>> {
            return localVarFp.guestLifiContentsControllerFindAllPublicContents(hotspot, site, offline, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all network type active public contents
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindAllPublicNetworkContents(offline?: boolean, options?: any): AxiosPromise<Array<LifiContent>> {
            return localVarFp.guestLifiContentsControllerFindAllPublicNetworkContents(offline, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all network type active public contents for specified site
         * @param {string} site 
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site: string, offline?: boolean, options?: any): AxiosPromise<Array<LifiContent>> {
            return localVarFp.guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site, offline, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get single active public content from hotspot
         * @param {string} content 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {boolean} [offline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindOnePublicContent(content: string, hotspot: string, site: string, offline?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.guestLifiContentsControllerFindOnePublicContent(content, hotspot, site, offline, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get single network type active public content
         * @param {string} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindOnePublicNetworkContent(content: string, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.guestLifiContentsControllerFindOnePublicNetworkContent(content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get single network type active public content for specified site
         * @param {string} content 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content: string, site: string, options?: any): AxiosPromise<void> {
            return localVarFp.guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Locate a hotspot in a site
         * @param {string} site 
         * @param {string} [componentId] 
         * @param {string} [lookup] 
         * @param {number} [latitude] 
         * @param {number} [longitude] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: any): AxiosPromise<LifiHotspot> {
            return localVarFp.lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Locate a site near a given position
         * @param {number} latitude 
         * @param {number} longitude 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerLocate(latitude: number, longitude: number, options?: any): AxiosPromise<LifiSite> {
            return localVarFp.lifiSitesControllerLocate(latitude, longitude, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuestsAreaApi - object-oriented interface
 * @export
 * @class GuestsAreaApi
 * @extends {BaseAPI}
 */
export class GuestsAreaApi extends BaseAPI {
    /**
     * 
     * @summary Get all hotspots in site
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsAreaApi
     */
    public guestLifiContentsControllerFindAllHotspots(site: string, options?: AxiosRequestConfig) {
        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindAllHotspots(site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all active public contents from hotspot
     * @param {string} hotspot 
     * @param {string} site 
     * @param {boolean} [offline] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsAreaApi
     */
    public guestLifiContentsControllerFindAllPublicContents(hotspot: string, site: string, offline?: boolean, options?: AxiosRequestConfig) {
        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindAllPublicContents(hotspot, site, offline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all network type active public contents
     * @param {boolean} [offline] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsAreaApi
     */
    public guestLifiContentsControllerFindAllPublicNetworkContents(offline?: boolean, options?: AxiosRequestConfig) {
        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindAllPublicNetworkContents(offline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all network type active public contents for specified site
     * @param {string} site 
     * @param {boolean} [offline] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsAreaApi
     */
    public guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site: string, offline?: boolean, options?: AxiosRequestConfig) {
        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site, offline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get single active public content from hotspot
     * @param {string} content 
     * @param {string} hotspot 
     * @param {string} site 
     * @param {boolean} [offline] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsAreaApi
     */
    public guestLifiContentsControllerFindOnePublicContent(content: string, hotspot: string, site: string, offline?: boolean, options?: AxiosRequestConfig) {
        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindOnePublicContent(content, hotspot, site, offline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get single network type active public content
     * @param {string} content 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsAreaApi
     */
    public guestLifiContentsControllerFindOnePublicNetworkContent(content: string, options?: AxiosRequestConfig) {
        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindOnePublicNetworkContent(content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get single network type active public content for specified site
     * @param {string} content 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsAreaApi
     */
    public guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content: string, site: string, options?: AxiosRequestConfig) {
        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Locate a hotspot in a site
     * @param {string} site 
     * @param {string} [componentId] 
     * @param {string} [lookup] 
     * @param {number} [latitude] 
     * @param {number} [longitude] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsAreaApi
     */
    public lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: AxiosRequestConfig) {
        return GuestsAreaApiFp(this.configuration).lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Locate a site near a given position
     * @param {number} latitude 
     * @param {number} longitude 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestsAreaApi
     */
    public lifiSitesControllerLocate(latitude: number, longitude: number, options?: AxiosRequestConfig) {
        return GuestsAreaApiFp(this.configuration).lifiSitesControllerLocate(latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HotspotManagementApi - axios parameter creator
 * @export
 */
export const HotspotManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a component to a hotspot in a site
         * @param {string} component 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerAssignComponent: async (component: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'component' is not null or undefined
            assertParamExists('lifiHotspotControllerAssignComponent', 'component', component)
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiHotspotControllerAssignComponent', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiHotspotControllerAssignComponent', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-components/{component}`
                .replace(`{${"component"}}`, encodeURIComponent(String(component)))
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a hotspot in a site
         * @param {string} site 
         * @param {CreateLifiHotspotDto} createLifiHotspotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerCreate: async (site: string, createLifiHotspotDto: CreateLifiHotspotDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiHotspotControllerCreate', 'site', site)
            // verify required parameter 'createLifiHotspotDto' is not null or undefined
            assertParamExists('lifiHotspotControllerCreate', 'createLifiHotspotDto', createLifiHotspotDto)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLifiHotspotDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a component from a hotspot in a site
         * @param {string} component 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerDismissComponent: async (component: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'component' is not null or undefined
            assertParamExists('lifiHotspotControllerDismissComponent', 'component', component)
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiHotspotControllerDismissComponent', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiHotspotControllerDismissComponent', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-components/{component}`
                .replace(`{${"component"}}`, encodeURIComponent(String(component)))
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all hotspots from a site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerFindAll: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiHotspotControllerFindAll', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all components assigned to a hotspot from a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerFindAssignedComponents: async (hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiHotspotControllerFindAssignedComponents', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiHotspotControllerFindAssignedComponents', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-components`
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a hotspot in a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerFindOne: async (hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiHotspotControllerFindOne', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiHotspotControllerFindOne', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}`
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Locate a hotspot in a site
         * @param {string} site 
         * @param {string} [componentId] 
         * @param {string} [lookup] 
         * @param {number} [latitude] 
         * @param {number} [longitude] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerLocate: async (site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiHotspotControllerLocate', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/locate`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (componentId !== undefined) {
                localVarQueryParameter['componentId'] = componentId;
            }

            if (lookup !== undefined) {
                localVarQueryParameter['lookup'] = lookup;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a hotspot from a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerRemove: async (hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiHotspotControllerRemove', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiHotspotControllerRemove', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}`
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a hotspot in a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {UpdateLifiHotspotDto} updateLifiHotspotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerUpdate: async (hotspot: string, site: string, updateLifiHotspotDto: UpdateLifiHotspotDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotspot' is not null or undefined
            assertParamExists('lifiHotspotControllerUpdate', 'hotspot', hotspot)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiHotspotControllerUpdate', 'site', site)
            // verify required parameter 'updateLifiHotspotDto' is not null or undefined
            assertParamExists('lifiHotspotControllerUpdate', 'updateLifiHotspotDto', updateLifiHotspotDto)
            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}`
                .replace(`{${"hotspot"}}`, encodeURIComponent(String(hotspot)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiHotspotDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HotspotManagementApi - functional programming interface
 * @export
 */
export const HotspotManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HotspotManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a component to a hotspot in a site
         * @param {string} component 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiHotspotControllerAssignComponent(component: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiComponent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerAssignComponent(component, hotspot, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a hotspot in a site
         * @param {string} site 
         * @param {CreateLifiHotspotDto} createLifiHotspotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiHotspotControllerCreate(site: string, createLifiHotspotDto: CreateLifiHotspotDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiHotspot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerCreate(site, createLifiHotspotDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a component from a hotspot in a site
         * @param {string} component 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiHotspotControllerDismissComponent(component: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiComponent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerDismissComponent(component, hotspot, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all hotspots from a site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiHotspotControllerFindAll(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiHotspot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerFindAll(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all components assigned to a hotspot from a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiHotspotControllerFindAssignedComponents(hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiComponent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerFindAssignedComponents(hotspot, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a hotspot in a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiHotspotControllerFindOne(hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiHotspot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerFindOne(hotspot, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Locate a hotspot in a site
         * @param {string} site 
         * @param {string} [componentId] 
         * @param {string} [lookup] 
         * @param {number} [latitude] 
         * @param {number} [longitude] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiHotspot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a hotspot from a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiHotspotControllerRemove(hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerRemove(hotspot, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a hotspot in a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {UpdateLifiHotspotDto} updateLifiHotspotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiHotspotControllerUpdate(hotspot: string, site: string, updateLifiHotspotDto: UpdateLifiHotspotDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerUpdate(hotspot, site, updateLifiHotspotDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HotspotManagementApi - factory interface
 * @export
 */
export const HotspotManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HotspotManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a component to a hotspot in a site
         * @param {string} component 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerAssignComponent(component: string, hotspot: string, site: string, options?: any): AxiosPromise<LifiComponent> {
            return localVarFp.lifiHotspotControllerAssignComponent(component, hotspot, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a hotspot in a site
         * @param {string} site 
         * @param {CreateLifiHotspotDto} createLifiHotspotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerCreate(site: string, createLifiHotspotDto: CreateLifiHotspotDto, options?: any): AxiosPromise<LifiHotspot> {
            return localVarFp.lifiHotspotControllerCreate(site, createLifiHotspotDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a component from a hotspot in a site
         * @param {string} component 
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerDismissComponent(component: string, hotspot: string, site: string, options?: any): AxiosPromise<LifiComponent> {
            return localVarFp.lifiHotspotControllerDismissComponent(component, hotspot, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all hotspots from a site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerFindAll(site: string, options?: any): AxiosPromise<Array<LifiHotspot>> {
            return localVarFp.lifiHotspotControllerFindAll(site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all components assigned to a hotspot from a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerFindAssignedComponents(hotspot: string, site: string, options?: any): AxiosPromise<Array<LifiComponent>> {
            return localVarFp.lifiHotspotControllerFindAssignedComponents(hotspot, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a hotspot in a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerFindOne(hotspot: string, site: string, options?: any): AxiosPromise<LifiHotspot> {
            return localVarFp.lifiHotspotControllerFindOne(hotspot, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Locate a hotspot in a site
         * @param {string} site 
         * @param {string} [componentId] 
         * @param {string} [lookup] 
         * @param {number} [latitude] 
         * @param {number} [longitude] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: any): AxiosPromise<LifiHotspot> {
            return localVarFp.lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a hotspot from a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerRemove(hotspot: string, site: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiHotspotControllerRemove(hotspot, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a hotspot in a site
         * @param {string} hotspot 
         * @param {string} site 
         * @param {UpdateLifiHotspotDto} updateLifiHotspotDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiHotspotControllerUpdate(hotspot: string, site: string, updateLifiHotspotDto: UpdateLifiHotspotDto, options?: any): AxiosPromise<void> {
            return localVarFp.lifiHotspotControllerUpdate(hotspot, site, updateLifiHotspotDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HotspotManagementApi - object-oriented interface
 * @export
 * @class HotspotManagementApi
 * @extends {BaseAPI}
 */
export class HotspotManagementApi extends BaseAPI {
    /**
     * 
     * @summary Assign a component to a hotspot in a site
     * @param {string} component 
     * @param {string} hotspot 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotspotManagementApi
     */
    public lifiHotspotControllerAssignComponent(component: string, hotspot: string, site: string, options?: AxiosRequestConfig) {
        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerAssignComponent(component, hotspot, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a hotspot in a site
     * @param {string} site 
     * @param {CreateLifiHotspotDto} createLifiHotspotDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotspotManagementApi
     */
    public lifiHotspotControllerCreate(site: string, createLifiHotspotDto: CreateLifiHotspotDto, options?: AxiosRequestConfig) {
        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerCreate(site, createLifiHotspotDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a component from a hotspot in a site
     * @param {string} component 
     * @param {string} hotspot 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotspotManagementApi
     */
    public lifiHotspotControllerDismissComponent(component: string, hotspot: string, site: string, options?: AxiosRequestConfig) {
        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerDismissComponent(component, hotspot, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all hotspots from a site
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotspotManagementApi
     */
    public lifiHotspotControllerFindAll(site: string, options?: AxiosRequestConfig) {
        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerFindAll(site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all components assigned to a hotspot from a site
     * @param {string} hotspot 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotspotManagementApi
     */
    public lifiHotspotControllerFindAssignedComponents(hotspot: string, site: string, options?: AxiosRequestConfig) {
        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerFindAssignedComponents(hotspot, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a hotspot in a site
     * @param {string} hotspot 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotspotManagementApi
     */
    public lifiHotspotControllerFindOne(hotspot: string, site: string, options?: AxiosRequestConfig) {
        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerFindOne(hotspot, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Locate a hotspot in a site
     * @param {string} site 
     * @param {string} [componentId] 
     * @param {string} [lookup] 
     * @param {number} [latitude] 
     * @param {number} [longitude] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotspotManagementApi
     */
    public lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: AxiosRequestConfig) {
        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a hotspot from a site
     * @param {string} hotspot 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotspotManagementApi
     */
    public lifiHotspotControllerRemove(hotspot: string, site: string, options?: AxiosRequestConfig) {
        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerRemove(hotspot, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a hotspot in a site
     * @param {string} hotspot 
     * @param {string} site 
     * @param {UpdateLifiHotspotDto} updateLifiHotspotDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotspotManagementApi
     */
    public lifiHotspotControllerUpdate(hotspot: string, site: string, updateLifiHotspotDto: UpdateLifiHotspotDto, options?: AxiosRequestConfig) {
        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerUpdate(hotspot, site, updateLifiHotspotDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IndexApi - axios parameter creator
 * @export
 */
export const IndexApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IndexApi - functional programming interface
 * @export
 */
export const IndexApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IndexApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IndexApi - factory interface
 * @export
 */
export const IndexApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IndexApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerVersion(options?: any): AxiosPromise<void> {
            return localVarFp.appControllerVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IndexApi - object-oriented interface
 * @export
 * @class IndexApi
 * @extends {BaseAPI}
 */
export class IndexApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexApi
     */
    public appControllerVersion(options?: AxiosRequestConfig) {
        return IndexApiFp(this.configuration).appControllerVersion(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkContentManagementApi - axios parameter creator
 * @export
 */
export const NetworkContentManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a network content, unbound
         * @param {CreateLifiContentDto} createLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerCreate: async (createLifiContentDto: CreateLifiContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLifiContentDto' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerCreate', 'createLifiContentDto', createLifiContentDto)
            const localVarPath = `/lifi-contents/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLifiContentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a network content, assigned to a site
         * @param {string} site 
         * @param {CreateLifiContentDto} createLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerCreateWithSite: async (site: string, createLifiContentDto: CreateLifiContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerCreateWithSite', 'site', site)
            // verify required parameter 'createLifiContentDto' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerCreateWithSite', 'createLifiContentDto', createLifiContentDto)
            const localVarPath = `/lifi-sites/{site}/lifi-contents/network`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLifiContentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download an attachment from a content
         * @param {string} content 
         * @param {string} attachment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerDownloadAttachment: async (content: string, attachment: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerDownloadAttachment', 'content', content)
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerDownloadAttachment', 'attachment', attachment)
            const localVarPath = `/lifi-contents/network/{content}/attachments/{attachment}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)))
                .replace(`{${"attachment"}}`, encodeURIComponent(String(attachment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all network contents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lifi-contents/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all network contents, filtered by site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerFindAllBySite: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerFindAllBySite', 'site', site)
            const localVarPath = `/lifi-sites/{site}/lifi-contents/network`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a network content
         * @param {string} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerFindOne: async (content: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerFindOne', 'content', content)
            const localVarPath = `/lifi-contents/network/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a network content
         * @param {string} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerRemove: async (content: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerRemove', 'content', content)
            const localVarPath = `/lifi-contents/network/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an attachment from a content
         * @param {string} content 
         * @param {string} attachment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerRemoveAttachment: async (content: string, attachment: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerRemoveAttachment', 'content', content)
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerRemoveAttachment', 'attachment', attachment)
            const localVarPath = `/lifi-contents/network/{content}/attachments/{attachment}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)))
                .replace(`{${"attachment"}}`, encodeURIComponent(String(attachment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a network content
         * @param {string} content 
         * @param {UpdateLifiContentDto} updateLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerUpdate: async (content: string, updateLifiContentDto: UpdateLifiContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerUpdate', 'content', content)
            // verify required parameter 'updateLifiContentDto' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerUpdate', 'updateLifiContentDto', updateLifiContentDto)
            const localVarPath = `/lifi-contents/network/{content}`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiContentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an attachment to a content
         * @param {string} content 
         * @param {string} name 
         * @param {File} file 
         * @param {string} [accessibility] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerUploadAttachment: async (content: string, name: string, file: File, accessibility?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerUploadAttachment', 'content', content)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerUploadAttachment', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('lifiNetworkContentsControllerUploadAttachment', 'file', file)
            const localVarPath = `/lifi-contents/network/{content}/attachments`
                .replace(`{${"content"}}`, encodeURIComponent(String(content)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (accessibility !== undefined) { 
                localVarFormParams.append('accessibility', accessibility as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkContentManagementApi - functional programming interface
 * @export
 */
export const NetworkContentManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkContentManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a network content, unbound
         * @param {CreateLifiContentDto} createLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiNetworkContentsControllerCreate(createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerCreate(createLifiContentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a network content, assigned to a site
         * @param {string} site 
         * @param {CreateLifiContentDto} createLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiNetworkContentsControllerCreateWithSite(site: string, createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerCreateWithSite(site, createLifiContentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download an attachment from a content
         * @param {string} content 
         * @param {string} attachment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiNetworkContentsControllerDownloadAttachment(content: string, attachment: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerDownloadAttachment(content, attachment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all network contents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiNetworkContentsControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiContent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all network contents, filtered by site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiNetworkContentsControllerFindAllBySite(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiContent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerFindAllBySite(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a network content
         * @param {string} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiNetworkContentsControllerFindOne(content: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerFindOne(content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a network content
         * @param {string} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiNetworkContentsControllerRemove(content: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerRemove(content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an attachment from a content
         * @param {string} content 
         * @param {string} attachment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiNetworkContentsControllerRemoveAttachment(content: string, attachment: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerRemoveAttachment(content, attachment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a network content
         * @param {string} content 
         * @param {UpdateLifiContentDto} updateLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiNetworkContentsControllerUpdate(content: string, updateLifiContentDto: UpdateLifiContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerUpdate(content, updateLifiContentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload an attachment to a content
         * @param {string} content 
         * @param {string} name 
         * @param {File} file 
         * @param {string} [accessibility] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiNetworkContentsControllerUploadAttachment(content: string, name: string, file: File, accessibility?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerUploadAttachment(content, name, file, accessibility, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkContentManagementApi - factory interface
 * @export
 */
export const NetworkContentManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkContentManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a network content, unbound
         * @param {CreateLifiContentDto} createLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerCreate(createLifiContentDto: CreateLifiContentDto, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.lifiNetworkContentsControllerCreate(createLifiContentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a network content, assigned to a site
         * @param {string} site 
         * @param {CreateLifiContentDto} createLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerCreateWithSite(site: string, createLifiContentDto: CreateLifiContentDto, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.lifiNetworkContentsControllerCreateWithSite(site, createLifiContentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download an attachment from a content
         * @param {string} content 
         * @param {string} attachment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerDownloadAttachment(content: string, attachment: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiNetworkContentsControllerDownloadAttachment(content, attachment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all network contents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerFindAll(options?: any): AxiosPromise<Array<LifiContent>> {
            return localVarFp.lifiNetworkContentsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all network contents, filtered by site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerFindAllBySite(site: string, options?: any): AxiosPromise<Array<LifiContent>> {
            return localVarFp.lifiNetworkContentsControllerFindAllBySite(site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a network content
         * @param {string} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerFindOne(content: string, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.lifiNetworkContentsControllerFindOne(content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a network content
         * @param {string} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerRemove(content: string, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.lifiNetworkContentsControllerRemove(content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an attachment from a content
         * @param {string} content 
         * @param {string} attachment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerRemoveAttachment(content: string, attachment: string, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.lifiNetworkContentsControllerRemoveAttachment(content, attachment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a network content
         * @param {string} content 
         * @param {UpdateLifiContentDto} updateLifiContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerUpdate(content: string, updateLifiContentDto: UpdateLifiContentDto, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.lifiNetworkContentsControllerUpdate(content, updateLifiContentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload an attachment to a content
         * @param {string} content 
         * @param {string} name 
         * @param {File} file 
         * @param {string} [accessibility] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiNetworkContentsControllerUploadAttachment(content: string, name: string, file: File, accessibility?: string, options?: any): AxiosPromise<LifiContent> {
            return localVarFp.lifiNetworkContentsControllerUploadAttachment(content, name, file, accessibility, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkContentManagementApi - object-oriented interface
 * @export
 * @class NetworkContentManagementApi
 * @extends {BaseAPI}
 */
export class NetworkContentManagementApi extends BaseAPI {
    /**
     * 
     * @summary Create a network content, unbound
     * @param {CreateLifiContentDto} createLifiContentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkContentManagementApi
     */
    public lifiNetworkContentsControllerCreate(createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig) {
        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerCreate(createLifiContentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a network content, assigned to a site
     * @param {string} site 
     * @param {CreateLifiContentDto} createLifiContentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkContentManagementApi
     */
    public lifiNetworkContentsControllerCreateWithSite(site: string, createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig) {
        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerCreateWithSite(site, createLifiContentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download an attachment from a content
     * @param {string} content 
     * @param {string} attachment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkContentManagementApi
     */
    public lifiNetworkContentsControllerDownloadAttachment(content: string, attachment: string, options?: AxiosRequestConfig) {
        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerDownloadAttachment(content, attachment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all network contents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkContentManagementApi
     */
    public lifiNetworkContentsControllerFindAll(options?: AxiosRequestConfig) {
        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all network contents, filtered by site
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkContentManagementApi
     */
    public lifiNetworkContentsControllerFindAllBySite(site: string, options?: AxiosRequestConfig) {
        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerFindAllBySite(site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a network content
     * @param {string} content 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkContentManagementApi
     */
    public lifiNetworkContentsControllerFindOne(content: string, options?: AxiosRequestConfig) {
        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerFindOne(content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a network content
     * @param {string} content 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkContentManagementApi
     */
    public lifiNetworkContentsControllerRemove(content: string, options?: AxiosRequestConfig) {
        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerRemove(content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an attachment from a content
     * @param {string} content 
     * @param {string} attachment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkContentManagementApi
     */
    public lifiNetworkContentsControllerRemoveAttachment(content: string, attachment: string, options?: AxiosRequestConfig) {
        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerRemoveAttachment(content, attachment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a network content
     * @param {string} content 
     * @param {UpdateLifiContentDto} updateLifiContentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkContentManagementApi
     */
    public lifiNetworkContentsControllerUpdate(content: string, updateLifiContentDto: UpdateLifiContentDto, options?: AxiosRequestConfig) {
        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerUpdate(content, updateLifiContentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload an attachment to a content
     * @param {string} content 
     * @param {string} name 
     * @param {File} file 
     * @param {string} [accessibility] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkContentManagementApi
     */
    public lifiNetworkContentsControllerUploadAttachment(content: string, name: string, file: File, accessibility?: string, options?: AxiosRequestConfig) {
        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerUploadAttachment(content, name, file, accessibility, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistryManagementApi - axios parameter creator
 * @export
 */
export const RegistryManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create the registry for the current user
         * @param {CreateRegistryDto} createRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryControllerCreate: async (createRegistryDto: CreateRegistryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRegistryDto' is not null or undefined
            assertParamExists('registryControllerCreate', 'createRegistryDto', createRegistryDto)
            const localVarPath = `/registry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRegistryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current user\'s registry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/registry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the registry for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryControllerRemove: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/registry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the registry for the current user
         * @param {UpdateRegistryDto} updateRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryControllerUpdate: async (updateRegistryDto: UpdateRegistryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateRegistryDto' is not null or undefined
            assertParamExists('registryControllerUpdate', 'updateRegistryDto', updateRegistryDto)
            const localVarPath = `/registry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRegistryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryManagementApi - functional programming interface
 * @export
 */
export const RegistryManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistryManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create the registry for the current user
         * @param {CreateRegistryDto} createRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryControllerCreate(createRegistryDto: CreateRegistryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryControllerCreate(createRegistryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the current user\'s registry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the registry for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryControllerRemove(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryControllerRemove(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the registry for the current user
         * @param {UpdateRegistryDto} updateRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryControllerUpdate(updateRegistryDto: UpdateRegistryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryControllerUpdate(updateRegistryDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistryManagementApi - factory interface
 * @export
 */
export const RegistryManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistryManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create the registry for the current user
         * @param {CreateRegistryDto} createRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryControllerCreate(createRegistryDto: CreateRegistryDto, options?: any): AxiosPromise<Registry> {
            return localVarFp.registryControllerCreate(createRegistryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current user\'s registry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryControllerFindAll(options?: any): AxiosPromise<Registry> {
            return localVarFp.registryControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the registry for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryControllerRemove(options?: any): AxiosPromise<Registry> {
            return localVarFp.registryControllerRemove(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the registry for the current user
         * @param {UpdateRegistryDto} updateRegistryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryControllerUpdate(updateRegistryDto: UpdateRegistryDto, options?: any): AxiosPromise<Registry> {
            return localVarFp.registryControllerUpdate(updateRegistryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistryManagementApi - object-oriented interface
 * @export
 * @class RegistryManagementApi
 * @extends {BaseAPI}
 */
export class RegistryManagementApi extends BaseAPI {
    /**
     * 
     * @summary Create the registry for the current user
     * @param {CreateRegistryDto} createRegistryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryManagementApi
     */
    public registryControllerCreate(createRegistryDto: CreateRegistryDto, options?: AxiosRequestConfig) {
        return RegistryManagementApiFp(this.configuration).registryControllerCreate(createRegistryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current user\'s registry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryManagementApi
     */
    public registryControllerFindAll(options?: AxiosRequestConfig) {
        return RegistryManagementApiFp(this.configuration).registryControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the registry for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryManagementApi
     */
    public registryControllerRemove(options?: AxiosRequestConfig) {
        return RegistryManagementApiFp(this.configuration).registryControllerRemove(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the registry for the current user
     * @param {UpdateRegistryDto} updateRegistryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryManagementApi
     */
    public registryControllerUpdate(updateRegistryDto: UpdateRegistryDto, options?: AxiosRequestConfig) {
        return RegistryManagementApiFp(this.configuration).registryControllerUpdate(updateRegistryDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SitesManagementApi - axios parameter creator
 * @export
 */
export const SitesManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a permission level to a user on an accessible site
         * @param {string} site 
         * @param {AssignUserDto} assignUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerAssign: async (site: string, assignUserDto: AssignUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerAssign', 'site', site)
            // verify required parameter 'assignUserDto' is not null or undefined
            assertParamExists('lifiSitesControllerAssign', 'assignUserDto', assignUserDto)
            const localVarPath = `/lifi-sites/{site}/users`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new site with the given information
         * @summary Create a new site
         * @param {CreateLifiSiteDto} createLifiSiteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerCreate: async (createLifiSiteDto: CreateLifiSiteDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLifiSiteDto' is not null or undefined
            assertParamExists('lifiSitesControllerCreate', 'createLifiSiteDto', createLifiSiteDto)
            const localVarPath = `/lifi-sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLifiSiteDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a logo for this site
         * @param {string} logo 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerDeleteLogo: async (logo: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logo' is not null or undefined
            assertParamExists('lifiSitesControllerDeleteLogo', 'logo', logo)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerDeleteLogo', 'site', site)
            const localVarPath = `/lifi-sites/{site}/logos/{logo}`
                .replace(`{${"logo"}}`, encodeURIComponent(String(logo)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a signify map for this site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerDeleteSignifyMap: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerDeleteSignifyMap', 'site', site)
            const localVarPath = `/lifi-sites/{site}/signify/map`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an assignation to a user from an accessible site
         * @param {string} user 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerDismiss: async (user: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('lifiSitesControllerDismiss', 'user', user)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerDismiss', 'site', site)
            const localVarPath = `/lifi-sites/{site}/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a logo for this site
         * @param {string} logo 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerDownloadLogo: async (logo: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logo' is not null or undefined
            assertParamExists('lifiSitesControllerDownloadLogo', 'logo', logo)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerDownloadLogo', 'site', site)
            const localVarPath = `/lifi-sites/{site}/logos/{logo}`
                .replace(`{${"logo"}}`, encodeURIComponent(String(logo)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a signify map for this site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerDownloadSignifyMap: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerDownloadSignifyMap', 'site', site)
            const localVarPath = `/lifi-sites/{site}/signify/map`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all accessible sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lifi-sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find an accessible site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerFindOne: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerFindOne', 'site', site)
            const localVarPath = `/lifi-sites/{site}`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users that has manager permission over an accessible site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerGetAllUsers: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerGetAllUsers', 'site', site)
            const localVarPath = `/lifi-sites/{site}/users`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Locate a site near a given position
         * @param {number} latitude 
         * @param {number} longitude 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerLocate: async (latitude: number, longitude: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('lifiSitesControllerLocate', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('lifiSitesControllerLocate', 'longitude', longitude)
            const localVarPath = `/lifi-sites/locate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an accessible site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerRemove: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerRemove', 'site', site)
            const localVarPath = `/lifi-sites/{site}`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an accessible site
         * @param {string} site 
         * @param {UpdateLifiSiteDto} updateLifiSiteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerUpdate: async (site: string, updateLifiSiteDto: UpdateLifiSiteDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerUpdate', 'site', site)
            // verify required parameter 'updateLifiSiteDto' is not null or undefined
            assertParamExists('lifiSitesControllerUpdate', 'updateLifiSiteDto', updateLifiSiteDto)
            const localVarPath = `/lifi-sites/{site}`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiSiteDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a logo for this site
         * @param {string} logo 
         * @param {string} site 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerUploadLogo: async (logo: string, site: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logo' is not null or undefined
            assertParamExists('lifiSitesControllerUploadLogo', 'logo', logo)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerUploadLogo', 'site', site)
            const localVarPath = `/lifi-sites/{site}/logos/{logo}`
                .replace(`{${"logo"}}`, encodeURIComponent(String(logo)))
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a signify map for this site
         * @param {string} site 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerUploadSignifyMap: async (site: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('lifiSitesControllerUploadSignifyMap', 'site', site)
            const localVarPath = `/lifi-sites/{site}/signify/map`
                .replace(`{${"site"}}`, encodeURIComponent(String(site)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SitesManagementApi - functional programming interface
 * @export
 */
export const SitesManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SitesManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a permission level to a user on an accessible site
         * @param {string} site 
         * @param {AssignUserDto} assignUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerAssign(site: string, assignUserDto: AssignUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSiteUserAbility>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerAssign(site, assignUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new site with the given information
         * @summary Create a new site
         * @param {CreateLifiSiteDto} createLifiSiteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerCreate(createLifiSiteDto: CreateLifiSiteDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerCreate(createLifiSiteDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a logo for this site
         * @param {string} logo 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerDeleteLogo(logo: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerDeleteLogo(logo, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a signify map for this site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerDeleteSignifyMap(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerDeleteSignifyMap(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an assignation to a user from an accessible site
         * @param {string} user 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerDismiss(user: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSiteUserAbility>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerDismiss(user, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a logo for this site
         * @param {string} logo 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerDownloadLogo(logo: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerDownloadLogo(logo, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a signify map for this site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerDownloadSignifyMap(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerDownloadSignifyMap(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find all accessible sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiSite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find an accessible site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerFindOne(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerFindOne(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all users that has manager permission over an accessible site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerGetAllUsers(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiSiteUserAbility>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerGetAllUsers(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Locate a site near a given position
         * @param {number} latitude 
         * @param {number} longitude 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerLocate(latitude: number, longitude: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerLocate(latitude, longitude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an accessible site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerRemove(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerRemove(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an accessible site
         * @param {string} site 
         * @param {UpdateLifiSiteDto} updateLifiSiteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerUpdate(site: string, updateLifiSiteDto: UpdateLifiSiteDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerUpdate(site, updateLifiSiteDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload a logo for this site
         * @param {string} logo 
         * @param {string} site 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerUploadLogo(logo: string, site: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerUploadLogo(logo, site, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload a signify map for this site
         * @param {string} site 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lifiSitesControllerUploadSignifyMap(site: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerUploadSignifyMap(site, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SitesManagementApi - factory interface
 * @export
 */
export const SitesManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SitesManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a permission level to a user on an accessible site
         * @param {string} site 
         * @param {AssignUserDto} assignUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerAssign(site: string, assignUserDto: AssignUserDto, options?: any): AxiosPromise<LifiSiteUserAbility> {
            return localVarFp.lifiSitesControllerAssign(site, assignUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new site with the given information
         * @summary Create a new site
         * @param {CreateLifiSiteDto} createLifiSiteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerCreate(createLifiSiteDto: CreateLifiSiteDto, options?: any): AxiosPromise<LifiSite> {
            return localVarFp.lifiSitesControllerCreate(createLifiSiteDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a logo for this site
         * @param {string} logo 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerDeleteLogo(logo: string, site: string, options?: any): AxiosPromise<LifiSite> {
            return localVarFp.lifiSitesControllerDeleteLogo(logo, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a signify map for this site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerDeleteSignifyMap(site: string, options?: any): AxiosPromise<LifiSite> {
            return localVarFp.lifiSitesControllerDeleteSignifyMap(site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an assignation to a user from an accessible site
         * @param {string} user 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerDismiss(user: string, site: string, options?: any): AxiosPromise<LifiSiteUserAbility> {
            return localVarFp.lifiSitesControllerDismiss(user, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a logo for this site
         * @param {string} logo 
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerDownloadLogo(logo: string, site: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiSitesControllerDownloadLogo(logo, site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a signify map for this site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerDownloadSignifyMap(site: string, options?: any): AxiosPromise<void> {
            return localVarFp.lifiSitesControllerDownloadSignifyMap(site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find all accessible sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerFindAll(options?: any): AxiosPromise<Array<LifiSite>> {
            return localVarFp.lifiSitesControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find an accessible site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerFindOne(site: string, options?: any): AxiosPromise<LifiSite> {
            return localVarFp.lifiSitesControllerFindOne(site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users that has manager permission over an accessible site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerGetAllUsers(site: string, options?: any): AxiosPromise<Array<LifiSiteUserAbility>> {
            return localVarFp.lifiSitesControllerGetAllUsers(site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Locate a site near a given position
         * @param {number} latitude 
         * @param {number} longitude 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerLocate(latitude: number, longitude: number, options?: any): AxiosPromise<LifiSite> {
            return localVarFp.lifiSitesControllerLocate(latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an accessible site
         * @param {string} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerRemove(site: string, options?: any): AxiosPromise<LifiSite> {
            return localVarFp.lifiSitesControllerRemove(site, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an accessible site
         * @param {string} site 
         * @param {UpdateLifiSiteDto} updateLifiSiteDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerUpdate(site: string, updateLifiSiteDto: UpdateLifiSiteDto, options?: any): AxiosPromise<LifiSite> {
            return localVarFp.lifiSitesControllerUpdate(site, updateLifiSiteDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a logo for this site
         * @param {string} logo 
         * @param {string} site 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerUploadLogo(logo: string, site: string, file?: File, options?: any): AxiosPromise<LifiSite> {
            return localVarFp.lifiSitesControllerUploadLogo(logo, site, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a signify map for this site
         * @param {string} site 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lifiSitesControllerUploadSignifyMap(site: string, file?: File, options?: any): AxiosPromise<LifiSite> {
            return localVarFp.lifiSitesControllerUploadSignifyMap(site, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SitesManagementApi - object-oriented interface
 * @export
 * @class SitesManagementApi
 * @extends {BaseAPI}
 */
export class SitesManagementApi extends BaseAPI {
    /**
     * 
     * @summary Assign a permission level to a user on an accessible site
     * @param {string} site 
     * @param {AssignUserDto} assignUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerAssign(site: string, assignUserDto: AssignUserDto, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerAssign(site, assignUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new site with the given information
     * @summary Create a new site
     * @param {CreateLifiSiteDto} createLifiSiteDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerCreate(createLifiSiteDto: CreateLifiSiteDto, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerCreate(createLifiSiteDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a logo for this site
     * @param {string} logo 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerDeleteLogo(logo: string, site: string, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerDeleteLogo(logo, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a signify map for this site
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerDeleteSignifyMap(site: string, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerDeleteSignifyMap(site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an assignation to a user from an accessible site
     * @param {string} user 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerDismiss(user: string, site: string, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerDismiss(user, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a logo for this site
     * @param {string} logo 
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerDownloadLogo(logo: string, site: string, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerDownloadLogo(logo, site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a signify map for this site
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerDownloadSignifyMap(site: string, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerDownloadSignifyMap(site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find all accessible sites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerFindAll(options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find an accessible site
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerFindOne(site: string, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerFindOne(site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users that has manager permission over an accessible site
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerGetAllUsers(site: string, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerGetAllUsers(site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Locate a site near a given position
     * @param {number} latitude 
     * @param {number} longitude 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerLocate(latitude: number, longitude: number, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerLocate(latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an accessible site
     * @param {string} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerRemove(site: string, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerRemove(site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an accessible site
     * @param {string} site 
     * @param {UpdateLifiSiteDto} updateLifiSiteDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerUpdate(site: string, updateLifiSiteDto: UpdateLifiSiteDto, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerUpdate(site, updateLifiSiteDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a logo for this site
     * @param {string} logo 
     * @param {string} site 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerUploadLogo(logo: string, site: string, file?: File, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerUploadLogo(logo, site, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a signify map for this site
     * @param {string} site 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesManagementApi
     */
    public lifiSitesControllerUploadSignifyMap(site: string, file?: File, options?: AxiosRequestConfig) {
        return SitesManagementApiFp(this.configuration).lifiSitesControllerUploadSignifyMap(site, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserManagementApi - axios parameter creator
 * @export
 */
export const UserManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a user account
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreate: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('usersControllerCreate', 'createUserDto', createUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a user account
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersControllerFindOne', 'user', user)
            const localVarPath = `/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all sites that this user has access to. This is for convenience purposes only.
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetAllUsers: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersControllerGetAllUsers', 'user', user)
            const localVarPath = `/users/{user}/sites`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a user account
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRemove: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersControllerRemove', 'user', user)
            const localVarPath = `/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user account
         * @param {string} user 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdate: async (user: string, updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersControllerUpdate', 'user', user)
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('usersControllerUpdate', 'updateUserDto', updateUserDto)
            const localVarPath = `/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserManagementApi - functional programming interface
 * @export
 */
export const UserManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a user account
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerCreate(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerCreate(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a user account
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindOne(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindOne(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all sites that this user has access to. This is for convenience purposes only.
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetAllUsers(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiSiteUserAbility>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetAllUsers(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a user account
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerRemove(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerRemove(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a user account
         * @param {string} user 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUpdate(user: string, updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUpdate(user, updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserManagementApi - factory interface
 * @export
 */
export const UserManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a user account
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreate(createUserDto: CreateUserDto, options?: any): AxiosPromise<void> {
            return localVarFp.usersControllerCreate(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.usersControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a user account
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne(user: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersControllerFindOne(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all sites that this user has access to. This is for convenience purposes only.
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetAllUsers(user: string, options?: any): AxiosPromise<Array<LifiSiteUserAbility>> {
            return localVarFp.usersControllerGetAllUsers(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a user account
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRemove(user: string, options?: any): AxiosPromise<User> {
            return localVarFp.usersControllerRemove(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user account
         * @param {string} user 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdate(user: string, updateUserDto: UpdateUserDto, options?: any): AxiosPromise<User> {
            return localVarFp.usersControllerUpdate(user, updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserManagementApi - object-oriented interface
 * @export
 * @class UserManagementApi
 * @extends {BaseAPI}
 */
export class UserManagementApi extends BaseAPI {
    /**
     * 
     * @summary Create a user account
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersControllerCreate(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersControllerCreate(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersControllerFindAll(options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a user account
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersControllerFindOne(user: string, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersControllerFindOne(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all sites that this user has access to. This is for convenience purposes only.
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersControllerGetAllUsers(user: string, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersControllerGetAllUsers(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a user account
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersControllerRemove(user: string, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersControllerRemove(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user account
     * @param {string} user 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersControllerUpdate(user: string, updateUserDto: UpdateUserDto, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersControllerUpdate(user, updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


