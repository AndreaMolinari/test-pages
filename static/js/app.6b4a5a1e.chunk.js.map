{"version":3,"sources":["src/Elements/Header.tsx","src/Elements/Background.tsx","src/HomeView.tsx","generated/base.ts","generated/common.ts","generated/api.ts","src/api.ts","generated/configuration.ts","src/LiFiZone.tsx","src/Navigator/Main.navigator.tsx","App.tsx"],"names":["linkTo","useLinkTo","style","flexDirection","justifyContent","onPress","screen","h3","color","size","raised","title","props","theme","useTheme","View","flex","height","backgroundColor","colors","background","children","HomeView","useNavigation","Background","h2","BASE_PATH","replace","BaseAPI","configuration","basePath","axios","globalAxios","this","RequiredError","field","msg","name","Error","DUMMY_BASE_URL","assertParamExists","functionName","paramName","paramValue","undefined","setBearerAuthToObject","object","keyParamName","apiKey","localVarApiKeyValue","accessToken","scopes","localVarAccessTokenValue","setFlattenedQueryParams","urlSearchParams","parameter","key","Array","isArray","forEach","item","Object","keys","currentKey","has","append","set","setSearchParams","url","searchParams","URLSearchParams","search","objects","toString","serializeDataIfNeeded","value","requestOptions","nonString","isJsonMime","headers","JSON","stringify","toPathString","pathname","hash","createRequestFunction","axiosArgs","axiosRequestArgs","options","request","AdminRegistryManagementApiFp","localVarAxiosParamCreator","adminRegistryControllerCreate","user","createRegistryDto","baseOptions","localVarPath","encodeURIComponent","String","localVarUrlObj","URL","localVarRequestOptions","method","localVarHeaderParameter","localVarQueryParameter","headersFromBaseOptions","data","adminRegistryControllerFindAll","adminRegistryControllerRemove","registry","adminRegistryControllerUpdate","updateRegistryDto","AdminRegistryManagementApiAxiosParamCreator","localVarAxiosArgs","AppsManagementApiFp","then","lifiAppsControllerAssign","app","site","lifiAppsControllerCreate","createLifiAppDto","lifiAppsControllerDismiss","lifiAppsControllerFindAll","lifiAppsControllerFindOne","lifiAppsControllerGetAllSites","lifiAppsControllerRemove","lifiAppsControllerUpdate","updateLifiAppDto","AppsManagementApiAxiosParamCreator","AuthApiFp","authControllerChangePassword","changePasswordDto","authControllerGetCsrfToken","authControllerGetProfile","authControllerPresignedProfileImage","authControllerProfileImage","authControllerRefreshToken","refreshTokenDto","authControllerResetPassword","token","authControllerSignIn","signInDto","authControllerSignOut","authControllerSignUp","createUserDto","authControllerUploadFile","file","localVarFormParams","formDataCtor","FormData","authControllerVerifyEmail","AuthApiAxiosParamCreator","AuthApi","ComponentManagementApiFp","lifiComponentsControllerCreate","createLifiComponentDto","lifiComponentsControllerFindAll","assigned","lifiComponentsControllerFindOne","component","lifiComponentsControllerRemove","lifiComponentsControllerUpdate","updateLifiComponentDto","ComponentManagementApiAxiosParamCreator","ContentManagementApiFp","lifiContentsControllerCreate","hotspot","createLifiContentDto","lifiContentsControllerDownloadAttachment","attachment","content","lifiContentsControllerFindAll","lifiContentsControllerFindOne","lifiContentsControllerRemove","lifiContentsControllerRemoveAttachment","lifiContentsControllerUpdate","updateLifiContentDto","lifiContentsControllerUploadAttachment","accessibility","ContentManagementApiAxiosParamCreator","FAQsManagementApiFp","faqControllerCreate","createFaqDto","faqControllerFindAll","faqControllerFindOne","faq","faqControllerRemove","faqControllerUpdate","updateFaqDto","FAQsManagementApiAxiosParamCreator","GuestAreaApiFp","GuestAreaApiAxiosParamCreator","GuestsAreaApiFp","guestLifiContentsControllerFindAllHotspots","guestLifiContentsControllerFindAllPublicContents","offline","guestLifiContentsControllerFindAllPublicNetworkContents","guestLifiContentsControllerFindAllPublicNetworkContentsFromSite","guestLifiContentsControllerFindOnePublicContent","guestLifiContentsControllerFindOnePublicNetworkContent","guestLifiContentsControllerFindOnePublicNetworkContentFromSite","lifiHotspotControllerLocate","componentId","lookup","latitude","longitude","lifiSitesControllerLocate","GuestsAreaApiAxiosParamCreator","HotspotManagementApiFp","lifiHotspotControllerAssignComponent","lifiHotspotControllerCreate","createLifiHotspotDto","lifiHotspotControllerDismissComponent","lifiHotspotControllerFindAll","lifiHotspotControllerFindAssignedComponents","lifiHotspotControllerFindOne","lifiHotspotControllerRemove","lifiHotspotControllerUpdate","updateLifiHotspotDto","HotspotManagementApiAxiosParamCreator","IndexApiFp","appControllerVersion","IndexApiAxiosParamCreator","NetworkContentManagementApiFp","lifiNetworkContentsControllerCreate","lifiNetworkContentsControllerCreateWithSite","lifiNetworkContentsControllerDownloadAttachment","lifiNetworkContentsControllerFindAll","lifiNetworkContentsControllerFindAllBySite","lifiNetworkContentsControllerFindOne","lifiNetworkContentsControllerRemove","lifiNetworkContentsControllerRemoveAttachment","lifiNetworkContentsControllerUpdate","lifiNetworkContentsControllerUploadAttachment","NetworkContentManagementApiAxiosParamCreator","RegistryManagementApiFp","registryControllerCreate","registryControllerFindAll","registryControllerRemove","registryControllerUpdate","RegistryManagementApiAxiosParamCreator","SitesManagementApiFp","lifiSitesControllerAssign","assignUserDto","lifiSitesControllerCreate","createLifiSiteDto","lifiSitesControllerDeleteLogo","logo","lifiSitesControllerDeleteSignifyMap","lifiSitesControllerDismiss","lifiSitesControllerDownloadLogo","lifiSitesControllerDownloadSignifyMap","lifiSitesControllerFindAll","lifiSitesControllerFindOne","lifiSitesControllerGetAllUsers","lifiSitesControllerRemove","lifiSitesControllerUpdate","updateLifiSiteDto","lifiSitesControllerUploadLogo","lifiSitesControllerUploadSignifyMap","SitesManagementApiAxiosParamCreator","UserManagementApiFp","usersControllerCreate","usersControllerFindAll","usersControllerFindOne","usersControllerGetAllUsers","usersControllerRemove","usersControllerUpdate","updateUserDto","UserManagementApiAxiosParamCreator","authApi","param","username","password","mime","jsonMime","RegExp","test","toLowerCase","create","Authorization","TastoConModal","React","useState","isVisible","setIsVisible","useEffect","visible","onBackdropPress","s","Title","styles","StyleSheet","button","margin","BottomSheetComponent","list","containerStyle","titleStyle","login","email","error","console","warn","visibleCosaSotto","setVisibleCosaSotto","buttonStyle","modalProps","map","l","i","Content","NavStack","createNativeStackNavigator","linking","prefixes","prefix","NavigationContainer","fallback","Navigator","initialRouteName","screenOptions","header","Header","Screen","lightColors","primary","secondary","white","black","darkColors","App"],"mappings":"oKAIe,aACb,IAAMA,EAASC,oBACf,OACE,eAAC,SAAM,CACLC,MAAO,CACLC,cAAe,MACfC,eAAgB,gBAChB,UAEF,cAAC,SAAM,CAACC,QAAS,kBAAML,EAAO,CAAEM,OAAQ,UAAU,SAChD,cAAC,OAAI,CAACC,IAAE,kCAEV,cAAC,SAAM,CAACC,MAAO,YAAaC,KAAM,KAAMC,QAAM,EAACC,MAAM,a,gBCZ5C,WAACC,GACd,IAAMC,EAAQC,qBACd,OACE,cAACC,EAAA,QAAI,CACHb,MAAO,CACLc,KAAM,EACNC,OAAQ,IACRC,gBAAiBL,EAAMA,MAAMM,OAAOC,YACpC,SAEDR,EAAMS,YCMEC,EAdY,WACbC,0BACET,qBADd,IAEMd,EAASC,oBAEf,OACE,cAACuB,EAAU,UACT,cAAC,SAAM,CAACnB,QAAS,kBAAML,EAAO,CAAEM,OAAQ,iBAAiB,SACvD,cAAC,OAAI,CAACmB,IAAE,qC,4lBCMT,IAAMC,EAAY,mBAAmBC,QAAQ,OAAQ,IA4B/CC,EAAO,KAGhB,WAAYC,GAAsH,IAA7EC,EAAgB,uDAAGJ,EAAqBK,EAAoB,uDAAGC,UAAW,iBAA1EF,WAAgB,KAAwBC,QACrFF,IACAI,KAAKJ,cAAgBA,EACrBI,KAAKH,SAAWD,EAAcC,UAAYG,KAAKH,aAW9CI,EAAa,gCAEtB,WAAmBC,EAAeC,GAAe,IAAD,EADR,OACQ,aAC5C,cAAMA,IADSD,QAAa,EADhCE,KAAwB,gBAAe,EAGtC,cAJqB,CAIrB,IAJ8BC,Q,ikBC1C5B,IAAMC,EAAiB,sBAOjBC,EAAoB,SAAUC,EAAsBC,EAAmBC,GAChF,GAAmB,OAAfA,QAAsCC,IAAfD,EACvB,MAAM,IAAIT,EAAcQ,EAAU,sBAAuBA,EAAS,uCAAuCD,EAAY,MA+BhHI,GAvBiB,sBAAG,UAAgBC,EAAaC,EAAsBlB,GAChF,GAAIA,GAAiBA,EAAcmB,OAAQ,CACvC,IAAMC,EAAsD,oBAAzBpB,EAAcmB,aACrCnB,EAAcmB,OAAOD,SACrBlB,EAAcmB,OAC1BF,EAAOC,GAAgBE,MALD,GAuBI,sBAAG,UAAgBH,EAAajB,GAC9D,GAAIA,GAAiBA,EAAcqB,YAAa,CAC5C,IAAMA,EAAmD,oBAA9BrB,EAAcqB,kBAC7BrB,EAAcqB,oBACdrB,EAAcqB,YAC1BJ,EAAsB,cAAI,UAAYI,MAE7C,gBAPiC,0CAaL,sBAAG,UAAgBJ,EAAaT,EAAcc,EAAkBtB,GACzF,GAAIA,GAAiBA,EAAcqB,YAAa,CAC5C,IAAME,EAAgE,oBAA9BvB,EAAcqB,kBAC1CrB,EAAcqB,YAAYb,EAAMc,SAChCtB,EAAcqB,YAC1BJ,EAAsB,cAAI,UAAYM,MALjB,GAS7B,SAASC,EAAwBC,EAAkCC,GAAyC,IAAzBC,EAAW,uDAAG,GACpE,kBAAdD,EACHE,MAAMC,QAAQH,GACbA,EAAoBI,SAAQ,SAAAC,GAAI,OAAIP,EAAwBC,EAAiBM,EAAMJ,MAGpFK,OAAOC,KAAKP,GAAWI,SAAQ,SAAAI,GAAU,OACrCV,EAAwBC,EAAiBC,EAAUQ,GAAgBP,GAAc,KAARA,EAAa,IAAM,IAAKO,MAKrGT,EAAgBU,IAAIR,GACpBF,EAAgBW,OAAOT,EAAKD,GAG5BD,EAAgBY,IAAIV,EAAKD,GAS9B,IAAMY,EAAkB,SAAUC,GACgB,IAArD,IAAMC,EAAe,IAAIC,gBAAgBF,EAAIG,QAAQ,mBADHC,EAAO,iCAAPA,EAAO,kBAEzDnB,EAAwBgB,EAAcG,GACtCJ,EAAIG,OAASF,EAAaI,YAOjBC,EAAwB,SAAUC,EAAYC,EAAqB/C,GAC5E,IAAMgD,EAA6B,kBAAVF,EAIzB,OAH2BE,GAAahD,GAAiBA,EAAciD,WACjEjD,EAAciD,WAAWF,EAAeG,QAAQ,iBAChDF,GAEAG,KAAKC,eAAoBrC,IAAV+B,EAAsBA,EAAQ,IAC5CA,GAAS,IAOPO,EAAe,SAAUd,GAClC,OAAOA,EAAIe,SAAWf,EAAIG,OAASH,EAAIgB,MAO9BC,EAAwB,SAAUC,EAAwBtD,EAA4BN,EAAmBG,GAClH,OAAO,WAA0G,IAAtEE,EAAoB,uDAAGC,EAAaF,EAAgB,uDAAGJ,EACxF6D,EAAgB,OAAOD,EAAUE,SAAO,IAAEpB,MAAmB,MAAbvC,OAAa,EAAbA,EAAeC,WAAYA,GAAYwD,EAAUlB,MACvG,OAAOrC,EAAM0D,QAAcF,K,g/BCzC5B,IA6wDMG,EAA+B,SAAS7D,GACjD,IAAM8D,EAtLiD,SAAU9D,GACjE,MAAO,CASH+D,8BAA8B,WAAD,WAAE,UAAOC,EAAcC,GAAkG,IAA5DN,EAA2B,uDAAG,GAEpHhD,EAAkB,gCAAiC,OAAQqD,GAE3DrD,EAAkB,gCAAiC,oBAAqBsD,GACxE,IAIIC,EAJEC,EAAe,yBAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOL,KAEhDM,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBoB,EAAmBO,EAAwBxE,GAExF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnC6B,GA2C9BM,+BAA+B,WAAD,WAAE,UAAOd,GAA0E,IAA5DL,EAA2B,uDAAG,GAE/EhD,EAAkB,iCAAkC,OAAQqD,GAC5D,IAIIE,EAJEC,EAAe,yBAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOL,KAEhDM,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9B8B,GAuC/BO,8BAA8B,WAAD,WAAE,UAAOC,EAAkBhB,GAA0E,IAA5DL,EAA2B,uDAAG,GAEhGhD,EAAkB,gCAAiC,WAAYqE,GAE/DrE,EAAkB,gCAAiC,OAAQqD,GAC3D,IAKIE,EALEC,EAAe,oCAChBrE,QAAQ,aAAmBsE,mBAAmBC,OAAOW,KACrDlF,QAAQ,SAAesE,mBAAmBC,OAAOL,KAEhDM,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAjC6B,GA2C9BS,8BAA8B,WAAD,WAAE,UAAOD,EAAkBhB,EAAckB,GAAkG,IAA5DvB,EAA2B,uDAAG,GAEtIhD,EAAkB,gCAAiC,WAAYqE,GAE/DrE,EAAkB,gCAAiC,OAAQqD,GAE3DrD,EAAkB,gCAAiC,oBAAqBuE,GACxE,IAKIhB,EALEC,EAAe,oCAChBrE,QAAQ,aAAmBsE,mBAAmBC,OAAOW,KACrDlF,QAAQ,SAAesE,mBAAmBC,OAAOL,KAEhDM,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,SAAYP,GAAgBP,GAC/De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBqC,EAAmBV,EAAwBxE,GAExF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,uDAtC6B,IA+CAW,CAA4CnF,GAC9E,MAAO,CASG+D,8BAA6B,gCAACC,EAAcC,EAAsCN,GACpF,IAAMyB,QAA0BtB,EAA0BC,8BAA8BC,EAAMC,EAAmBN,GACjH,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHkC,GAW7B8E,+BAA8B,gCAACd,EAAcL,GAC/C,IAAMyB,QAA0BtB,EAA0BgB,+BAA+Bd,EAAML,GAC/F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHmC,GAY9B+E,8BAA6B,gCAACC,EAAkBhB,EAAcL,GAChE,IAAMyB,QAA0BtB,EAA0BiB,8BAA8BC,EAAUhB,EAAML,GACxG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHkC,GAa7BiF,8BAA6B,gCAACD,EAAkBhB,EAAckB,EAAsCvB,GACtG,IAAMyB,QAA0BtB,EAA0BmB,8BAA8BD,EAAUhB,EAAMkB,EAAmBvB,GAC3H,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,yDAHkC,KAmc9BqF,IAhY0B,0IAUnC,SAAqCrB,EAAcC,EAAsCN,GAA+B,IAAD,OACnH,OAAOE,EAA6BzD,KAAKJ,eAAe+D,8BAA8BC,EAAMC,EAAmBN,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACtK,4CAUD,SAAsC+D,EAAcL,GAA+B,IAAD,OAC9E,OAAOE,EAA6BzD,KAAKJ,eAAe8E,+BAA+Bd,EAAML,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACpJ,2CAWD,SAAqC+E,EAAkBhB,EAAcL,GAA+B,IAAD,OAC/F,OAAOE,EAA6BzD,KAAKJ,eAAe+E,8BAA8BC,EAAUhB,EAAML,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC7J,2CAYD,SAAqC+E,EAAkBhB,EAAckB,EAAsCvB,GAA+B,IAAD,OACrI,OAAOE,EAA6BzD,KAAKJ,eAAeiF,8BAA8BD,EAAUhB,EAAMkB,EAAmBvB,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBAlD9I,CAASF,GAgYb,SAASC,GACxC,IAAM8D,EAtUwC,SAAU9D,GACxD,MAAO,CASHuF,yBAAyB,WAAD,WAAE,UAAOC,EAAaC,GAA0E,IAA5D9B,EAA2B,uDAAG,GAEtFhD,EAAkB,2BAA4B,MAAO6E,GAErD7E,EAAkB,2BAA4B,OAAQ8E,GACtD,IAKIvB,EALEC,EAAe,gCAChBrE,QAAQ,QAAcsE,mBAAmBC,OAAOmB,KAChD1F,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAjCwB,GAyCzBkB,yBAAyB,WAAD,WAAE,UAAOC,GAAgG,IAA5DhC,EAA2B,uDAAG,GAE/FhD,EAAkB,2BAA4B,mBAAoBgF,GAClE,IAGIzB,EAHEC,EAAY,aAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsB8C,EAAkBnB,EAAwBxE,GAEvF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAhCwB,GAyCzBoB,0BAA0B,WAAD,WAAE,UAAOJ,EAAaC,GAA0E,IAA5D9B,EAA2B,uDAAG,GAEvFhD,EAAkB,4BAA6B,MAAO6E,GAEtD7E,EAAkB,4BAA6B,OAAQ8E,GACvD,IAKIvB,EALEC,EAAe,gCAChBrE,QAAQ,QAAcsE,mBAAmBC,OAAOmB,KAChD1F,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAjCyB,GAwC1BqB,0BAA0B,WAAD,WAAE,YAAmE,IAItF3B,EAJ0BP,EAA2B,uDAAG,GACtDQ,EAAY,aAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDA3ByB,GAmC1BsB,0BAA0B,WAAD,WAAE,UAAON,GAAyE,IAA5D7B,EAA2B,uDAAG,GAEzEhD,EAAkB,4BAA6B,MAAO6E,GACtD,IAIItB,EAJEC,EAAe,mBAChBrE,QAAQ,QAAcsE,mBAAmBC,OAAOmB,KAE/ClB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9ByB,GAsC1BuB,8BAA8B,WAAD,WAAE,UAAOP,GAAyE,IAA5D7B,EAA2B,uDAAG,GAE7EhD,EAAkB,gCAAiC,MAAO6E,GAC1D,IAIItB,EAJEC,EAAe,yBAChBrE,QAAQ,QAAcsE,mBAAmBC,OAAOmB,KAE/ClB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9B6B,GAsC9BwB,yBAAyB,WAAD,WAAE,UAAOR,GAAyE,IAA5D7B,EAA2B,uDAAG,GAExEhD,EAAkB,2BAA4B,MAAO6E,GACrD,IAIItB,EAJEC,EAAe,mBAChBrE,QAAQ,QAAcsE,mBAAmBC,OAAOmB,KAE/ClB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9BwB,GAuCzByB,yBAAyB,WAAD,WAAE,UAAOT,EAAaU,GAAgG,IAA5DvC,EAA2B,uDAAG,GAE5GhD,EAAkB,2BAA4B,MAAO6E,GAErD7E,EAAkB,2BAA4B,mBAAoBuF,GAClE,IAIIhC,EAJEC,EAAe,mBAChBrE,QAAQ,QAAcsE,mBAAmBC,OAAOmB,KAE/ClB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,SAAYP,GAAgBP,GAC/De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBqD,EAAkB1B,EAAwBxE,GAEvF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnCwB,IA4CK2B,CAAmCnG,GACrE,MAAO,CASGuF,yBAAwB,gCAACC,EAAaC,EAAc9B,GACtD,IAAMyB,QAA0BtB,EAA0ByB,yBAAyBC,EAAKC,EAAM9B,GAC9F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAH6B,GAWxB0F,yBAAwB,gCAACC,EAAoChC,GAC/D,IAAMyB,QAA0BtB,EAA0B4B,yBAAyBC,EAAkBhC,GACrG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH6B,GAYxB4F,0BAAyB,gCAACJ,EAAaC,EAAc9B,GACvD,IAAMyB,QAA0BtB,EAA0B8B,0BAA0BJ,EAAKC,EAAM9B,GAC/F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAH8B,GAUzB6F,0BAAyB,gCAAClC,GAC5B,IAAMyB,QAA0BtB,EAA0B+B,0BAA0BlC,GACpF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAH8B,GAWzB8F,0BAAyB,gCAACN,EAAa7B,GACzC,IAAMyB,QAA0BtB,EAA0BgC,0BAA0BN,EAAK7B,GACzF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH8B,GAWzB+F,8BAA6B,gCAACP,EAAa7B,GAC7C,IAAMyB,QAA0BtB,EAA0BiC,8BAA8BP,EAAK7B,GAC7F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHkC,GAW7BgG,yBAAwB,gCAACR,EAAa7B,GACxC,IAAMyB,QAA0BtB,EAA0BkC,yBAAyBR,EAAK7B,GACxF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH6B,GAYxBiG,yBAAwB,gCAACT,EAAaU,EAAoCvC,GAC5E,IAAMyB,QAA0BtB,EAA0BmC,yBAAyBT,EAAKU,EAAkBvC,GAC1G,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAH6B,MAsoBzBoG,IA7hBiB,qIAU1B,SAAgCZ,EAAaC,EAAc9B,GAA+B,IAAD,OACrF,OAAO0B,GAAoBjF,KAAKJ,eAAeuF,yBAAyBC,EAAKC,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC1I,sCAUD,SAAgC0F,EAAoChC,GAA+B,IAAD,OAC9F,OAAO0B,GAAoBjF,KAAKJ,eAAe0F,yBAAyBC,EAAkBhC,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACjJ,uCAWD,SAAiCuF,EAAaC,EAAc9B,GAA+B,IAAD,OACtF,OAAO0B,GAAoBjF,KAAKJ,eAAe4F,0BAA0BJ,EAAKC,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC3I,uCASD,SAAiC0D,GAA+B,IAAD,OAC3D,OAAO0B,GAAoBjF,KAAKJ,eAAe6F,0BAA0BlC,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAChI,uCAUD,SAAiCuF,EAAa7B,GAA+B,IAAD,OACxE,OAAO0B,GAAoBjF,KAAKJ,eAAe8F,0BAA0BN,EAAK7B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACrI,2CAUD,SAAqCuF,EAAa7B,GAA+B,IAAD,OAC5E,OAAO0B,GAAoBjF,KAAKJ,eAAe+F,8BAA8BP,EAAK7B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACzI,sCAUD,SAAgCuF,EAAa7B,GAA+B,IAAD,OACvE,OAAO0B,GAAoBjF,KAAKJ,eAAegG,yBAAyBR,EAAK7B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACpI,sCAWD,SAAgCuF,EAAaU,EAAoCvC,GAA+B,IAAD,OAC3G,OAAO0B,GAAoBjF,KAAKJ,eAAeiG,yBAAyBT,EAAKU,EAAkBvC,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBAhG7H,CAASF,GA6hBd,SAASC,GAC9B,IAAM8D,EArb8B,SAAU9D,GAC9C,MAAO,CAQHqG,6BAA6B,WAAD,WAAE,UAAOC,GAAkG,IAA5D3C,EAA2B,uDAAG,GAErGhD,EAAkB,+BAAgC,oBAAqB2F,GACvE,IAGIpC,EAHEC,EAAY,wBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsByD,EAAmB9B,EAAwBxE,GAExF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAhC4B,GAuC7B+B,2BAA2B,WAAD,WAAE,YAAmE,IAIvFrC,EAJ2BP,EAA2B,uDAAG,GACvDQ,EAAY,aAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDAvB0B,GA8B3BgC,yBAAyB,WAAD,WAAE,YAAmE,IAIrFtC,EAJyBP,EAA2B,uDAAG,GACrDQ,EAAY,gBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDA3BwB,GAkCzBiC,oCAAoC,WAAD,WAAE,YAAmE,IAIhGvC,EAJoCP,EAA2B,uDAAG,GAChEQ,EAAY,8BAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDAvBmC,GA8BpCkC,2BAA2B,WAAD,WAAE,YAAmE,IAIvFxC,EAJ2BP,EAA2B,uDAAG,GACvDQ,EAAY,qBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDAvB0B,GA+B3BmC,2BAA2B,WAAD,WAAE,UAAOC,GAA8F,IAA5DjD,EAA2B,uDAAG,GAE/FhD,EAAkB,6BAA8B,kBAAmBiG,GACnE,IAGI1C,EAHEC,EAAY,gBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,GAI/BD,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsB+D,EAAiBpC,EAAwBxE,GAEtF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA5B0B,GAoC3BqC,4BAA4B,WAAD,WAAE,UAAOC,GAA2E,IAA5DnD,EAA2B,uDAAG,GAE7EhD,EAAkB,8BAA+B,QAASmG,GAC1D,IAGI5C,EAHEC,EAAY,uBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,QAEvCe,IAAV+F,IACAnC,EAA8B,MAAImC,GAKtCxE,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAjC2B,GAyC5BuC,qBAAqB,WAAD,WAAE,UAAOC,GAAkF,IAA5DrD,EAA2B,uDAAG,GAE7EhD,EAAkB,uBAAwB,YAAaqG,GACvD,IAGI9C,EAHEC,EAAY,eAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,GAI/BD,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBmE,EAAWxC,EAAwBxE,GAEhF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA5BoB,GAmCrByC,sBAAsB,WAAD,WAAE,YAAmE,IAIlF/C,EAJsBP,EAA2B,uDAAG,GAClDQ,EAAY,gBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDA3BqB,GAmCtB0C,qBAAqB,WAAD,WAAE,UAAOC,GAA0F,IAA5DxD,EAA2B,uDAAG,GAErFhD,EAAkB,uBAAwB,gBAAiBwG,GAC3D,IAGIjD,EAHEC,EAAY,eAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,GAI/BD,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBsE,EAAe3C,EAAwBxE,GAEpF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA5BoB,GAoCrB4C,yBAAyB,WAAD,WAAE,UAAOC,GAAyE,IAIlGnD,EAJsCP,EAA2B,uDAAG,GAClEQ,EAAY,eAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,GACzB2C,EAAqB,IAAMtH,GAAiBA,EAAcuH,cAAiBC,eAGpEzG,IAATsG,GACAC,EAAmBlF,OAAO,OAAQiF,GAItC3C,EAAwB,gBAAkB,sBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOyC,EAEvB,CACH/E,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA/BwB,GAuCzBiD,0BAA0B,WAAD,WAAE,UAAOX,GAA2E,IAA5DnD,EAA2B,uDAAG,GAE3EhD,EAAkB,4BAA6B,QAASmG,GACxD,IAGI5C,EAHEC,EAAY,qBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,QAEvCe,IAAV+F,IACAnC,EAA8B,MAAImC,GAKtCxE,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAjCyB,IA0CIkD,CAAyB1H,GAC3D,MAAO,CAQGqG,6BAA4B,gCAACC,EAAsC3C,GACrE,IAAMyB,QAA0BtB,EAA0BuC,6BAA6BC,EAAmB3C,GAC1G,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHiC,GAU5BuG,2BAA0B,gCAAC5C,GAC7B,IAAMyB,QAA0BtB,EAA0ByC,2BAA2B5C,GACrF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAH+B,GAU1BwG,yBAAwB,gCAAC7C,GAC3B,IAAMyB,QAA0BtB,EAA0B0C,yBAAyB7C,GACnF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAH6B,GAUxByG,oCAAmC,gCAAC9C,GACtC,IAAMyB,QAA0BtB,EAA0B2C,oCAAoC9C,GAC9F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAHwC,GAUnC0G,2BAA0B,gCAAC/C,GAC7B,IAAMyB,QAA0BtB,EAA0B4C,2BAA2B/C,GACrF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAH+B,GAW1B2G,2BAA0B,gCAACC,EAAkCjD,GAC/D,IAAMyB,QAA0BtB,EAA0B6C,2BAA2BC,EAAiBjD,GACtG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH+B,GAW1B6G,4BAA2B,gCAACC,EAAenD,GAC7C,IAAMyB,QAA0BtB,EAA0B+C,4BAA4BC,EAAOnD,GAC7F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHgC,GAW3B+G,qBAAoB,gCAACC,EAAsBrD,GAC7C,IAAMyB,QAA0BtB,EAA0BiD,qBAAqBC,EAAWrD,GAC1F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHyB,GAUpBiH,sBAAqB,gCAACtD,GACxB,IAAMyB,QAA0BtB,EAA0BmD,sBAAsBtD,GAChF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAH0B,GAWrBkH,qBAAoB,gCAACC,EAA8BxD,GACrD,IAAMyB,QAA0BtB,EAA0BoD,qBAAqBC,EAAexD,GAC9F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHyB,GAWpBoH,yBAAwB,gCAACC,EAAa1D,GACxC,IAAMyB,QAA0BtB,EAA0BsD,yBAAyBC,EAAM1D,GACzF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH6B,GAWxByH,0BAAyB,gCAACX,EAAenD,GAC3C,IAAMyB,QAA0BtB,EAA0B2D,0BAA0BX,EAAOnD,GAC3F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH8B,MA0I1B2H,GAAO,wFA0If,OA1Ie,iDAShB,SAAoCrB,EAAsC3C,GAA+B,IAAD,OACpG,OAAOyC,GAAUhG,KAAKJ,eAAeqG,6BAA6BC,EAAmB3C,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC5I,wCASD,SAAkC0D,GAA+B,IAAD,OAC5D,OAAOyC,GAAUhG,KAAKJ,eAAeuG,2BAA2B5C,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACvH,sCASD,SAAgC0D,GAA+B,IAAD,OAC1D,OAAOyC,GAAUhG,KAAKJ,eAAewG,yBAAyB7C,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACrH,iDASD,SAA2C0D,GAA+B,IAAD,OACrE,OAAOyC,GAAUhG,KAAKJ,eAAeyG,oCAAoC9C,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAChI,wCASD,SAAkC0D,GAA+B,IAAD,OAC5D,OAAOyC,GAAUhG,KAAKJ,eAAe0G,2BAA2B/C,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACvH,wCAUD,SAAkC2G,EAAkCjD,GAA+B,IAAD,OAC9F,OAAOyC,GAAUhG,KAAKJ,eAAe2G,2BAA2BC,EAAiBjD,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACxI,yCAUD,SAAmC6G,EAAenD,GAA+B,IAAD,OAC5E,OAAOyC,GAAUhG,KAAKJ,eAAe6G,4BAA4BC,EAAOnD,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC/H,kCAUD,SAA4B+G,EAAsBrD,GAA+B,IAAD,OAC5E,OAAOyC,GAAUhG,KAAKJ,eAAe+G,qBAAqBC,EAAWrD,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC5H,mCASD,SAA6B0D,GAA+B,IAAD,OACvD,OAAOyC,GAAUhG,KAAKJ,eAAeiH,sBAAsBtD,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAClH,kCAUD,SAA4BkH,EAA8BxD,GAA+B,IAAD,OACpF,OAAOyC,GAAUhG,KAAKJ,eAAekH,qBAAqBC,EAAexD,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAChI,sCAUD,SAAgCoH,EAAa1D,GAA+B,IAAD,OACvE,OAAOyC,GAAUhG,KAAKJ,eAAeoH,yBAAyBC,EAAM1D,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC3H,uCAUD,SAAiC6G,EAAenD,GAA+B,IAAD,OAC1E,OAAOyC,GAAUhG,KAAKJ,eAAeyH,0BAA0BX,EAAOnD,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBAC7H,EA1Ie,CAASF,GAkWhB6H,GAA2B,SAAS5H,GAC7C,IAAM8D,EAjN6C,SAAU9D,GAC7D,MAAO,CAQH6H,+BAA+B,WAAD,WAAE,UAAOC,GAA4G,IAA5DnE,EAA2B,uDAAG,GAEjHhD,EAAkB,iCAAkC,yBAA0BmH,GAC9E,IAGI5D,EAHEC,EAAY,mBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBiF,EAAwBtD,EAAwBxE,GAE7F,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAhC8B,GAwC/BuD,gCAAgC,WAAD,WAAE,UAAOC,GAAgF,IAIhH9D,EAJoDP,EAA2B,uDAAG,GAChFQ,EAAY,mBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,QAEpCe,IAAbiH,IACArD,EAAiC,SAAIqD,GAKzC1F,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA/B+B,GAuChCyD,gCAAgC,WAAD,WAAE,UAAOC,GAA+E,IAA5DvE,EAA2B,uDAAG,GAErFhD,EAAkB,kCAAmC,YAAauH,GAClE,IAIIhE,EAJEC,EAAe,+BAChBrE,QAAQ,cAAoBsE,mBAAmBC,OAAO6D,KAErD5D,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9B+B,GAsChC2D,+BAA+B,WAAD,WAAE,UAAOD,GAA+E,IAA5DvE,EAA2B,uDAAG,GAEpFhD,EAAkB,iCAAkC,YAAauH,GACjE,IAIIhE,EAJEC,EAAe,+BAChBrE,QAAQ,cAAoBsE,mBAAmBC,OAAO6D,KAErD5D,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9B8B,GAuC/B4D,+BAA+B,WAAD,WAAE,UAAOF,EAAmBG,GAA4G,IAA5D1E,EAA2B,uDAAG,GAEpIhD,EAAkB,iCAAkC,YAAauH,GAEjEvH,EAAkB,iCAAkC,yBAA0B0H,GAC9E,IAIInE,EAJEC,EAAe,+BAChBrE,QAAQ,cAAoBsE,mBAAmBC,OAAO6D,KAErD5D,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,SAAYP,GAAgBP,GAC/De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBwF,EAAwB7D,EAAwBxE,GAE7F,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnC8B,IA4CD8D,CAAwCtI,GAC1E,MAAO,CAQG6H,+BAA8B,gCAACC,EAAgDnE,GACjF,IAAMyB,QAA0BtB,EAA0B+D,+BAA+BC,EAAwBnE,GACjH,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHmC,GAW9B+H,gCAA+B,gCAACC,EAAoBrE,GACtD,IAAMyB,QAA0BtB,EAA0BiE,gCAAgCC,EAAUrE,GACpG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHoC,GAW/BiI,gCAA+B,gCAACC,EAAmBvE,GACrD,IAAMyB,QAA0BtB,EAA0BmE,gCAAgCC,EAAWvE,GACrG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHoC,GAW/BmI,+BAA8B,gCAACD,EAAmBvE,GACpD,IAAMyB,QAA0BtB,EAA0BqE,+BAA+BD,EAAWvE,GACpG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHmC,GAY9BoI,+BAA8B,gCAACF,EAAmBG,EAAgD1E,GACpG,IAAMyB,QAA0BtB,EAA0BsE,+BAA+BF,EAAWG,EAAwB1E,GAC5H,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHmC,KA0iB/BuI,IAhesB,2IAS/B,SAAsCT,EAAgDnE,GAA+B,IAAD,OAChH,OAAOiE,GAAyBxH,KAAKJ,eAAe6H,+BAA+BC,EAAwBnE,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAClK,6CAUD,SAAuC+H,EAAoBrE,GAA+B,IAAD,OACrF,OAAOiE,GAAyBxH,KAAKJ,eAAe+H,gCAAgCC,EAAUrE,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACrJ,6CAUD,SAAuCiI,EAAmBvE,GAA+B,IAAD,OACpF,OAAOiE,GAAyBxH,KAAKJ,eAAeiI,gCAAgCC,EAAWvE,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACtJ,4CAUD,SAAsCiI,EAAmBvE,GAA+B,IAAD,OACnF,OAAOiE,GAAyBxH,KAAKJ,eAAemI,+BAA+BD,EAAWvE,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACrJ,4CAWD,SAAsCiI,EAAmBG,EAAgD1E,GAA+B,IAAD,OACnI,OAAOiE,GAAyBxH,KAAKJ,eAAeoI,+BAA+BF,EAAWG,EAAwB1E,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBA3D/I,CAASF,GAgeN,SAASC,GAC3C,IAAM8D,EA7Z2C,SAAU9D,GAC3D,MAAO,CAUHwI,6BAA6B,WAAD,WAAE,UAAOC,EAAiBhD,EAAciD,GAAwG,IAA5D/E,EAA2B,uDAAG,GAE1IhD,EAAkB,+BAAgC,UAAW8H,GAE7D9H,EAAkB,+BAAgC,OAAQ8E,GAE1D9E,EAAkB,+BAAgC,uBAAwB+H,GAC1E,IAKIxE,EALEC,EAAe,2DAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsB6F,EAAsBlE,EAAwBxE,GAE3F,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,uDAtC4B,GAiD7BmE,yCAAyC,WAAD,WAAE,UAAOC,EAAoBC,EAAiBJ,EAAiBhD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE/IhD,EAAkB,2CAA4C,aAAciI,GAE5EjI,EAAkB,2CAA4C,UAAWkI,GAEzElI,EAAkB,2CAA4C,UAAW8H,GAEzE9H,EAAkB,2CAA4C,OAAQ8E,GACtE,IAOIvB,EAPEC,EAAe,8FAChBrE,QAAQ,eAAqBsE,mBAAmBC,OAAOuE,KACvD9I,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KACpD/I,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,yDAvCwC,GAgDzCsE,8BAA8B,WAAD,WAAE,UAAOL,EAAiBhD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE/FhD,EAAkB,gCAAiC,UAAW8H,GAE9D9H,EAAkB,gCAAiC,OAAQ8E,GAC3D,IAKIvB,EALEC,EAAe,2DAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAjC6B,GA2C9BuE,8BAA8B,WAAD,WAAE,UAAOF,EAAiBJ,EAAiBhD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAEhHhD,EAAkB,gCAAiC,UAAWkI,GAE9DlI,EAAkB,gCAAiC,UAAW8H,GAE9D9H,EAAkB,gCAAiC,OAAQ8E,GAC3D,IAMIvB,EANEC,EAAe,qEAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KACpD/I,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,uDApC6B,GA8C9BwE,6BAA6B,WAAD,WAAE,UAAOH,EAAiBJ,EAAiBhD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE/GhD,EAAkB,+BAAgC,UAAWkI,GAE7DlI,EAAkB,+BAAgC,UAAW8H,GAE7D9H,EAAkB,+BAAgC,OAAQ8E,GAC1D,IAMIvB,EANEC,EAAe,qEAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KACpD/I,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,uDApC4B,GA+C7ByE,uCAAuC,WAAD,WAAE,UAAOL,EAAoBC,EAAiBJ,EAAiBhD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE7IhD,EAAkB,yCAA0C,aAAciI,GAE1EjI,EAAkB,yCAA0C,UAAWkI,GAEvElI,EAAkB,yCAA0C,UAAW8H,GAEvE9H,EAAkB,yCAA0C,OAAQ8E,GACpE,IAOIvB,EAPEC,EAAe,8FAChBrE,QAAQ,eAAqBsE,mBAAmBC,OAAOuE,KACvD9I,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KACpD/I,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,yDAvCsC,GAkDvC0E,6BAA6B,WAAD,WAAE,UAAOL,EAAiBJ,EAAiBhD,EAAc0D,GAAwG,IAA5DxF,EAA2B,uDAAG,GAE3JhD,EAAkB,+BAAgC,UAAWkI,GAE7DlI,EAAkB,+BAAgC,UAAW8H,GAE7D9H,EAAkB,+BAAgC,OAAQ8E,GAE1D9E,EAAkB,+BAAgC,uBAAwBwI,GAC1E,IAMIjF,EANEC,EAAe,qEAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KACpD/I,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,SAAYP,GAAgBP,GAC/De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBsG,EAAsB3E,EAAwBxE,GAE3F,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,yDAzC4B,GAsD7B4E,uCAAuC,WAAD,WAAE,UAAOP,EAAiBJ,EAAiBhD,EAAcjF,EAAc6G,EAAYgC,GAAoF,IAA5D1F,EAA2B,uDAAG,GAE3KhD,EAAkB,yCAA0C,UAAWkI,GAEvElI,EAAkB,yCAA0C,UAAW8H,GAEvE9H,EAAkB,yCAA0C,OAAQ8E,GAEpE9E,EAAkB,yCAA0C,OAAQH,GAEpEG,EAAkB,yCAA0C,OAAQ0G,GACpE,IAMInD,EANEC,EAAe,iFAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KACpD/I,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,GACzB2C,EAAqB,IAAMtH,GAAiBA,EAAcuH,cAAiBC,gBAI3ExG,EAAsB0D,EAAyB1E,QAGxCe,IAATP,GACA8G,EAAmBlF,OAAO,OAAQ5B,QAGhBO,IAAlBsI,GACA/B,EAAmBlF,OAAO,gBAAiBiH,QAGlCtI,IAATsG,GACAC,EAAmBlF,OAAO,OAAQiF,GAItC3C,EAAwB,gBAAkB,sBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOyC,EAEvB,CACH/E,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,6DAxDsC,IAiET8E,CAAsCtJ,GACxE,MAAO,CAUGwI,6BAA4B,gCAACC,EAAiBhD,EAAciD,EAA4C/E,GAC1G,IAAMyB,QAA0BtB,EAA0B0E,6BAA6BC,EAAShD,EAAMiD,EAAsB/E,GAC5H,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,yDAHiC,GAc5B2I,yCAAwC,gCAACC,EAAoBC,EAAiBJ,EAAiBhD,EAAc9B,GAC/G,IAAMyB,QAA0BtB,EAA0B6E,yCAAyCC,EAAYC,EAASJ,EAAShD,EAAM9B,GACvI,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,2DAH6C,GAYxC8I,8BAA6B,gCAACL,EAAiBhD,EAAc9B,GAC/D,IAAMyB,QAA0BtB,EAA0BgF,8BAA8BL,EAAShD,EAAM9B,GACvG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHkC,GAa7B+I,8BAA6B,gCAACF,EAAiBJ,EAAiBhD,EAAc9B,GAChF,IAAMyB,QAA0BtB,EAA0BiF,8BAA8BF,EAASJ,EAAShD,EAAM9B,GAChH,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,yDAHkC,GAa7BgJ,6BAA4B,gCAACH,EAAiBJ,EAAiBhD,EAAc9B,GAC/E,IAAMyB,QAA0BtB,EAA0BkF,6BAA6BH,EAASJ,EAAShD,EAAM9B,GAC/G,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,yDAHiC,GAc5BiJ,uCAAsC,gCAACL,EAAoBC,EAAiBJ,EAAiBhD,EAAc9B,GAC7G,IAAMyB,QAA0BtB,EAA0BmF,uCAAuCL,EAAYC,EAASJ,EAAShD,EAAM9B,GACrI,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,2DAH2C,GActCkJ,6BAA4B,gCAACL,EAAiBJ,EAAiBhD,EAAc0D,EAA4CxF,GAC3H,IAAMyB,QAA0BtB,EAA0BoF,6BAA6BL,EAASJ,EAAShD,EAAM0D,EAAsBxF,GACrI,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,2DAHiC,GAgB5BoJ,uCAAsC,gCAACP,EAAiBJ,EAAiBhD,EAAcjF,EAAc6G,EAAYgC,EAAwB1F,GAC3I,IAAMyB,QAA0BtB,EAA0BsF,uCAAuCP,EAASJ,EAAShD,EAAMjF,EAAM6G,EAAMgC,EAAe1F,GACpJ,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,+DAH2C,MA2bvCuJ,IA/ToB,yIAW7B,SAAoCd,EAAiBhD,EAAciD,EAA4C/E,GAA+B,IAAD,OACzI,OAAO4E,GAAuBnI,KAAKJ,eAAewI,6BAA6BC,EAAShD,EAAMiD,EAAsB/E,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC3K,sDAaD,SAAgD2I,EAAoBC,EAAiBJ,EAAiBhD,EAAc9B,GAA+B,IAAD,OAC9I,OAAO4E,GAAuBnI,KAAKJ,eAAe2I,yCAAyCC,EAAYC,EAASJ,EAAShD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACtL,2CAWD,SAAqCwI,EAAiBhD,EAAc9B,GAA+B,IAAD,OAC9F,OAAO4E,GAAuBnI,KAAKJ,eAAe8I,8BAA8BL,EAAShD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACtJ,2CAYD,SAAqC4I,EAAiBJ,EAAiBhD,EAAc9B,GAA+B,IAAD,OAC/G,OAAO4E,GAAuBnI,KAAKJ,eAAe+I,8BAA8BF,EAASJ,EAAShD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC/J,0CAYD,SAAoC4I,EAAiBJ,EAAiBhD,EAAc9B,GAA+B,IAAD,OAC9G,OAAO4E,GAAuBnI,KAAKJ,eAAegJ,6BAA6BH,EAASJ,EAAShD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC9J,oDAaD,SAA8C2I,EAAoBC,EAAiBJ,EAAiBhD,EAAc9B,GAA+B,IAAD,OAC5I,OAAO4E,GAAuBnI,KAAKJ,eAAeiJ,uCAAuCL,EAAYC,EAASJ,EAAShD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACpL,0CAaD,SAAoC4I,EAAiBJ,EAAiBhD,EAAc0D,EAA4CxF,GAA+B,IAAD,OAC1J,OAAO4E,GAAuBnI,KAAKJ,eAAekJ,6BAA6BL,EAASJ,EAAShD,EAAM0D,EAAsBxF,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACpL,oDAeD,SAA8C4I,EAAiBJ,EAAiBhD,EAAcjF,EAAc6G,EAAYgC,EAAwB1F,GAA+B,IAAD,OAC1K,OAAO4E,GAAuBnI,KAAKJ,eAAeoJ,uCAAuCP,EAASJ,EAAShD,EAAMjF,EAAM6G,EAAMgC,EAAe1F,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBAnHvK,CAASF,GA+TP,SAASC,GACxC,IAAM8D,EApMwC,SAAU9D,GACxD,MAAO,CAQHwJ,oBAAoB,WAAD,WAAE,UAAOC,GAAwF,IAA5D9F,EAA2B,uDAAG,GAElFhD,EAAkB,sBAAuB,eAAgB8I,GACzD,IAGIvF,EAHEC,EAAY,OAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsB4G,EAAcjF,EAAwBxE,GAEnF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAhCmB,GAuCpBkF,qBAAqB,WAAD,WAAE,YAAmE,IAIjFxF,EAJqBP,EAA2B,uDAAG,GACjDQ,EAAY,OAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDAvBoB,GA+BrBmF,qBAAqB,WAAD,WAAE,UAAOC,GAAyE,IAA5DjG,EAA2B,uDAAG,GAEpEhD,EAAkB,uBAAwB,MAAOiJ,GACjD,IAII1F,EAJEC,EAAe,aAChBrE,QAAQ,QAAcsE,mBAAmBC,OAAOuF,KAE/CtF,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA1BoB,GAkCrBqF,oBAAoB,WAAD,WAAE,UAAOD,GAAyE,IAA5DjG,EAA2B,uDAAG,GAEnEhD,EAAkB,sBAAuB,MAAOiJ,GAChD,IAII1F,EAJEC,EAAe,aAChBrE,QAAQ,QAAcsE,mBAAmBC,OAAOuF,KAE/CtF,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9BmB,GAuCpBsF,oBAAoB,WAAD,WAAE,UAAOF,EAAaG,GAAwF,IAA5DpG,EAA2B,uDAAG,GAE/FhD,EAAkB,sBAAuB,MAAOiJ,GAEhDjJ,EAAkB,sBAAuB,eAAgBoJ,GACzD,IAII7F,EAJEC,EAAe,aAChBrE,QAAQ,QAAcsE,mBAAmBC,OAAOuF,KAE/CtF,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,SAAYP,GAAgBP,GAC/De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBkH,EAAcvF,EAAwBxE,GAEnF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnCmB,IA4CUwF,CAAmChK,GACrE,MAAO,CAQGwJ,oBAAmB,gCAACC,EAA4B9F,GAClD,IAAMyB,QAA0BtB,EAA0B0F,oBAAoBC,EAAc9F,GAC5F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHwB,GAUnB0J,qBAAoB,gCAAC/F,GACvB,IAAMyB,QAA0BtB,EAA0B4F,qBAAqB/F,GAC/E,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAHyB,GAWpB2J,qBAAoB,gCAACC,EAAajG,GACpC,IAAMyB,QAA0BtB,EAA0B6F,qBAAqBC,EAAKjG,GACpF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHyB,GAWpB6J,oBAAmB,gCAACD,EAAajG,GACnC,IAAMyB,QAA0BtB,EAA0B+F,oBAAoBD,EAAKjG,GACnF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHwB,GAYnB8J,oBAAmB,gCAACF,EAAaG,EAA4BpG,GAC/D,IAAMyB,QAA0BtB,EAA0BgG,oBAAoBF,EAAKG,EAAcpG,GACjG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHwB,MA+NpBiK,IAtJiB,gIAS1B,SAA2BR,EAA4B9F,GAA+B,IAAD,OACjF,OAAO4F,GAAoBnJ,KAAKJ,eAAewJ,oBAAoBC,EAAc9F,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACxI,kCASD,SAA4B0D,GAA+B,IAAD,OACtD,OAAO4F,GAAoBnJ,KAAKJ,eAAe0J,qBAAqB/F,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC3H,kCAUD,SAA4B2J,EAAajG,GAA+B,IAAD,OACnE,OAAO4F,GAAoBnJ,KAAKJ,eAAe2J,qBAAqBC,EAAKjG,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAChI,iCAUD,SAA2B2J,EAAajG,GAA+B,IAAD,OAClE,OAAO4F,GAAoBnJ,KAAKJ,eAAe6J,oBAAoBD,EAAKjG,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC/H,iCAWD,SAA2B2J,EAAaG,EAA4BpG,GAA+B,IAAD,OAC9F,OAAO4F,GAAoBnJ,KAAKJ,eAAe8J,oBAAoBF,EAAKG,EAAcpG,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBA1DpH,CAASF,GAsJT,SAASC,GACnC,IAAM8D,EApFmC,SAAU9D,GACnD,MAAO,CAQHwJ,oBAAoB,WAAD,WAAE,UAAOC,GAAwF,IAA5D9F,EAA2B,uDAAG,GAElFhD,EAAkB,sBAAuB,eAAgB8I,GACzD,IAGIvF,EAHEC,EAAY,OAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsB4G,EAAcjF,EAAwBxE,GAEnF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAhCmB,GAwCpBmF,qBAAqB,WAAD,WAAE,UAAOC,GAAyE,IAA5DjG,EAA2B,uDAAG,GAEpEhD,EAAkB,uBAAwB,MAAOiJ,GACjD,IAII1F,EAJEC,EAAe,aAChBrE,QAAQ,QAAcsE,mBAAmBC,OAAOuF,KAE/CtF,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA1BoB,IAmCS0F,CAA8BlK,GAChE,MAAO,CAQGwJ,oBAAmB,gCAACC,EAA4B9F,GAClD,IAAMyB,QAA0BtB,EAA0B0F,oBAAoBC,EAAc9F,GAC5F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHwB,GAWnB2J,qBAAoB,gCAACC,EAAajG,GACpC,IAAMyB,QAA0BtB,EAA0B6F,qBAAqBC,EAAKjG,GACpF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHyB,MAucrBmK,IA5ZY,gIASrB,SAA2BV,EAA4B9F,GAA+B,IAAD,OACjF,OAAOsG,GAAe7J,KAAKJ,eAAewJ,oBAAoBC,EAAc9F,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACnI,kCAUD,SAA4B2J,EAAajG,GAA+B,IAAD,OACnE,OAAOsG,GAAe7J,KAAKJ,eAAe2J,qBAAqBC,EAAKjG,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBAtBvG,CAASF,GA4ZH,SAASC,GACpC,IAAM8D,EA9XoC,SAAU9D,GACpD,MAAO,CAQHoK,2CAA2C,WAAD,WAAE,UAAO3E,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE3FhD,EAAkB,6CAA8C,OAAQ8E,GACxE,IAIIvB,EAJEC,EAAe,mBAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA1B0C,GAoC3C6F,iDAAiD,WAAD,WAAE,UAAO5B,EAAiBhD,EAAc6E,GAA+E,IAA5D3G,EAA2B,uDAAG,GAErIhD,EAAkB,mDAAoD,UAAW8H,GAEjF9H,EAAkB,mDAAoD,OAAQ8E,GAC9E,IAKIvB,EALEC,EAAe,6BAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,QAEf5D,IAAZuJ,IACA3F,EAAgC,QAAI2F,GAKxChI,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,uDAjCgD,GAyCjD+F,wDAAwD,WAAD,WAAE,UAAOD,GAA+E,IAIvIpG,EAJ2EP,EAA2B,uDAAG,GACvGQ,EAAY,oBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,QAEf5D,IAAZuJ,IACA3F,EAAgC,QAAI2F,GAKxChI,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA3BuD,GAoCxDgG,gEAAgE,WAAD,WAAE,UAAO/E,EAAc6E,GAA+E,IAA5D3G,EAA2B,uDAAG,GAEnIhD,EAAkB,kEAAmE,OAAQ8E,GAC7F,IAIIvB,EAJEC,EAAe,2BAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,QAEf5D,IAAZuJ,IACA3F,EAAgC,QAAI2F,GAKxChI,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDA9B+D,GAyChEiG,gDAAgD,WAAD,WAAE,UAAO5B,EAAiBJ,EAAiBhD,EAAc6E,GAA+E,IAA5D3G,EAA2B,uDAAG,GAErJhD,EAAkB,kDAAmD,UAAWkI,GAEhFlI,EAAkB,kDAAmD,UAAW8H,GAEhF9H,EAAkB,kDAAmD,OAAQ8E,GAC7E,IAMIvB,EANEC,EAAe,uCAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KACpD/I,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,QAEf5D,IAAZuJ,IACA3F,EAAgC,QAAI2F,GAKxChI,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,yDApC+C,GA4ChDkG,uDAAuD,WAAD,WAAE,UAAO7B,GAA6E,IAA5DlF,EAA2B,uDAAG,GAE1GhD,EAAkB,yDAA0D,UAAWkI,GACvF,IAII3E,EAJEC,EAAe,8BAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KAEnDvE,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA1BsD,GAmCvDmG,+DAA+D,WAAD,WAAE,UAAO9B,EAAiBpD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAEhIhD,EAAkB,iEAAkE,UAAWkI,GAE/FlI,EAAkB,iEAAkE,OAAQ8E,GAC5F,IAKIvB,EALEC,EAAe,qCAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KACpD/I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDA7B8D,GAyC/DoG,4BAA4B,WAAD,WAAE,UAAOnF,EAAcoF,EAAsBC,EAAiBC,EAAmBC,GAAgF,IAA5DrH,EAA2B,uDAAG,GAE1JhD,EAAkB,8BAA+B,OAAQ8E,GACzD,IAIIvB,EAJEC,EAAe,0CAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,QAEjCe,IAAhB8J,IACAlG,EAAoC,YAAIkG,QAG7B9J,IAAX+J,IACAnG,EAA+B,OAAImG,QAGtB/J,IAAbgK,IACApG,EAAiC,SAAIoG,QAGvBhK,IAAdiK,IACArG,EAAkC,UAAIqG,GAK1C1I,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,2DA9C2B,GAuD5ByG,0BAA0B,WAAD,WAAE,UAAOF,EAAkBC,GAA+E,IAA5DrH,EAA2B,uDAAG,GAEjGhD,EAAkB,4BAA6B,WAAYoK,GAE3DpK,EAAkB,4BAA6B,YAAaqK,GAC5D,IAGI9G,EAHEC,EAAY,qBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,QAEd5D,IAAbgK,IACApG,EAAiC,SAAIoG,QAGvBhK,IAAdiK,IACArG,EAAkC,UAAIqG,GAK1C1I,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnCyB,IA4CI0G,CAA+BlL,GACjE,MAAO,CAQGoK,2CAA0C,gCAAC3E,EAAc9B,GAC3D,IAAMyB,QAA0BtB,EAA0BsG,2CAA2C3E,EAAM9B,GAC3G,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH+C,GAa1CqK,iDAAgD,gCAAC5B,EAAiBhD,EAAc6E,EAAmB3G,GACrG,IAAMyB,QAA0BtB,EAA0BuG,iDAAiD5B,EAAShD,EAAM6E,EAAS3G,GACnI,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,yDAHqD,GAWhDuK,wDAAuD,gCAACD,EAAmB3G,GAC7E,IAAMyB,QAA0BtB,EAA0ByG,wDAAwDD,EAAS3G,GAC3H,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH4D,GAYvDwK,gEAA+D,gCAAC/E,EAAc6E,EAAmB3G,GACnG,IAAMyB,QAA0BtB,EAA0B0G,gEAAgE/E,EAAM6E,EAAS3G,GACzI,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHoE,GAc/DyK,gDAA+C,gCAAC5B,EAAiBJ,EAAiBhD,EAAc6E,EAAmB3G,GACrH,IAAMyB,QAA0BtB,EAA0B2G,gDAAgD5B,EAASJ,EAAShD,EAAM6E,EAAS3G,GAC3I,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,2DAHoD,GAW/C0K,uDAAsD,gCAAC7B,EAAiBlF,GAC1E,IAAMyB,QAA0BtB,EAA0B4G,uDAAuD7B,EAASlF,GAC1H,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH2D,GAYtD2K,+DAA8D,gCAAC9B,EAAiBpD,EAAc9B,GAChG,IAAMyB,QAA0BtB,EAA0B6G,+DAA+D9B,EAASpD,EAAM9B,GACxI,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHmE,GAe9D4K,4BAA2B,gCAACnF,EAAcoF,EAAsBC,EAAiBC,EAAmBC,EAAoBrH,GAC1H,IAAMyB,QAA0BtB,EAA0B8G,4BAA4BnF,EAAMoF,EAAaC,EAAQC,EAAUC,EAAWrH,GACtI,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,6DAHgC,GAY3BiL,0BAAyB,gCAACF,EAAkBC,EAAmBrH,GACjE,IAAMyB,QAA0BtB,EAA0BmH,0BAA0BF,EAAUC,EAAWrH,GACzG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAH8B,MA2pB1BmL,IA9hBa,uJAStB,SAAkD1F,EAAc9B,GAA+B,IAAD,OAC1F,OAAOwG,GAAgB/J,KAAKJ,eAAeoK,2CAA2C3E,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACnJ,8DAYD,SAAwDwI,EAAiBhD,EAAc6E,EAAmB3G,GAA+B,IAAD,OACpI,OAAOwG,GAAgB/J,KAAKJ,eAAeqK,iDAAiD5B,EAAShD,EAAM6E,EAAS3G,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC3K,qEAUD,SAA+DqK,EAAmB3G,GAA+B,IAAD,OAC5G,OAAOwG,GAAgB/J,KAAKJ,eAAeuK,wDAAwDD,EAAS3G,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACnK,6EAWD,SAAuEwF,EAAc6E,EAAmB3G,GAA+B,IAAD,OAClI,OAAOwG,GAAgB/J,KAAKJ,eAAewK,gEAAgE/E,EAAM6E,EAAS3G,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACjL,6DAaD,SAAuD4I,EAAiBJ,EAAiBhD,EAAc6E,EAAmB3G,GAA+B,IAAD,OACpJ,OAAOwG,GAAgB/J,KAAKJ,eAAeyK,gDAAgD5B,EAASJ,EAAShD,EAAM6E,EAAS3G,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACnL,oEAUD,SAA8D4I,EAAiBlF,GAA+B,IAAD,OACzG,OAAOwG,GAAgB/J,KAAKJ,eAAe0K,uDAAuD7B,EAASlF,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAClK,4EAWD,SAAsE4I,EAAiBpD,EAAc9B,GAA+B,IAAD,OAC/H,OAAOwG,GAAgB/J,KAAKJ,eAAe2K,+DAA+D9B,EAASpD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAChL,yCAcD,SAAmCwF,EAAcoF,EAAsBC,EAAiBC,EAAmBC,EAAoBrH,GAA+B,IAAD,OACzJ,OAAOwG,GAAgB/J,KAAKJ,eAAe4K,4BAA4BnF,EAAMoF,EAAaC,EAAQC,EAAUC,EAAWrH,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC9K,uCAWD,SAAiC8K,EAAkBC,EAAmBrH,GAA+B,IAAD,OAChG,OAAOwG,GAAgB/J,KAAKJ,eAAeiL,0BAA0BF,EAAUC,EAAWrH,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBAtH5H,CAASF,GA8hBG,SAASC,GAC3C,IAAM8D,EAha2C,SAAU9D,GAC3D,MAAO,CAUHoL,qCAAqC,WAAD,WAAE,UAAOlD,EAAmBO,EAAiBhD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAEzHhD,EAAkB,uCAAwC,YAAauH,GAEvEvH,EAAkB,uCAAwC,UAAW8H,GAErE9H,EAAkB,uCAAwC,OAAQ8E,GAClE,IAMIvB,EANEC,EAAe,yEAChBrE,QAAQ,cAAoBsE,mBAAmBC,OAAO6D,KACtDpI,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,uDApCoC,GA6CrC6G,4BAA4B,WAAD,WAAE,UAAO5F,EAAc6F,GAAwG,IAA5D3H,EAA2B,uDAAG,GAExHhD,EAAkB,8BAA+B,OAAQ8E,GAEzD9E,EAAkB,8BAA+B,uBAAwB2K,GACzE,IAIIpH,EAJEC,EAAe,mCAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsByI,EAAsB9G,EAAwBxE,GAE3F,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnC2B,GA6C5B+G,sCAAsC,WAAD,WAAE,UAAOrD,EAAmBO,EAAiBhD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE1HhD,EAAkB,wCAAyC,YAAauH,GAExEvH,EAAkB,wCAAyC,UAAW8H,GAEtE9H,EAAkB,wCAAyC,OAAQ8E,GACnE,IAMIvB,EANEC,EAAe,yEAChBrE,QAAQ,cAAoBsE,mBAAmBC,OAAO6D,KACtDpI,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,uDApCqC,GA4CtCgH,6BAA6B,WAAD,WAAE,UAAO/F,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE7EhD,EAAkB,+BAAgC,OAAQ8E,GAC1D,IAIIvB,EAJEC,EAAe,mCAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9B4B,GAuC7BiH,4CAA4C,WAAD,WAAE,UAAOhD,EAAiBhD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE7GhD,EAAkB,8CAA+C,UAAW8H,GAE5E9H,EAAkB,8CAA+C,OAAQ8E,GACzE,IAKIvB,EALEC,EAAe,6DAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAjC2C,GA0C5CkH,6BAA6B,WAAD,WAAE,UAAOjD,EAAiBhD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE9FhD,EAAkB,+BAAgC,UAAW8H,GAE7D9H,EAAkB,+BAAgC,OAAQ8E,GAC1D,IAKIvB,EALEC,EAAe,6CAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAjC4B,GA6C7BoG,4BAA4B,WAAD,WAAE,UAAOnF,EAAcoF,EAAsBC,EAAiBC,EAAmBC,GAAgF,IAA5DrH,EAA2B,uDAAG,GAE1JhD,EAAkB,8BAA+B,OAAQ8E,GACzD,IAIIvB,EAJEC,EAAe,0CAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,QAEjCe,IAAhB8J,IACAlG,EAAoC,YAAIkG,QAG7B9J,IAAX+J,IACAnG,EAA+B,OAAImG,QAGtB/J,IAAbgK,IACApG,EAAiC,SAAIoG,QAGvBhK,IAAdiK,IACArG,EAAkC,UAAIqG,GAK1C1I,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,2DA9C2B,GAuD5BmH,4BAA4B,WAAD,WAAE,UAAOlD,EAAiBhD,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE7FhD,EAAkB,8BAA+B,UAAW8H,GAE5D9H,EAAkB,8BAA+B,OAAQ8E,GACzD,IAKIvB,EALEC,EAAe,6CAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAjC2B,GA2C5BoH,4BAA4B,WAAD,WAAE,UAAOnD,EAAiBhD,EAAcoG,GAAwG,IAA5DlI,EAA2B,uDAAG,GAEzIhD,EAAkB,8BAA+B,UAAW8H,GAE5D9H,EAAkB,8BAA+B,OAAQ8E,GAEzD9E,EAAkB,8BAA+B,uBAAwBkL,GACzE,IAKI3H,EALEC,EAAe,6CAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOoE,KACpD3I,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,SAAYP,GAAgBP,GAC/De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBgJ,EAAsBrH,EAAwBxE,GAE3F,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,uDAtC2B,IA+CEsH,CAAsC9L,GACxE,MAAO,CAUGoL,qCAAoC,gCAAClD,EAAmBO,EAAiBhD,EAAc9B,GACzF,IAAMyB,QAA0BtB,EAA0BsH,qCAAqClD,EAAWO,EAAShD,EAAM9B,GACzH,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,yDAHyC,GAYpCqL,4BAA2B,gCAAC5F,EAAc6F,EAA4C3H,GACxF,IAAMyB,QAA0BtB,EAA0BuH,4BAA4B5F,EAAM6F,EAAsB3H,GAClH,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHgC,GAa3BuL,sCAAqC,gCAACrD,EAAmBO,EAAiBhD,EAAc9B,GAC1F,IAAMyB,QAA0BtB,EAA0ByH,sCAAsCrD,EAAWO,EAAShD,EAAM9B,GAC1H,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,yDAH0C,GAWrCwL,6BAA4B,gCAAC/F,EAAc9B,GAC7C,IAAMyB,QAA0BtB,EAA0B0H,6BAA6B/F,EAAM9B,GAC7F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHiC,GAY5ByL,4CAA2C,gCAAChD,EAAiBhD,EAAc9B,GAC7E,IAAMyB,QAA0BtB,EAA0B2H,4CAA4ChD,EAAShD,EAAM9B,GACrH,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHgD,GAY3C0L,6BAA4B,gCAACjD,EAAiBhD,EAAc9B,GAC9D,IAAMyB,QAA0BtB,EAA0B4H,6BAA6BjD,EAAShD,EAAM9B,GACtG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHiC,GAe5B4K,4BAA2B,gCAACnF,EAAcoF,EAAsBC,EAAiBC,EAAmBC,EAAoBrH,GAC1H,IAAMyB,QAA0BtB,EAA0B8G,4BAA4BnF,EAAMoF,EAAaC,EAAQC,EAAUC,EAAWrH,GACtI,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,6DAHgC,GAY3B2L,4BAA2B,gCAAClD,EAAiBhD,EAAc9B,GAC7D,IAAMyB,QAA0BtB,EAA0B6H,4BAA4BlD,EAAShD,EAAM9B,GACrG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHgC,GAa3B4L,4BAA2B,gCAACnD,EAAiBhD,EAAcoG,EAA4ClI,GACzG,IAAMyB,QAA0BtB,EAA0B8H,4BAA4BnD,EAAShD,EAAMoG,EAAsBlI,GAC3H,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,yDAHgC,MAsS5B+L,IAvKoB,iJAW7B,SAA4C7D,EAAmBO,EAAiBhD,EAAc9B,GAA+B,IAAD,OACxH,OAAOwH,GAAuB/K,KAAKJ,eAAeoL,qCAAqClD,EAAWO,EAAShD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACxK,yCAWD,SAAmCwF,EAAc6F,EAA4C3H,GAA+B,IAAD,OACvH,OAAOwH,GAAuB/K,KAAKJ,eAAeqL,4BAA4B5F,EAAM6F,EAAsB3H,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACjK,mDAYD,SAA6CiI,EAAmBO,EAAiBhD,EAAc9B,GAA+B,IAAD,OACzH,OAAOwH,GAAuB/K,KAAKJ,eAAeuL,sCAAsCrD,EAAWO,EAAShD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACzK,0CAUD,SAAoCwF,EAAc9B,GAA+B,IAAD,OAC5E,OAAOwH,GAAuB/K,KAAKJ,eAAewL,6BAA6B/F,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC5I,yDAWD,SAAmDwI,EAAiBhD,EAAc9B,GAA+B,IAAD,OAC5G,OAAOwH,GAAuB/K,KAAKJ,eAAeyL,4CAA4ChD,EAAShD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACpK,0CAWD,SAAoCwI,EAAiBhD,EAAc9B,GAA+B,IAAD,OAC7F,OAAOwH,GAAuB/K,KAAKJ,eAAe0L,6BAA6BjD,EAAShD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACrJ,yCAcD,SAAmCwF,EAAcoF,EAAsBC,EAAiBC,EAAmBC,EAAoBrH,GAA+B,IAAD,OACzJ,OAAOwH,GAAuB/K,KAAKJ,eAAe4K,4BAA4BnF,EAAMoF,EAAaC,EAAQC,EAAUC,EAAWrH,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACrL,yCAWD,SAAmCwI,EAAiBhD,EAAc9B,GAA+B,IAAD,OAC5F,OAAOwH,GAAuB/K,KAAKJ,eAAe2L,4BAA4BlD,EAAShD,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACpJ,yCAYD,SAAmCwI,EAAiBhD,EAAcoG,EAA4ClI,GAA+B,IAAD,OACxI,OAAOwH,GAAuB/K,KAAKJ,eAAe4L,4BAA4BnD,EAAShD,EAAMoG,EAAsBlI,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBAxH9I,CAASF,GAuKhB,SAASC,GAC/B,IAAM8D,EAvC+B,SAAU9D,GAC/C,MAAO,CAMHgM,qBAAqB,WAAD,WAAE,YAAmE,IAIjF9H,EAJqBP,EAA2B,uDAAG,GACjDQ,EAAY,WAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDAvBoB,IAgCSyH,CAA0BjM,GAC5D,MAAO,CAMGgM,qBAAoB,gCAACrI,GACvB,IAAMyB,QAA0BtB,EAA0BkI,qBAAqBrI,GAC/E,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAHyB,MA8drBkM,IA/bQ,iIAOjB,SAA4BvI,GAA+B,IAAD,OACtD,OAAOoI,GAAW3L,KAAKJ,eAAegM,qBAAqBrI,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBARlG,CAASF,GA+be,SAASC,GAClD,IAAM8D,EA/akD,SAAU9D,GAClE,MAAO,CAQHmM,oCAAoC,WAAD,WAAE,UAAOzD,GAAwG,IAA5D/E,EAA2B,uDAAG,GAElHhD,EAAkB,sCAAuC,uBAAwB+H,GACjF,IAGIxE,EAHEC,EAAY,yBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsB6F,EAAsBlE,EAAwBxE,GAE3F,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAhCmC,GAyCpC4H,4CAA4C,WAAD,WAAE,UAAO3G,EAAciD,GAAwG,IAA5D/E,EAA2B,uDAAG,GAExIhD,EAAkB,8CAA+C,OAAQ8E,GAEzE9E,EAAkB,8CAA+C,uBAAwB+H,GACzF,IAIIxE,EAJEC,EAAe,2CAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsB6F,EAAsBlE,EAAwBxE,GAE3F,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnC2C,GA4C5C6H,gDAAgD,WAAD,WAAE,UAAOxD,EAAiBD,GAAgF,IAA5DjF,EAA2B,uDAAG,GAEvHhD,EAAkB,kDAAmD,UAAWkI,GAEhFlI,EAAkB,kDAAmD,aAAciI,GACnF,IAKI1E,EALEC,EAAe,4DAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KACpD/I,QAAQ,eAAqBsE,mBAAmBC,OAAOuE,KAEtDtE,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAjC+C,GAwChD8H,qCAAqC,WAAD,WAAE,YAAmE,IAIjGpI,EAJqCP,EAA2B,uDAAG,GACjEQ,EAAY,yBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDA3BoC,GAmCrC+H,2CAA2C,WAAD,WAAE,UAAO9G,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE3FhD,EAAkB,6CAA8C,OAAQ8E,GACxE,IAIIvB,EAJEC,EAAe,2CAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9B0C,GAsC3CgI,qCAAqC,WAAD,WAAE,UAAO3D,GAA6E,IAA5DlF,EAA2B,uDAAG,GAExFhD,EAAkB,uCAAwC,UAAWkI,GACrE,IAII3E,EAJEC,EAAe,mCAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KAEnDvE,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9BoC,GAsCrCiI,oCAAoC,WAAD,WAAE,UAAO5D,GAA6E,IAA5DlF,EAA2B,uDAAG,GAEvFhD,EAAkB,sCAAuC,UAAWkI,GACpE,IAII3E,EAJEC,EAAe,mCAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KAEnDvE,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9BmC,GAuCpCkI,8CAA8C,WAAD,WAAE,UAAO7D,EAAiBD,GAAgF,IAA5DjF,EAA2B,uDAAG,GAErHhD,EAAkB,gDAAiD,UAAWkI,GAE9ElI,EAAkB,gDAAiD,aAAciI,GACjF,IAKI1E,EALEC,EAAe,4DAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KACpD/I,QAAQ,eAAqBsE,mBAAmBC,OAAOuE,KAEtDtE,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAjC6C,GA0C9CmI,oCAAoC,WAAD,WAAE,UAAO9D,EAAiBM,GAAwG,IAA5DxF,EAA2B,uDAAG,GAEnIhD,EAAkB,sCAAuC,UAAWkI,GAEpElI,EAAkB,sCAAuC,uBAAwBwI,GACjF,IAIIjF,EAJEC,EAAe,mCAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KAEnDvE,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,SAAYP,GAAgBP,GAC/De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBsG,EAAsB3E,EAAwBxE,GAE3F,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnCmC,GA8CpCoI,8CAA8C,WAAD,WAAE,UAAO/D,EAAiBrI,EAAc6G,EAAYgC,GAAoF,IAA5D1F,EAA2B,uDAAG,GAEnJhD,EAAkB,gDAAiD,UAAWkI,GAE9ElI,EAAkB,gDAAiD,OAAQH,GAE3EG,EAAkB,gDAAiD,OAAQ0G,GAC3E,IAIInD,EAJEC,EAAe,+CAChBrE,QAAQ,YAAkBsE,mBAAmBC,OAAOwE,KAEnDvE,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,GACzB2C,EAAqB,IAAMtH,GAAiBA,EAAcuH,cAAiBC,gBAI3ExG,EAAsB0D,EAAyB1E,QAGxCe,IAATP,GACA8G,EAAmBlF,OAAO,OAAQ5B,QAGhBO,IAAlBsI,GACA/B,EAAmBlF,OAAO,gBAAiBiH,QAGlCtI,IAATsG,GACAC,EAAmBlF,OAAO,OAAQiF,GAItC3C,EAAwB,gBAAkB,sBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOyC,EAEvB,CACH/E,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,yDAlD6C,IA2DhBqI,CAA6C7M,GAC/E,MAAO,CAQGmM,oCAAmC,gCAACzD,EAA4C/E,GAClF,IAAMyB,QAA0BtB,EAA0BqI,oCAAoCzD,EAAsB/E,GACpH,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHwC,GAYnCoM,4CAA2C,gCAAC3G,EAAciD,EAA4C/E,GACxG,IAAMyB,QAA0BtB,EAA0BsI,4CAA4C3G,EAAMiD,EAAsB/E,GAClI,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHgD,GAY3CqM,gDAA+C,gCAACxD,EAAiBD,EAAoBjF,GACvF,IAAMyB,QAA0BtB,EAA0BuI,gDAAgDxD,EAASD,EAAYjF,GAC/H,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHoD,GAU/CsM,qCAAoC,gCAAC3I,GACvC,IAAMyB,QAA0BtB,EAA0BwI,qCAAqC3I,GAC/F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAHyC,GAWpCuM,2CAA0C,gCAAC9G,EAAc9B,GAC3D,IAAMyB,QAA0BtB,EAA0ByI,2CAA2C9G,EAAM9B,GAC3G,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH+C,GAW1CwM,qCAAoC,gCAAC3D,EAAiBlF,GACxD,IAAMyB,QAA0BtB,EAA0B0I,qCAAqC3D,EAASlF,GACxG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHyC,GAWpCyM,oCAAmC,gCAAC5D,EAAiBlF,GACvD,IAAMyB,QAA0BtB,EAA0B2I,oCAAoC5D,EAASlF,GACvG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHwC,GAYnC0M,8CAA6C,gCAAC7D,EAAiBD,EAAoBjF,GACrF,IAAMyB,QAA0BtB,EAA0B4I,8CAA8C7D,EAASD,EAAYjF,GAC7H,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHkD,GAY7C2M,oCAAmC,gCAAC9D,EAAiBM,EAA4CxF,GACnG,IAAMyB,QAA0BtB,EAA0B6I,oCAAoC9D,EAASM,EAAsBxF,GAC7H,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHwC,GAcnC4M,8CAA6C,gCAAC/D,EAAiBrI,EAAc6G,EAAYgC,EAAwB1F,GACnH,IAAMyB,QAA0BtB,EAA0B8I,8CAA8C/D,EAASrI,EAAM6G,EAAMgC,EAAe1F,GAC5I,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,2DAHkD,MAma9C8M,IAlS2B,gJASpC,SAA2CpE,EAA4C/E,GAA+B,IAAD,OACjH,OAAOuI,GAA8B9L,KAAKJ,eAAemM,oCAAoCzD,EAAsB/E,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC1K,yDAWD,SAAmDwF,EAAciD,EAA4C/E,GAA+B,IAAD,OACvI,OAAOuI,GAA8B9L,KAAKJ,eAAeoM,4CAA4C3G,EAAMiD,EAAsB/E,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACxL,6DAWD,SAAuD4I,EAAiBD,EAAoBjF,GAA+B,IAAD,OACtH,OAAOuI,GAA8B9L,KAAKJ,eAAeqM,gDAAgDxD,EAASD,EAAYjF,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACrL,kDASD,SAA4C0D,GAA+B,IAAD,OACtE,OAAOuI,GAA8B9L,KAAKJ,eAAesM,qCAAqC3I,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACrJ,wDAUD,SAAkDwF,EAAc9B,GAA+B,IAAD,OAC1F,OAAOuI,GAA8B9L,KAAKJ,eAAeuM,2CAA2C9G,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACjK,kDAUD,SAA4C4I,EAAiBlF,GAA+B,IAAD,OACvF,OAAOuI,GAA8B9L,KAAKJ,eAAewM,qCAAqC3D,EAASlF,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC9J,iDAUD,SAA2C4I,EAAiBlF,GAA+B,IAAD,OACtF,OAAOuI,GAA8B9L,KAAKJ,eAAeyM,oCAAoC5D,EAASlF,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC7J,2DAWD,SAAqD4I,EAAiBD,EAAoBjF,GAA+B,IAAD,OACpH,OAAOuI,GAA8B9L,KAAKJ,eAAe0M,8CAA8C7D,EAASD,EAAYjF,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACnL,iDAWD,SAA2C4I,EAAiBM,EAA4CxF,GAA+B,IAAD,OAClI,OAAOuI,GAA8B9L,KAAKJ,eAAe2M,oCAAoC9D,EAASM,EAAsBxF,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACnL,2DAaD,SAAqD4I,EAAiBrI,EAAc6G,EAAYgC,EAAwB1F,GAA+B,IAAD,OAClJ,OAAOuI,GAA8B9L,KAAKJ,eAAe4M,8CAA8C/D,EAASrI,EAAM6G,EAAMgC,EAAe1F,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBA5H/J,CAASF,GAkSV,SAASC,GAC5C,IAAM8D,EA9J4C,SAAU9D,GAC5D,MAAO,CAQH+M,yBAAyB,WAAD,WAAE,UAAO9I,GAAkG,IAA5DN,EAA2B,uDAAG,GAEjGhD,EAAkB,2BAA4B,oBAAqBsD,GACnE,IAGIC,EAHEC,EAAY,YAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBoB,EAAmBO,EAAwBxE,GAExF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAhCwB,GAuCzBwI,0BAA0B,WAAD,WAAE,YAAmE,IAItF9I,EAJ0BP,EAA2B,uDAAG,GACtDQ,EAAY,YAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDA3ByB,GAkC1ByI,yBAAyB,WAAD,WAAE,YAAmE,IAIrF/I,EAJyBP,EAA2B,uDAAG,GACrDQ,EAAY,YAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDA3BwB,GAmCzB0I,yBAAyB,WAAD,WAAE,UAAOhI,GAAkG,IAA5DvB,EAA2B,uDAAG,GAEjGhD,EAAkB,2BAA4B,oBAAqBuE,GACnE,IAGIhB,EAHEC,EAAY,YAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,SAAYP,GAAgBP,GAC/De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBqC,EAAmBV,EAAwBxE,GAExF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAhCwB,IAyCK2I,CAAuCnN,GACzE,MAAO,CAQG+M,yBAAwB,gCAAC9I,EAAsCN,GACjE,IAAMyB,QAA0BtB,EAA0BiJ,yBAAyB9I,EAAmBN,GACtG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH6B,GAUxBgN,0BAAyB,gCAACrJ,GAC5B,IAAMyB,QAA0BtB,EAA0BkJ,0BAA0BrJ,GACpF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAH8B,GAUzBiN,yBAAwB,gCAACtJ,GAC3B,IAAMyB,QAA0BtB,EAA0BmJ,yBAAyBtJ,GACnF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAH6B,GAWxBkN,yBAAwB,gCAAChI,EAAsCvB,GACjE,IAAMyB,QAA0BtB,EAA0BoJ,yBAAyBhI,EAAmBvB,GACtG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH6B,MA+sBzBoN,IAlpBqB,qIAS9B,SAAgCnJ,EAAsCN,GAA+B,IAAD,OAChG,OAAOmJ,GAAwB1M,KAAKJ,eAAe+M,yBAAyB9I,EAAmBN,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACtJ,uCASD,SAAiC0D,GAA+B,IAAD,OAC3D,OAAOmJ,GAAwB1M,KAAKJ,eAAegN,0BAA0BrJ,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACpI,sCASD,SAAgC0D,GAA+B,IAAD,OAC1D,OAAOmJ,GAAwB1M,KAAKJ,eAAeiN,yBAAyBtJ,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACnI,sCAUD,SAAgCiF,EAAsCvB,GAA+B,IAAD,OAChG,OAAOmJ,GAAwB1M,KAAKJ,eAAekN,yBAAyBhI,EAAmBvB,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBA5CzH,CAASF,GAkpBP,SAASC,GACzC,IAAM8D,EA9lByC,SAAU9D,GACzD,MAAO,CASHqN,0BAA0B,WAAD,WAAE,UAAO5H,EAAc6H,GAA0F,IAA5D3J,EAA2B,uDAAG,GAExGhD,EAAkB,4BAA6B,OAAQ8E,GAEvD9E,EAAkB,4BAA6B,gBAAiB2M,GAChE,IAIIpJ,EAJEC,EAAe,2BAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsByK,EAAe9I,EAAwBxE,GAEpF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnCyB,GA2C1B+I,0BAA0B,WAAD,WAAE,UAAOC,GAAkG,IAA5D7J,EAA2B,uDAAG,GAElGhD,EAAkB,4BAA6B,oBAAqB6M,GACpE,IAGItJ,EAHEC,EAAY,cAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsB2K,EAAmBhJ,EAAwBxE,GAExF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAhCyB,GAyC1BiJ,8BAA8B,WAAD,WAAE,UAAOC,EAAcjI,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE5FhD,EAAkB,gCAAiC,OAAQ+M,GAE3D/M,EAAkB,gCAAiC,OAAQ8E,GAC3D,IAKIvB,EALEC,EAAe,kCAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOqJ,KACjD5N,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDA7B6B,GAqC9BmJ,oCAAoC,WAAD,WAAE,UAAOlI,GAA0E,IAA5D9B,EAA2B,uDAAG,GAEpFhD,EAAkB,sCAAuC,OAAQ8E,GACjE,IAIIvB,EAJEC,EAAe,iCAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA1BmC,GAmCpCoJ,2BAA2B,WAAD,WAAE,UAAO5J,EAAcyB,GAA0E,IAA5D9B,EAA2B,uDAAG,GAEzFhD,EAAkB,6BAA8B,OAAQqD,GAExDrD,EAAkB,6BAA8B,OAAQ8E,GACxD,IAKIvB,EALEC,EAAe,kCAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOL,KACjDlE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAjC0B,GA0C3BqJ,gCAAgC,WAAD,WAAE,UAAOH,EAAcjI,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE9FhD,EAAkB,kCAAmC,OAAQ+M,GAE7D/M,EAAkB,kCAAmC,OAAQ8E,GAC7D,IAKIvB,EALEC,EAAe,kCAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOqJ,KACjD5N,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDA7B+B,GAqChCsJ,sCAAsC,WAAD,WAAE,UAAOrI,GAA0E,IAA5D9B,EAA2B,uDAAG,GAEtFhD,EAAkB,wCAAyC,OAAQ8E,GACnE,IAIIvB,EAJEC,EAAe,iCAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,GAI/BrC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA1BqC,GAiCtCuJ,2BAA2B,WAAD,WAAE,YAAmE,IAIvF7J,EAJ2BP,EAA2B,uDAAG,GACvDQ,EAAY,cAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDA3B0B,GAmC3BwJ,2BAA2B,WAAD,WAAE,UAAOvI,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE3EhD,EAAkB,6BAA8B,OAAQ8E,GACxD,IAIIvB,EAJEC,EAAe,qBAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9B0B,GAsC3ByJ,+BAA+B,WAAD,WAAE,UAAOxI,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE/EhD,EAAkB,iCAAkC,OAAQ8E,GAC5D,IAIIvB,EAJEC,EAAe,2BAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9B8B,GAuC/ByG,0BAA0B,WAAD,WAAE,UAAOF,EAAkBC,GAA+E,IAA5DrH,EAA2B,uDAAG,GAEjGhD,EAAkB,4BAA6B,WAAYoK,GAE3DpK,EAAkB,4BAA6B,YAAaqK,GAC5D,IAGI9G,EAHEC,EAAY,qBAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,QAEd5D,IAAbgK,IACApG,EAAiC,SAAIoG,QAGvBhK,IAAdiK,IACArG,EAAkC,UAAIqG,GAK1C1I,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnCyB,GA2C1B0J,0BAA0B,WAAD,WAAE,UAAOzI,GAA0E,IAA5D9B,EAA2B,uDAAG,GAE1EhD,EAAkB,4BAA6B,OAAQ8E,GACvD,IAIIvB,EAJEC,EAAe,qBAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9ByB,GAuC1B2J,0BAA0B,WAAD,WAAE,UAAO1I,EAAc2I,GAAkG,IAA5DzK,EAA2B,uDAAG,GAEhHhD,EAAkB,4BAA6B,OAAQ8E,GAEvD9E,EAAkB,4BAA6B,oBAAqByN,GACpE,IAIIlK,EAJEC,EAAe,qBAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,SAAYP,GAAgBP,GAC/De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBuL,EAAmB5J,EAAwBxE,GAExF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnCyB,GA6C1B6J,8BAA8B,WAAD,WAAE,UAAOX,EAAcjI,EAAc4B,GAAyE,IAA5D1D,EAA2B,uDAAG,GAEzGhD,EAAkB,gCAAiC,OAAQ+M,GAE3D/M,EAAkB,gCAAiC,OAAQ8E,GAC3D,IAKIvB,EALEC,EAAe,kCAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOqJ,KACjD5N,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,GACzB2C,EAAqB,IAAMtH,GAAiBA,EAAcuH,cAAiBC,eAGpEzG,IAATsG,GACAC,EAAmBlF,OAAO,OAAQiF,GAItC3C,EAAwB,gBAAkB,sBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOyC,EAEvB,CACH/E,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,uDArC6B,GA8C9B8J,oCAAoC,WAAD,WAAE,UAAO7I,EAAc4B,GAAyE,IAA5D1D,EAA2B,uDAAG,GAEjGhD,EAAkB,sCAAuC,OAAQ8E,GACjE,IAIIvB,EAJEC,EAAe,iCAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOoB,KAEhDnB,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,GACzB2C,EAAqB,IAAMtH,GAAiBA,EAAcuH,cAAiBC,eAGpEzG,IAATsG,GACAC,EAAmBlF,OAAO,OAAQiF,GAItC3C,EAAwB,gBAAkB,sBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOyC,EAEvB,CACH/E,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAlCmC,IA2CN+J,CAAoCvO,GACtE,MAAO,CASGqN,0BAAyB,gCAAC5H,EAAc6H,EAA8B3J,GACxE,IAAMyB,QAA0BtB,EAA0BuJ,0BAA0B5H,EAAM6H,EAAe3J,GACzG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAH8B,GAWzBuN,0BAAyB,gCAACC,EAAsC7J,GAClE,IAAMyB,QAA0BtB,EAA0ByJ,0BAA0BC,EAAmB7J,GACvG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH8B,GAYzByN,8BAA6B,gCAACC,EAAcjI,EAAc9B,GAC5D,IAAMyB,QAA0BtB,EAA0B2J,8BAA8BC,EAAMjI,EAAM9B,GACpG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHkC,GAW7B2N,oCAAmC,gCAAClI,EAAc9B,GACpD,IAAMyB,QAA0BtB,EAA0B6J,oCAAoClI,EAAM9B,GACpG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHwC,GAYnC4N,2BAA0B,gCAAC5J,EAAcyB,EAAc9B,GACzD,IAAMyB,QAA0BtB,EAA0B8J,2BAA2B5J,EAAMyB,EAAM9B,GACjG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAH+B,GAY1B6N,gCAA+B,gCAACH,EAAcjI,EAAc9B,GAC9D,IAAMyB,QAA0BtB,EAA0B+J,gCAAgCH,EAAMjI,EAAM9B,GACtG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHoC,GAW/B8N,sCAAqC,gCAACrI,EAAc9B,GACtD,IAAMyB,QAA0BtB,EAA0BgK,sCAAsCrI,EAAM9B,GACtG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH0C,GAUrC+N,2BAA0B,gCAACpK,GAC7B,IAAMyB,QAA0BtB,EAA0BiK,2BAA2BpK,GACrF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAH+B,GAW1BgO,2BAA0B,gCAACvI,EAAc9B,GAC3C,IAAMyB,QAA0BtB,EAA0BkK,2BAA2BvI,EAAM9B,GAC3F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH+B,GAW1BiO,+BAA8B,gCAACxI,EAAc9B,GAC/C,IAAMyB,QAA0BtB,EAA0BmK,+BAA+BxI,EAAM9B,GAC/F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAHmC,GAY9BiL,0BAAyB,gCAACF,EAAkBC,EAAmBrH,GACjE,IAAMyB,QAA0BtB,EAA0BmH,0BAA0BF,EAAUC,EAAWrH,GACzG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAH8B,GAWzBkO,0BAAyB,gCAACzI,EAAc9B,GAC1C,IAAMyB,QAA0BtB,EAA0BoK,0BAA0BzI,EAAM9B,GAC1F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH8B,GAYzBmO,0BAAyB,gCAAC1I,EAAc2I,EAAsCzK,GAChF,IAAMyB,QAA0BtB,EAA0BqK,0BAA0B1I,EAAM2I,EAAmBzK,GAC7G,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAH8B,GAazBqO,8BAA6B,gCAACX,EAAcjI,EAAc4B,EAAa1D,GACzE,IAAMyB,QAA0BtB,EAA0BuK,8BAA8BX,EAAMjI,EAAM4B,EAAM1D,GAC1G,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,yDAHkC,GAY7BsO,oCAAmC,gCAAC7I,EAAc4B,EAAa1D,GACjE,IAAMyB,QAA0BtB,EAA0BwK,oCAAoC7I,EAAM4B,EAAM1D,GAC1G,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAHwC,MAymBpCwO,IApbkB,sIAU3B,SAAiC/I,EAAc6H,EAA8B3J,GAA+B,IAAD,OACvG,OAAOyJ,GAAqBhN,KAAKJ,eAAeqN,0BAA0B5H,EAAM6H,EAAe3J,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACtJ,uCAUD,SAAiCuN,EAAsC7J,GAA+B,IAAD,OACjG,OAAOyJ,GAAqBhN,KAAKJ,eAAeuN,0BAA0BC,EAAmB7J,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACpJ,2CAWD,SAAqCyN,EAAcjI,EAAc9B,GAA+B,IAAD,OAC3F,OAAOyJ,GAAqBhN,KAAKJ,eAAeyN,8BAA8BC,EAAMjI,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACjJ,iDAUD,SAA2CwF,EAAc9B,GAA+B,IAAD,OACnF,OAAOyJ,GAAqBhN,KAAKJ,eAAe2N,oCAAoClI,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACjJ,wCAWD,SAAkC+D,EAAcyB,EAAc9B,GAA+B,IAAD,OACxF,OAAOyJ,GAAqBhN,KAAKJ,eAAe4N,2BAA2B5J,EAAMyB,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC9I,6CAWD,SAAuCyN,EAAcjI,EAAc9B,GAA+B,IAAD,OAC7F,OAAOyJ,GAAqBhN,KAAKJ,eAAe6N,gCAAgCH,EAAMjI,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACnJ,mDAUD,SAA6CwF,EAAc9B,GAA+B,IAAD,OACrF,OAAOyJ,GAAqBhN,KAAKJ,eAAe8N,sCAAsCrI,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACnJ,wCASD,SAAkC0D,GAA+B,IAAD,OAC5D,OAAOyJ,GAAqBhN,KAAKJ,eAAe+N,2BAA2BpK,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAClI,wCAUD,SAAkCwF,EAAc9B,GAA+B,IAAD,OAC1E,OAAOyJ,GAAqBhN,KAAKJ,eAAegO,2BAA2BvI,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACxI,4CAUD,SAAsCwF,EAAc9B,GAA+B,IAAD,OAC9E,OAAOyJ,GAAqBhN,KAAKJ,eAAeiO,+BAA+BxI,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC5I,uCAWD,SAAiC8K,EAAkBC,EAAmBrH,GAA+B,IAAD,OAChG,OAAOyJ,GAAqBhN,KAAKJ,eAAeiL,0BAA0BF,EAAUC,EAAWrH,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACtJ,uCAUD,SAAiCwF,EAAc9B,GAA+B,IAAD,OACzE,OAAOyJ,GAAqBhN,KAAKJ,eAAekO,0BAA0BzI,EAAM9B,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACvI,uCAWD,SAAiCwF,EAAc2I,EAAsCzK,GAA+B,IAAD,OAC/G,OAAOyJ,GAAqBhN,KAAKJ,eAAemO,0BAA0B1I,EAAM2I,EAAmBzK,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC1J,2CAYD,SAAqCyN,EAAcjI,EAAc4B,EAAa1D,GAA+B,IAAD,OACxG,OAAOyJ,GAAqBhN,KAAKJ,eAAeqO,8BAA8BX,EAAMjI,EAAM4B,EAAM1D,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACvJ,iDAWD,SAA2CwF,EAAc4B,EAAa1D,GAA+B,IAAD,OAChG,OAAOyJ,GAAqBhN,KAAKJ,eAAesO,oCAAoC7I,EAAM4B,EAAM1D,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBA1L7H,CAASF,GAobL,SAASC,GACxC,IAAM8D,EAlPwC,SAAU9D,GACxD,MAAO,CAQHyO,sBAAsB,WAAD,WAAE,UAAOtH,GAA0F,IAA5DxD,EAA2B,uDAAG,GAEtFhD,EAAkB,wBAAyB,gBAAiBwG,GAC5D,IAGIjD,EAHEC,EAAY,SAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,QAAWP,GAAgBP,GAC9De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBsE,EAAe3C,EAAwBxE,GAEpF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDAhCqB,GAuCtBkK,uBAAuB,WAAD,WAAE,YAAmE,IAInFxK,EAJuBP,EAA2B,uDAAG,GACnDQ,EAAY,SAEZG,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,kDA3BsB,GAmCvBmK,uBAAuB,WAAD,WAAE,UAAO3K,GAA0E,IAA5DL,EAA2B,uDAAG,GAEvEhD,EAAkB,yBAA0B,OAAQqD,GACpD,IAIIE,EAJEC,EAAe,gBAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOL,KAEhDM,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9BsB,GAsCvBoK,2BAA2B,WAAD,WAAE,UAAO5K,GAA0E,IAA5DL,EAA2B,uDAAG,GAE3EhD,EAAkB,6BAA8B,OAAQqD,GACxD,IAIIE,EAJEC,EAAe,sBAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOL,KAEhDM,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,OAAUP,GAAgBP,GAC7De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9B0B,GAsC3BqK,sBAAsB,WAAD,WAAE,UAAO7K,GAA0E,IAA5DL,EAA2B,uDAAG,GAEtEhD,EAAkB,wBAAyB,OAAQqD,GACnD,IAIIE,EAJEC,EAAe,gBAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOL,KAEhDM,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,UAAaP,GAAgBP,GAChEe,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrDsC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAGxF,OAFAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SAE7F,CACHX,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,mDA9BqB,GAuCtBsK,sBAAsB,WAAD,WAAE,UAAO9K,EAAc+K,GAA0F,IAA5DpL,EAA2B,uDAAG,GAEpGhD,EAAkB,wBAAyB,OAAQqD,GAEnDrD,EAAkB,wBAAyB,gBAAiBoO,GAC5D,IAII7K,EAJEC,EAAe,gBAChBrE,QAAQ,SAAesE,mBAAmBC,OAAOL,KAEhDM,EAAiB,IAAIC,IAAIJ,EAAczD,GAEzCV,IACAkE,EAAclE,EAAckE,aAGhC,IAAMM,EAAsB,KAAKC,OAAQ,SAAYP,GAAgBP,GAC/De,EAA0B,GAC1BC,EAAyB,SAIzB3D,EAAsB0D,EAAyB1E,GAIrD0E,EAAwB,gBAAkB,mBAE1CpC,EAAgBgC,EAAgBK,GAChC,IAAIC,EAAyBV,GAAeA,EAAYhB,QAAUgB,EAAYhB,QAAU,GAIxF,OAHAsB,EAAuBtB,QAAO,SAAOwB,GAA4BE,GAA2BjB,EAAQT,SACpGsB,EAAuBK,KAAOhC,EAAsBkM,EAAevK,EAAwBxE,GAEpF,CACHuC,IAAKc,EAAaiB,GAClBX,QAASa,MAEhB,qDAnCqB,IA4CQwK,CAAmChP,GACrE,MAAO,CAQGyO,sBAAqB,gCAACtH,EAA8BxD,GACtD,IAAMyB,QAA0BtB,EAA0B2K,sBAAsBtH,EAAexD,GAC/F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH0B,GAUrB0O,uBAAsB,gCAAC/K,GACzB,IAAMyB,QAA0BtB,EAA0B4K,uBAAuB/K,GACjF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,mDAH2B,GAWtB2O,uBAAsB,gCAAC3K,EAAcL,GACvC,IAAMyB,QAA0BtB,EAA0B6K,uBAAuB3K,EAAML,GACvF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH2B,GAWtB4O,2BAA0B,gCAAC5K,EAAcL,GAC3C,IAAMyB,QAA0BtB,EAA0B8K,2BAA2B5K,EAAML,GAC3F,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH+B,GAW1B6O,sBAAqB,gCAAC7K,EAAcL,GACtC,IAAMyB,QAA0BtB,EAA0B+K,sBAAsB7K,EAAML,GACtF,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,qDAH0B,GAYrB8O,sBAAqB,gCAAC9K,EAAc+K,EAA8BpL,GACpE,IAAMyB,QAA0BtB,EAA0BgL,sBAAsB9K,EAAM+K,EAAepL,GACrG,OAAOH,EAAsB4B,EAAmBjF,UAAaN,EAAWG,MAC3E,uDAH0B,MChwS7BiP,IDm1SwB,kIAS1B,SAA6B9H,EAA8BxD,GAA+B,IAAD,OACrF,OAAO6K,GAAoBpO,KAAKJ,eAAeyO,sBAAsBtH,EAAexD,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC3I,oCASD,SAA8B0D,GAA+B,IAAD,OACxD,OAAO6K,GAAoBpO,KAAKJ,eAAe0O,uBAAuB/K,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAC7H,oCAUD,SAA8B+D,EAAcL,GAA+B,IAAD,OACtE,OAAO6K,GAAoBpO,KAAKJ,eAAe2O,uBAAuB3K,EAAML,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACnI,wCAUD,SAAkC+D,EAAcL,GAA+B,IAAD,OAC1E,OAAO6K,GAAoBpO,KAAKJ,eAAe4O,2BAA2B5K,EAAML,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eACvI,mCAUD,SAA6B+D,EAAcL,GAA+B,IAAD,OACrE,OAAO6K,GAAoBpO,KAAKJ,eAAe6O,sBAAsB7K,EAAML,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,eAClI,mCAWD,SAA6B+D,EAAc+K,EAA8BpL,GAA+B,IAAD,OACnG,OAAO6K,GAAoBpO,KAAKJ,eAAe8O,sBAAsB9K,EAAM+K,EAAepL,GAAS2B,MAAK,SAAC1B,GAAO,OAAKA,EAAQ,EAAK1D,MAAO,EAAKD,iBAtExH,CAASF,GCn1SvB,IAAI4H,GARL,ICeW,WAmDtB,aAAkD,IAAtCuH,EAA8B,uDAAG,GAAE,YAC3C9O,KAAKe,OAAS+N,EAAM/N,OACpBf,KAAK+O,SAAWD,EAAMC,SACtB/O,KAAKgP,SAAWF,EAAME,SACtBhP,KAAKiB,YAAc6N,EAAM7N,YACzBjB,KAAKH,SAAWiP,EAAMjP,SACtBG,KAAK8D,YAAcgL,EAAMhL,YACzB9D,KAAKmH,aAAe2H,EAAM3H,aAgB7B,OAfA,+BAYD,SAAkB8H,GACd,IAAMC,EAAmB,IAAIC,OAAO,8DAAiE,KACrG,OAAgB,OAATF,IAAkBC,EAASE,KAAKH,IAAgC,gCAAvBA,EAAKI,mBACxD,EA1EqB,IDTT,wCAJKvP,UAAMwP,OAAO,CACjCxM,QAAS,CAAEyM,cAAe,kBEwDtBC,GAED,SAAC7Q,GACJ,MAAkC8Q,IAAMC,UAAS,GAAM,WAAhDC,EAAS,KAAEC,EAAY,KAK9B,OAJAH,IAAMI,WAAU,WACdD,EAAajR,EAAMmR,WAClB,CAACnR,IAGF,cAAC,SAAM,CACLgR,UAAWA,EACXI,gBAAiB,kBAAMH,GAAa,SAACI,GAAC,OAAMA,MAAG,SAE/C,cAAC,SAAOC,MAAK,CAACvR,MAAM,mBAKpBwR,GAASC,UAAWb,OAAO,CAC/Bc,OAAQ,CACNC,OAAQ,MAIGC,GAlFX,WACF,MAAkCZ,oBAAS,GAAM,WAA1CC,EAAS,KAAEC,EAAY,KACxBW,EAAO,CACX,CAAE7R,MAAO,eACT,CAAEA,MAAO,eACT,CACEA,MAAO,SACP8R,eAAgB,CAAEvR,gBAAiB,OACnCwR,WAAY,CAAElS,MAAO,SACrBH,QAAS,kBAAMwR,GAAa,MAI1Bc,EAAK,sBAAG,YAMZ,IACE,aAAa7B,GAAQlI,qBANC,CACtBgK,MAAO,WACP3B,SAAU,WAKV,MAAO4B,GACPC,QAAQC,KAAK,kCAEhB,kBAXU,mCAaX,EAAgDrB,IAAMC,UAAS,GAAM,WAA9DqB,EAAgB,KAAEC,EAAmB,KAE5C,OACE,eAACzR,EAAU,WACT,cAAC,GAAa,CAACuQ,QAASiB,IAExB,cAAC,SAAM,CAAC3S,QAASsS,EAAOhS,MAAM,UAC9B,cAAC,SAAM,CACLA,MAAM,oBACNN,QAAS,kBAAMwR,GAAa,IAC5BqB,YAAaf,GAAOE,SAEtB,eAAC,cAAW,CAACc,WAAY,GAAIvB,UAAWA,EAAU,UAC/CY,EAAKY,KAAI,SAACC,EAAGC,GAAC,OACb,cAAC,WAAQ,CAEPb,eAAgBY,EAAEZ,eAClBpS,QAASgT,EAAEhT,QAAQ,SAEnB,cAAC,WAASkT,QAAO,UACf,cAAC,WAASrB,MAAK,CAAChS,MAAOmT,EAAEX,WAAW,SAAEW,EAAE1S,WALrC2S,MAST,cAAC,WAAQ,CAACjT,QAAS,kBAAM4S,GAAoB,SAAChB,GAAC,OAAMA,MAAG,SACtD,cAAC,WAASC,MAAK,gCClDnBsB,GAAWC,oBAEF,cACb,IAAMC,EAAU,CACdC,SAAU,CAACC,SAEb,OACE,cAACC,EAAA,QAAmB,CAACH,QAASA,EAASI,SAAU,cAAC,OAAI,yBAAmB,SACvE,eAACN,GAASO,UAAS,CACjBC,iBAAiB,OACjBC,cAAe,CACbC,OAAQ,kBAAM,cAACC,EAAM,MACrB,UAEF,cAACX,GAASY,OAAM,CAACrK,UAAWzI,EAAUe,KAAK,SAC3C,cAACmR,GAASY,OAAM,CAACrK,UAAWwI,GAAsBlQ,KAAK,sBCvBzDxB,GAAQ,CACZwT,YAAa,CACXC,QAAS,OACTlT,WAAY,OACZmT,UAAW,MACXC,MAAO,OACPC,MAAO,QAETC,WAAY,CACVJ,QAAS,OACTC,UAAW,MACXnT,WAAY,OACZoT,MAAO,QACPC,MAAO,UAcIE,UAVH,WACV,OACE,cAAC,mBAAgB,UACf,cAAC,gBAAa,CAAC9T,MAAOA,GAAM,SAC1B,cAAC,GAAa,U","file":"static/js/app.6b4a5a1e.chunk.js","sourcesContent":["import { Link, useLinkTo, useNavigation } from \"@react-navigation/native\";\nimport { Button, Header, Text } from \"@rneui/themed\";\nimport React from \"react\";\n\nexport default () => {\n  const linkTo = useLinkTo();\n  return (\n    <Header\n      style={{\n        flexDirection: \"row\",\n        justifyContent: \"space-around\",\n      }}\n    >\n      <Button onPress={() => linkTo({ screen: \"Home\" })}>\n        <Text h3>Ciao sono header</Text>\n      </Button>\n      <Button color={\"secondary\"} size={\"sm\"} raised title=\"Hey!\" />\n    </Header>\n  );\n};\n","import { useTheme } from \"@rneui/themed\";\nimport React from \"react\";\nimport { View } from \"react-native\";\n\nexport default (props) => {\n  const theme = useTheme();\n  return (\n    <View\n      style={{\n        flex: 1,\n        height: 200,\n        backgroundColor: theme.theme.colors.background,\n      }}\n    >\n      {props.children}\n    </View>\n  );\n};\n","import { Link, useLinkTo, useNavigation } from \"@react-navigation/native\";\nimport { Button, Text, useTheme } from \"@rneui/themed\";\nimport React from \"react\";\nimport { View } from \"react-native\";\nimport Background from \"./Elements/Background\";\n\nconst HomeView: React.FC = () => {\n  const nav = useNavigation();\n  const theme = useTheme();\n  const linkTo = useLinkTo();\n\n  return (\n    <Background>\n      <Button onPress={() => linkTo({ screen: \"BottomSheet\" })}>\n        <Text h2>Ciao sono andrea</Text>\n      </Button>\n    </Background>\n  );\n};\n\nexport default HomeView;\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * ToBe - API\n * Get Swagger in json OAS3 format <a target=\\\"_blank\\\" href=\\\"/api-json\\\" rel=\\\"noopener noreferrer\\\">here</a>        Esempio del formato GeoJSON utilizzato per la gestione delle aree di interesse:        {         \\\"type\\\": \\\"Point\\\",         \\\"coordinates\\\": [           35.859375,           35.17380831799959         ]       }\n *\n * The version of the OpenAPI document: 1.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport { Configuration } from \"./configuration\";\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';\n\nexport const BASE_PATH = \"http://localhost\".replace(/\\/+$/, \"\");\n\n/**\n *\n * @export\n */\nexport const COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n\n/**\n *\n * @export\n * @interface RequestArgs\n */\nexport interface RequestArgs {\n    url: string;\n    options: AxiosRequestConfig;\n}\n\n/**\n *\n * @export\n * @class BaseAPI\n */\nexport class BaseAPI {\n    protected configuration: Configuration | undefined;\n\n    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = configuration.basePath || this.basePath;\n        }\n    }\n};\n\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nexport class RequiredError extends Error {\n    name: \"RequiredError\" = \"RequiredError\";\n    constructor(public field: string, msg?: string) {\n        super(msg);\n    }\n}\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * ToBe - API\n * Get Swagger in json OAS3 format <a target=\\\"_blank\\\" href=\\\"/api-json\\\" rel=\\\"noopener noreferrer\\\">here</a>        Esempio del formato GeoJSON utilizzato per la gestione delle aree di interesse:        {         \\\"type\\\": \\\"Point\\\",         \\\"coordinates\\\": [           35.859375,           35.17380831799959         ]       }\n *\n * The version of the OpenAPI document: 1.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport { Configuration } from \"./configuration\";\nimport { RequiredError, RequestArgs } from \"./base\";\nimport { AxiosInstance, AxiosResponse } from 'axios';\n\n/**\n *\n * @export\n */\nexport const DUMMY_BASE_URL = 'https://example.com'\n\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nexport const assertParamExists = function (functionName: string, paramName: string, paramValue: unknown) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setApiKeyToObject = async function (object: any, keyParamName: string, configuration?: Configuration) {\n    if (configuration && configuration.apiKey) {\n        const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n            ? await configuration.apiKey(keyParamName)\n            : await configuration.apiKey;\n        object[keyParamName] = localVarApiKeyValue;\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setBasicAuthToObject = function (object: any, configuration?: Configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setBearerAuthToObject = async function (object: any, configuration?: Configuration) {\n    if (configuration && configuration.accessToken) {\n        const accessToken = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + accessToken;\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setOAuthToObject = async function (object: any, name: string, scopes: string[], configuration?: Configuration) {\n    if (configuration && configuration.accessToken) {\n        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken(name, scopes)\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n    }\n}\n\nfunction setFlattenedQueryParams(urlSearchParams: URLSearchParams, parameter: any, key: string = \"\"): void {\n    if (typeof parameter === \"object\") {\n        if (Array.isArray(parameter)) {\n            (parameter as any[]).forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));\n        } \n        else {\n            Object.keys(parameter).forEach(currentKey => \n                setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`)\n            );\n        }\n    } \n    else {\n        if (urlSearchParams.has(key)) {\n            urlSearchParams.append(key, parameter);\n        } \n        else {\n            urlSearchParams.set(key, parameter);\n        }\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setSearchParams = function (url: URL, ...objects: any[]) {\n    const searchParams = new URLSearchParams(url.search);\n    setFlattenedQueryParams(searchParams, objects);\n    url.search = searchParams.toString();\n}\n\n/**\n *\n * @export\n */\nexport const serializeDataIfNeeded = function (value: any, requestOptions: any, configuration?: Configuration) {\n    const nonString = typeof value !== 'string';\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    return needsSerialization\n        ? JSON.stringify(value !== undefined ? value : {})\n        : (value || \"\");\n}\n\n/**\n *\n * @export\n */\nexport const toPathString = function (url: URL) {\n    return url.pathname + url.search + url.hash\n}\n\n/**\n *\n * @export\n */\nexport const createRequestFunction = function (axiosArgs: RequestArgs, globalAxios: AxiosInstance, BASE_PATH: string, configuration?: Configuration) {\n    return <T = unknown, R = AxiosResponse<T>>(axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {\n        const axiosRequestArgs = {...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url};\n        return axios.request<T, R>(axiosRequestArgs);\n    };\n}\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * ToBe - API\n * Get Swagger in json OAS3 format <a target=\\\"_blank\\\" href=\\\"/api-json\\\" rel=\\\"noopener noreferrer\\\">here</a>        Esempio del formato GeoJSON utilizzato per la gestione delle aree di interesse:        {         \\\"type\\\": \\\"Point\\\",         \\\"coordinates\\\": [           35.859375,           35.17380831799959         ]       }\n *\n * The version of the OpenAPI document: 1.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport { Configuration } from './configuration';\nimport globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';\n\n/**\n * \n * @export\n * @interface Address\n */\nexport interface Address {\n    /**\n     * \n     * @type {string}\n     * @memberof Address\n     */\n    'road'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Address\n     */\n    'village'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Address\n     */\n    'municipality'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Address\n     */\n    'province'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Address\n     */\n    'state'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Address\n     */\n    'postcode'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Address\n     */\n    'country'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Address\n     */\n    'country_code'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Address\n     */\n    'displayName': string;\n}\n/**\n * \n * @export\n * @interface AssignUserDto\n */\nexport interface AssignUserDto {\n    /**\n     * \n     * @type {string}\n     * @memberof AssignUserDto\n     */\n    'user': string;\n    /**\n     * \n     * @type {string}\n     * @memberof AssignUserDto\n     */\n    'level': AssignUserDtoLevelEnum;\n}\n\nexport const AssignUserDtoLevelEnum = {\n    Owner: 'Owner',\n    Manager: 'Manager'\n} as const;\n\nexport type AssignUserDtoLevelEnum = typeof AssignUserDtoLevelEnum[keyof typeof AssignUserDtoLevelEnum];\n\n/**\n * \n * @export\n * @interface ChangePasswordDto\n */\nexport interface ChangePasswordDto {\n    /**\n     * \n     * @type {string}\n     * @memberof ChangePasswordDto\n     */\n    'oldPassword'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof ChangePasswordDto\n     */\n    'password': string;\n    /**\n     * \n     * @type {string}\n     * @memberof ChangePasswordDto\n     */\n    'passwordConfirm': string;\n}\n/**\n * \n * @export\n * @interface ContentAttachment\n */\nexport interface ContentAttachment {\n    /**\n     * \n     * @type {string}\n     * @memberof ContentAttachment\n     */\n    'link'?: string | null;\n    /**\n     * \n     * @type {string}\n     * @memberof ContentAttachment\n     */\n    'name': string;\n    /**\n     * \n     * @type {string}\n     * @memberof ContentAttachment\n     */\n    'accessibility'?: ContentAttachmentAccessibilityEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof ContentAttachment\n     */\n    'mediaType'?: ContentAttachmentMediaTypeEnum;\n}\n\nexport const ContentAttachmentAccessibilityEnum = {\n    Ipovedente: 'ipovedente'\n} as const;\n\nexport type ContentAttachmentAccessibilityEnum = typeof ContentAttachmentAccessibilityEnum[keyof typeof ContentAttachmentAccessibilityEnum];\nexport const ContentAttachmentMediaTypeEnum = {\n    Image: 'image',\n    Video: 'video',\n    Audio: 'audio'\n} as const;\n\nexport type ContentAttachmentMediaTypeEnum = typeof ContentAttachmentMediaTypeEnum[keyof typeof ContentAttachmentMediaTypeEnum];\n\n/**\n * \n * @export\n * @interface CreateAddressDto\n */\nexport interface CreateAddressDto {\n    /**\n     * \n     * @type {string}\n     * @memberof CreateAddressDto\n     */\n    'road': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateAddressDto\n     */\n    'village': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateAddressDto\n     */\n    'municipality': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateAddressDto\n     */\n    'province': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateAddressDto\n     */\n    'state': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateAddressDto\n     */\n    'postcode': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateAddressDto\n     */\n    'country': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateAddressDto\n     */\n    'country_code': string;\n}\n/**\n * \n * @export\n * @interface CreateFaqDto\n */\nexport interface CreateFaqDto {\n    /**\n     * \n     * @type {string}\n     * @memberof CreateFaqDto\n     */\n    'question': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateFaqDto\n     */\n    'answer'?: string;\n    /**\n     * \n     * @type {boolean}\n     * @memberof CreateFaqDto\n     */\n    'visible'?: boolean;\n}\n/**\n * \n * @export\n * @interface CreateLifiAppDto\n */\nexport interface CreateLifiAppDto {\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiAppDto\n     */\n    'name': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiAppDto\n     */\n    'sector': CreateLifiAppDtoSectorEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiAppDto\n     */\n    'version': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiAppDto\n     */\n    'redirectUri'?: string;\n}\n\nexport const CreateLifiAppDtoSectorEnum = {\n    Arte: 'Arte',\n    Sanit: 'Sanit',\n    Verticale: 'Verticale'\n} as const;\n\nexport type CreateLifiAppDtoSectorEnum = typeof CreateLifiAppDtoSectorEnum[keyof typeof CreateLifiAppDtoSectorEnum];\n\n/**\n * \n * @export\n * @interface CreateLifiComponentDto\n */\nexport interface CreateLifiComponentDto {\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiComponentDto\n     */\n    'componentId'?: string;\n    /**\n     * \n     * @type {LocateLifiSiteDto}\n     * @memberof CreateLifiComponentDto\n     */\n    'position'?: LocateLifiSiteDto;\n    /**\n     * \n     * @type {number}\n     * @memberof CreateLifiComponentDto\n     */\n    'range'?: number;\n}\n/**\n * \n * @export\n * @interface CreateLifiContentDto\n */\nexport interface CreateLifiContentDto {\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiContentDto\n     */\n    'title': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiContentDto\n     */\n    'date_from'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiContentDto\n     */\n    'date_to'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiContentDto\n     */\n    'link'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiContentDto\n     */\n    'text': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiContentDto\n     */\n    'details'?: string;\n    /**\n     * \n     * @type {boolean}\n     * @memberof CreateLifiContentDto\n     */\n    'public'?: boolean;\n    /**\n     * \n     * @type {boolean}\n     * @memberof CreateLifiContentDto\n     */\n    'offline'?: boolean;\n}\n/**\n * \n * @export\n * @interface CreateLifiHotspotDto\n */\nexport interface CreateLifiHotspotDto {\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiHotspotDto\n     */\n    'code': string;\n}\n/**\n * \n * @export\n * @interface CreateLifiSiteDto\n */\nexport interface CreateLifiSiteDto {\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiSiteDto\n     */\n    'name': string;\n    /**\n     * \n     * @type {LocateLifiSiteDto}\n     * @memberof CreateLifiSiteDto\n     */\n    'location': LocateLifiSiteDto;\n    /**\n     * \n     * @type {number}\n     * @memberof CreateLifiSiteDto\n     */\n    'locateRange'?: number;\n    /**\n     * \n     * @type {CreateSignifyInfoDto}\n     * @memberof CreateLifiSiteDto\n     */\n    'signify': CreateSignifyInfoDto;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiSiteDto\n     */\n    'website'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateLifiSiteDto\n     */\n    'sector': string;\n    /**\n     * \n     * @type {Array<string>}\n     * @memberof CreateLifiSiteDto\n     */\n    'loghi': Array<string>;\n}\n/**\n * \n * @export\n * @interface CreateRegistryDto\n */\nexport interface CreateRegistryDto {\n    /**\n     * \n     * @type {string}\n     * @memberof CreateRegistryDto\n     */\n    'firstName': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateRegistryDto\n     */\n    'lastName': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateRegistryDto\n     */\n    'birthday': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateRegistryDto\n     */\n    'gender': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateRegistryDto\n     */\n    'phone'?: string;\n    /**\n     * \n     * @type {CreateAddressDto}\n     * @memberof CreateRegistryDto\n     */\n    'address'?: CreateAddressDto;\n}\n/**\n * \n * @export\n * @interface CreateSignifyInfoDto\n */\nexport interface CreateSignifyInfoDto {\n    /**\n     * \n     * @type {string}\n     * @memberof CreateSignifyInfoDto\n     */\n    'token': string;\n}\n/**\n * \n * @export\n * @interface CreateUserDto\n */\nexport interface CreateUserDto {\n    /**\n     * \n     * @type {string}\n     * @memberof CreateUserDto\n     */\n    'email': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateUserDto\n     */\n    'password': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateUserDto\n     */\n    'passwordConfirm': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreateUserDto\n     */\n    'role': CreateUserDtoRoleEnum;\n    /**\n     * \n     * @type {boolean}\n     * @memberof CreateUserDto\n     */\n    'privacy': boolean;\n    /**\n     * \n     * @type {boolean}\n     * @memberof CreateUserDto\n     */\n    'privacyThirdParty': boolean;\n}\n\nexport const CreateUserDtoRoleEnum = {\n    Developer: 'developer',\n    Admin: 'admin',\n    Creator: 'creator',\n    User: 'user'\n} as const;\n\nexport type CreateUserDtoRoleEnum = typeof CreateUserDtoRoleEnum[keyof typeof CreateUserDtoRoleEnum];\n\n/**\n * \n * @export\n * @interface Faq\n */\nexport interface Faq {\n    /**\n     * \n     * @type {string}\n     * @memberof Faq\n     */\n    'uuid': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Faq\n     */\n    'question': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Faq\n     */\n    'answer'?: string;\n    /**\n     * \n     * @type {boolean}\n     * @memberof Faq\n     */\n    'visible': boolean;\n    /**\n     * \n     * @type {string}\n     * @memberof Faq\n     */\n    'createdAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Faq\n     */\n    'updatedAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Faq\n     */\n    'deletedAt'?: string;\n    /**\n     * \n     * @type {FaqExclusiveTo}\n     * @memberof Faq\n     */\n    'exclusiveTo'?: FaqExclusiveTo | null;\n}\n/**\n * App to which this faq is exclusive to\n * @export\n * @interface FaqExclusiveTo\n */\nexport interface FaqExclusiveTo {\n    /**\n     * \n     * @type {string}\n     * @memberof FaqExclusiveTo\n     */\n    'uuid': string;\n    /**\n     * \n     * @type {string}\n     * @memberof FaqExclusiveTo\n     */\n    'name': string;\n    /**\n     * \n     * @type {string}\n     * @memberof FaqExclusiveTo\n     */\n    'sector': FaqExclusiveToSectorEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof FaqExclusiveTo\n     */\n    'version': string;\n    /**\n     * \n     * @type {string}\n     * @memberof FaqExclusiveTo\n     */\n    'redirectUri'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof FaqExclusiveTo\n     */\n    'createdAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof FaqExclusiveTo\n     */\n    'updatedAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof FaqExclusiveTo\n     */\n    'deletedAt'?: string;\n    /**\n     * \n     * @type {Array<Faq>}\n     * @memberof FaqExclusiveTo\n     */\n    'faqs': Array<Faq>;\n    /**\n     * \n     * @type {Array<LifiSite>}\n     * @memberof FaqExclusiveTo\n     */\n    'sites': Array<LifiSite>;\n}\n\nexport const FaqExclusiveToSectorEnum = {\n    Arte: 'Arte',\n    Sanit: 'Sanit',\n    Verticale: 'Verticale'\n} as const;\n\nexport type FaqExclusiveToSectorEnum = typeof FaqExclusiveToSectorEnum[keyof typeof FaqExclusiveToSectorEnum];\n\n/**\n * \n * @export\n * @interface LifiApp\n */\nexport interface LifiApp {\n    /**\n     * \n     * @type {string}\n     * @memberof LifiApp\n     */\n    'uuid': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiApp\n     */\n    'name': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiApp\n     */\n    'sector': LifiAppSectorEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiApp\n     */\n    'version': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiApp\n     */\n    'redirectUri'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiApp\n     */\n    'createdAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiApp\n     */\n    'updatedAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiApp\n     */\n    'deletedAt'?: string;\n    /**\n     * \n     * @type {Array<Faq>}\n     * @memberof LifiApp\n     */\n    'faqs': Array<Faq>;\n    /**\n     * \n     * @type {Array<LifiSite>}\n     * @memberof LifiApp\n     */\n    'sites': Array<LifiSite>;\n}\n\nexport const LifiAppSectorEnum = {\n    Arte: 'Arte',\n    Sanit: 'Sanit',\n    Verticale: 'Verticale'\n} as const;\n\nexport type LifiAppSectorEnum = typeof LifiAppSectorEnum[keyof typeof LifiAppSectorEnum];\n\n/**\n * \n * @export\n * @interface LifiComponent\n */\nexport interface LifiComponent {\n    /**\n     * \n     * @type {string}\n     * @memberof LifiComponent\n     */\n    'uuid': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiComponent\n     */\n    'componentId'?: string;\n    /**\n     * \n     * @type {object}\n     * @memberof LifiComponent\n     */\n    'position'?: object;\n    /**\n     * \n     * @type {number}\n     * @memberof LifiComponent\n     */\n    'range': number;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiComponent\n     */\n    'createdAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiComponent\n     */\n    'updatedAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiComponent\n     */\n    'deletedAt'?: string;\n    /**\n     * \n     * @type {LifiHotspot}\n     * @memberof LifiComponent\n     */\n    'hotspot'?: LifiHotspot;\n}\n/**\n * \n * @export\n * @interface LifiContent\n */\nexport interface LifiContent {\n    /**\n     * \n     * @type {string}\n     * @memberof LifiContent\n     */\n    'uuid': string;\n    /**\n     * \n     * @type {LifiHotspot}\n     * @memberof LifiContent\n     */\n    'hotspot'?: LifiHotspot;\n    /**\n     * \n     * @type {LifiSite}\n     * @memberof LifiContent\n     */\n    'networkSite'?: LifiSite;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiContent\n     */\n    'title': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiContent\n     */\n    'date_from'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiContent\n     */\n    'date_to'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiContent\n     */\n    'link'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiContent\n     */\n    'text': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiContent\n     */\n    'details'?: string;\n    /**\n     * \n     * @type {boolean}\n     * @memberof LifiContent\n     */\n    'public': boolean;\n    /**\n     * \n     * @type {boolean}\n     * @memberof LifiContent\n     */\n    'offline': boolean;\n    /**\n     * \n     * @type {Array<ContentAttachment>}\n     * @memberof LifiContent\n     */\n    'attachments': Array<ContentAttachment>;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiContent\n     */\n    'createdAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiContent\n     */\n    'updatedAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiContent\n     */\n    'deletedAt'?: string;\n}\n/**\n * \n * @export\n * @interface LifiHotspot\n */\nexport interface LifiHotspot {\n    /**\n     * \n     * @type {string}\n     * @memberof LifiHotspot\n     */\n    'uuid': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiHotspot\n     */\n    'code': string;\n    /**\n     * \n     * @type {LifiSite}\n     * @memberof LifiHotspot\n     */\n    'site': LifiSite;\n    /**\n     * \n     * @type {Array<LifiComponent>}\n     * @memberof LifiHotspot\n     */\n    'components': Array<LifiComponent>;\n    /**\n     * \n     * @type {Array<LifiContent>}\n     * @memberof LifiHotspot\n     */\n    'contents': Array<LifiContent>;\n}\n/**\n * \n * @export\n * @interface LifiSite\n */\nexport interface LifiSite {\n    /**\n     * \n     * @type {string}\n     * @memberof LifiSite\n     */\n    'uuid': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiSite\n     */\n    'name': string;\n    /**\n     * \n     * @type {object}\n     * @memberof LifiSite\n     */\n    'location': object;\n    /**\n     * \n     * @type {number}\n     * @memberof LifiSite\n     */\n    'locateRange': number;\n    /**\n     * \n     * @type {SignifyInfo}\n     * @memberof LifiSite\n     */\n    'signify'?: SignifyInfo;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiSite\n     */\n    'website'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiSite\n     */\n    'sector': string;\n    /**\n     * \n     * @type {Array<string>}\n     * @memberof LifiSite\n     */\n    'loghi': Array<string>;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiSite\n     */\n    'createdAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiSite\n     */\n    'updatedAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiSite\n     */\n    'deletedAt'?: string;\n    /**\n     * \n     * @type {Array<LifiApp>}\n     * @memberof LifiSite\n     */\n    'apps': Array<LifiApp>;\n    /**\n     * \n     * @type {Array<LifiContent>}\n     * @memberof LifiSite\n     */\n    'networkContents': Array<LifiContent>;\n    /**\n     * \n     * @type {Array<LifiSiteUserAbility>}\n     * @memberof LifiSite\n     */\n    'enabledUserAbilities': Array<LifiSiteUserAbility>;\n    /**\n     * \n     * @type {Array<LifiHotspot>}\n     * @memberof LifiSite\n     */\n    'hotspots': Array<LifiHotspot>;\n}\n/**\n * \n * @export\n * @interface LifiSiteUserAbility\n */\nexport interface LifiSiteUserAbility {\n    /**\n     * \n     * @type {string}\n     * @memberof LifiSiteUserAbility\n     */\n    'uuid': string;\n    /**\n     * \n     * @type {string}\n     * @memberof LifiSiteUserAbility\n     */\n    'level': LifiSiteUserAbilityLevelEnum;\n    /**\n     * \n     * @type {User}\n     * @memberof LifiSiteUserAbility\n     */\n    'user': User;\n    /**\n     * \n     * @type {LifiSite}\n     * @memberof LifiSiteUserAbility\n     */\n    'site': LifiSite;\n}\n\nexport const LifiSiteUserAbilityLevelEnum = {\n    Owner: 'Owner',\n    Manager: 'Manager'\n} as const;\n\nexport type LifiSiteUserAbilityLevelEnum = typeof LifiSiteUserAbilityLevelEnum[keyof typeof LifiSiteUserAbilityLevelEnum];\n\n/**\n * \n * @export\n * @interface LocateLifiSiteDto\n */\nexport interface LocateLifiSiteDto {\n    /**\n     * \n     * @type {number}\n     * @memberof LocateLifiSiteDto\n     */\n    'latitude': number;\n    /**\n     * \n     * @type {number}\n     * @memberof LocateLifiSiteDto\n     */\n    'longitude': number;\n}\n/**\n * \n * @export\n * @interface RefreshTokenDto\n */\nexport interface RefreshTokenDto {\n    /**\n     * \n     * @type {string}\n     * @memberof RefreshTokenDto\n     */\n    'refreshToken': string;\n}\n/**\n * \n * @export\n * @interface Registry\n */\nexport interface Registry {\n    /**\n     * \n     * @type {string}\n     * @memberof Registry\n     */\n    'uuid': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Registry\n     */\n    'firstName': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Registry\n     */\n    'lastName': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Registry\n     */\n    'birthday': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Registry\n     */\n    'gender': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Registry\n     */\n    'phone'?: string;\n    /**\n     * \n     * @type {Address}\n     * @memberof Registry\n     */\n    'address': Address;\n    /**\n     * \n     * @type {string}\n     * @memberof Registry\n     */\n    'createdAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Registry\n     */\n    'updatedAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Registry\n     */\n    'deletedAt'?: string;\n    /**\n     * \n     * @type {User}\n     * @memberof Registry\n     */\n    'user': User;\n}\n/**\n * \n * @export\n * @interface SignInDto\n */\nexport interface SignInDto {\n    /**\n     * \n     * @type {string}\n     * @memberof SignInDto\n     */\n    'email': string;\n    /**\n     * \n     * @type {string}\n     * @memberof SignInDto\n     */\n    'password': string;\n}\n/**\n * \n * @export\n * @interface SignifyInfo\n */\nexport interface SignifyInfo {\n    /**\n     * \n     * @type {boolean}\n     * @memberof SignifyInfo\n     */\n    'hasMap'?: boolean;\n    /**\n     * \n     * @type {string}\n     * @memberof SignifyInfo\n     */\n    'map'?: string | null;\n    /**\n     * \n     * @type {string}\n     * @memberof SignifyInfo\n     */\n    'token'?: string;\n}\n/**\n * \n * @export\n * @interface UpdateAddressDto\n */\nexport interface UpdateAddressDto {\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateAddressDto\n     */\n    'road'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateAddressDto\n     */\n    'village'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateAddressDto\n     */\n    'municipality'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateAddressDto\n     */\n    'province'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateAddressDto\n     */\n    'state'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateAddressDto\n     */\n    'postcode'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateAddressDto\n     */\n    'country'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateAddressDto\n     */\n    'country_code'?: string;\n}\n/**\n * \n * @export\n * @interface UpdateFaqDto\n */\nexport interface UpdateFaqDto {\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateFaqDto\n     */\n    'question'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateFaqDto\n     */\n    'answer'?: string;\n    /**\n     * \n     * @type {boolean}\n     * @memberof UpdateFaqDto\n     */\n    'visible'?: boolean;\n}\n/**\n * \n * @export\n * @interface UpdateLifiAppDto\n */\nexport interface UpdateLifiAppDto {\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiAppDto\n     */\n    'name'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiAppDto\n     */\n    'sector'?: UpdateLifiAppDtoSectorEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiAppDto\n     */\n    'version'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiAppDto\n     */\n    'redirectUri'?: string;\n}\n\nexport const UpdateLifiAppDtoSectorEnum = {\n    Arte: 'Arte',\n    Sanit: 'Sanit',\n    Verticale: 'Verticale'\n} as const;\n\nexport type UpdateLifiAppDtoSectorEnum = typeof UpdateLifiAppDtoSectorEnum[keyof typeof UpdateLifiAppDtoSectorEnum];\n\n/**\n * \n * @export\n * @interface UpdateLifiComponentDto\n */\nexport interface UpdateLifiComponentDto {\n    /**\n     * \n     * @type {LocateLifiSiteDto}\n     * @memberof UpdateLifiComponentDto\n     */\n    'position'?: LocateLifiSiteDto;\n    /**\n     * \n     * @type {number}\n     * @memberof UpdateLifiComponentDto\n     */\n    'range'?: number;\n}\n/**\n * \n * @export\n * @interface UpdateLifiContentDto\n */\nexport interface UpdateLifiContentDto {\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiContentDto\n     */\n    'title'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiContentDto\n     */\n    'date_from'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiContentDto\n     */\n    'date_to'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiContentDto\n     */\n    'link'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiContentDto\n     */\n    'text'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiContentDto\n     */\n    'details'?: string;\n    /**\n     * \n     * @type {boolean}\n     * @memberof UpdateLifiContentDto\n     */\n    'public'?: boolean;\n    /**\n     * \n     * @type {boolean}\n     * @memberof UpdateLifiContentDto\n     */\n    'offline'?: boolean;\n}\n/**\n * \n * @export\n * @interface UpdateLifiHotspotDto\n */\nexport interface UpdateLifiHotspotDto {\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiHotspotDto\n     */\n    'code'?: string;\n}\n/**\n * \n * @export\n * @interface UpdateLifiSiteDto\n */\nexport interface UpdateLifiSiteDto {\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiSiteDto\n     */\n    'name'?: string;\n    /**\n     * \n     * @type {LocateLifiSiteDto}\n     * @memberof UpdateLifiSiteDto\n     */\n    'location'?: LocateLifiSiteDto;\n    /**\n     * \n     * @type {number}\n     * @memberof UpdateLifiSiteDto\n     */\n    'locateRange'?: number;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiSiteDto\n     */\n    'website'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateLifiSiteDto\n     */\n    'sector'?: string;\n    /**\n     * \n     * @type {UpdateSignifyInfoDto}\n     * @memberof UpdateLifiSiteDto\n     */\n    'signify'?: UpdateSignifyInfoDto;\n    /**\n     * \n     * @type {Array<string>}\n     * @memberof UpdateLifiSiteDto\n     */\n    'loghi'?: Array<string>;\n}\n/**\n * \n * @export\n * @interface UpdateRegistryDto\n */\nexport interface UpdateRegistryDto {\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateRegistryDto\n     */\n    'firstName'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateRegistryDto\n     */\n    'lastName'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateRegistryDto\n     */\n    'birthday'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateRegistryDto\n     */\n    'gender'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateRegistryDto\n     */\n    'phone'?: string;\n    /**\n     * \n     * @type {UpdateAddressDto}\n     * @memberof UpdateRegistryDto\n     */\n    'address'?: UpdateAddressDto;\n}\n/**\n * \n * @export\n * @interface UpdateSignifyInfoDto\n */\nexport interface UpdateSignifyInfoDto {\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateSignifyInfoDto\n     */\n    'token'?: string;\n}\n/**\n * \n * @export\n * @interface UpdateUserDto\n */\nexport interface UpdateUserDto {\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateUserDto\n     */\n    'password'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateUserDto\n     */\n    'passwordConfirm'?: string;\n    /**\n     * \n     * @type {boolean}\n     * @memberof UpdateUserDto\n     */\n    'privacy'?: boolean;\n    /**\n     * \n     * @type {boolean}\n     * @memberof UpdateUserDto\n     */\n    'privacyThirdParty'?: boolean;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateUserDto\n     */\n    'email'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdateUserDto\n     */\n    'role'?: UpdateUserDtoRoleEnum;\n}\n\nexport const UpdateUserDtoRoleEnum = {\n    Developer: 'developer',\n    Admin: 'admin',\n    Creator: 'creator',\n    User: 'user'\n} as const;\n\nexport type UpdateUserDtoRoleEnum = typeof UpdateUserDtoRoleEnum[keyof typeof UpdateUserDtoRoleEnum];\n\n/**\n * \n * @export\n * @interface User\n */\nexport interface User {\n    /**\n     * True if the user has an extended access to any site\n     * @type {boolean}\n     * @memberof User\n     */\n    'hasManagerAccess': boolean;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'uuid': string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'email': string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'password'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'refreshToken'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'profilePicture'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'role': UserRoleEnum;\n    /**\n     * \n     * @type {boolean}\n     * @memberof User\n     */\n    'verified': boolean;\n    /**\n     * \n     * @type {boolean}\n     * @memberof User\n     */\n    'privacy': boolean;\n    /**\n     * \n     * @type {boolean}\n     * @memberof User\n     */\n    'privacyThirdParty': boolean;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'googleUserId'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'facebookUserId'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'appleUserId'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'createdAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'updatedAt': string;\n    /**\n     * \n     * @type {string}\n     * @memberof User\n     */\n    'deletedAt'?: string;\n    /**\n     * \n     * @type {Registry}\n     * @memberof User\n     */\n    'registry'?: Registry;\n    /**\n     * \n     * @type {Array<LifiSiteUserAbility>}\n     * @memberof User\n     */\n    'enabledSiteAbilities': Array<LifiSiteUserAbility>;\n}\n\nexport const UserRoleEnum = {\n    Developer: 'developer',\n    Admin: 'admin',\n    Creator: 'creator',\n    User: 'user'\n} as const;\n\nexport type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];\n\n\n/**\n * AdminRegistryManagementApi - axios parameter creator\n * @export\n */\nexport const AdminRegistryManagementApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Create the registry for the user\n         * @param {string} user \n         * @param {CreateRegistryDto} createRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        adminRegistryControllerCreate: async (user: string, createRegistryDto: CreateRegistryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'user' is not null or undefined\n            assertParamExists('adminRegistryControllerCreate', 'user', user)\n            // verify required parameter 'createRegistryDto' is not null or undefined\n            assertParamExists('adminRegistryControllerCreate', 'createRegistryDto', createRegistryDto)\n            const localVarPath = `/users/{user}/registry`\n                .replace(`{${\"user\"}}`, encodeURIComponent(String(user)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createRegistryDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get the user\\'s registry\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        adminRegistryControllerFindAll: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'user' is not null or undefined\n            assertParamExists('adminRegistryControllerFindAll', 'user', user)\n            const localVarPath = `/users/{user}/registry`\n                .replace(`{${\"user\"}}`, encodeURIComponent(String(user)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Delete the registry for the user\n         * @param {string} registry \n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        adminRegistryControllerRemove: async (registry: string, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'registry' is not null or undefined\n            assertParamExists('adminRegistryControllerRemove', 'registry', registry)\n            // verify required parameter 'user' is not null or undefined\n            assertParamExists('adminRegistryControllerRemove', 'user', user)\n            const localVarPath = `/users/{user}/registry/{registry}`\n                .replace(`{${\"registry\"}}`, encodeURIComponent(String(registry)))\n                .replace(`{${\"user\"}}`, encodeURIComponent(String(user)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update the registry for the user\n         * @param {string} registry \n         * @param {string} user \n         * @param {UpdateRegistryDto} updateRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        adminRegistryControllerUpdate: async (registry: string, user: string, updateRegistryDto: UpdateRegistryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'registry' is not null or undefined\n            assertParamExists('adminRegistryControllerUpdate', 'registry', registry)\n            // verify required parameter 'user' is not null or undefined\n            assertParamExists('adminRegistryControllerUpdate', 'user', user)\n            // verify required parameter 'updateRegistryDto' is not null or undefined\n            assertParamExists('adminRegistryControllerUpdate', 'updateRegistryDto', updateRegistryDto)\n            const localVarPath = `/users/{user}/registry/{registry}`\n                .replace(`{${\"registry\"}}`, encodeURIComponent(String(registry)))\n                .replace(`{${\"user\"}}`, encodeURIComponent(String(user)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateRegistryDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * AdminRegistryManagementApi - functional programming interface\n * @export\n */\nexport const AdminRegistryManagementApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = AdminRegistryManagementApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Create the registry for the user\n         * @param {string} user \n         * @param {CreateRegistryDto} createRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async adminRegistryControllerCreate(user: string, createRegistryDto: CreateRegistryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRegistryControllerCreate(user, createRegistryDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get the user\\'s registry\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async adminRegistryControllerFindAll(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRegistryControllerFindAll(user, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Delete the registry for the user\n         * @param {string} registry \n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async adminRegistryControllerRemove(registry: string, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRegistryControllerRemove(registry, user, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Update the registry for the user\n         * @param {string} registry \n         * @param {string} user \n         * @param {UpdateRegistryDto} updateRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async adminRegistryControllerUpdate(registry: string, user: string, updateRegistryDto: UpdateRegistryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRegistryControllerUpdate(registry, user, updateRegistryDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * AdminRegistryManagementApi - factory interface\n * @export\n */\nexport const AdminRegistryManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = AdminRegistryManagementApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Create the registry for the user\n         * @param {string} user \n         * @param {CreateRegistryDto} createRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        adminRegistryControllerCreate(user: string, createRegistryDto: CreateRegistryDto, options?: any): AxiosPromise<Registry> {\n            return localVarFp.adminRegistryControllerCreate(user, createRegistryDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get the user\\'s registry\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        adminRegistryControllerFindAll(user: string, options?: any): AxiosPromise<Registry> {\n            return localVarFp.adminRegistryControllerFindAll(user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Delete the registry for the user\n         * @param {string} registry \n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        adminRegistryControllerRemove(registry: string, user: string, options?: any): AxiosPromise<Registry> {\n            return localVarFp.adminRegistryControllerRemove(registry, user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update the registry for the user\n         * @param {string} registry \n         * @param {string} user \n         * @param {UpdateRegistryDto} updateRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        adminRegistryControllerUpdate(registry: string, user: string, updateRegistryDto: UpdateRegistryDto, options?: any): AxiosPromise<Registry> {\n            return localVarFp.adminRegistryControllerUpdate(registry, user, updateRegistryDto, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * AdminRegistryManagementApi - object-oriented interface\n * @export\n * @class AdminRegistryManagementApi\n * @extends {BaseAPI}\n */\nexport class AdminRegistryManagementApi extends BaseAPI {\n    /**\n     * \n     * @summary Create the registry for the user\n     * @param {string} user \n     * @param {CreateRegistryDto} createRegistryDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AdminRegistryManagementApi\n     */\n    public adminRegistryControllerCreate(user: string, createRegistryDto: CreateRegistryDto, options?: AxiosRequestConfig) {\n        return AdminRegistryManagementApiFp(this.configuration).adminRegistryControllerCreate(user, createRegistryDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get the user\\'s registry\n     * @param {string} user \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AdminRegistryManagementApi\n     */\n    public adminRegistryControllerFindAll(user: string, options?: AxiosRequestConfig) {\n        return AdminRegistryManagementApiFp(this.configuration).adminRegistryControllerFindAll(user, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Delete the registry for the user\n     * @param {string} registry \n     * @param {string} user \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AdminRegistryManagementApi\n     */\n    public adminRegistryControllerRemove(registry: string, user: string, options?: AxiosRequestConfig) {\n        return AdminRegistryManagementApiFp(this.configuration).adminRegistryControllerRemove(registry, user, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update the registry for the user\n     * @param {string} registry \n     * @param {string} user \n     * @param {UpdateRegistryDto} updateRegistryDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AdminRegistryManagementApi\n     */\n    public adminRegistryControllerUpdate(registry: string, user: string, updateRegistryDto: UpdateRegistryDto, options?: AxiosRequestConfig) {\n        return AdminRegistryManagementApiFp(this.configuration).adminRegistryControllerUpdate(registry, user, updateRegistryDto, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * AppsManagementApi - axios parameter creator\n * @export\n */\nexport const AppsManagementApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Assign an accessible site to an app\n         * @param {string} app \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerAssign: async (app: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'app' is not null or undefined\n            assertParamExists('lifiAppsControllerAssign', 'app', app)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiAppsControllerAssign', 'site', site)\n            const localVarPath = `/lifi-apps/{app}/sites/{site}`\n                .replace(`{${\"app\"}}`, encodeURIComponent(String(app)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Create a new app\n         * @param {CreateLifiAppDto} createLifiAppDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerCreate: async (createLifiAppDto: CreateLifiAppDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createLifiAppDto' is not null or undefined\n            assertParamExists('lifiAppsControllerCreate', 'createLifiAppDto', createLifiAppDto)\n            const localVarPath = `/lifi-apps`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createLifiAppDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove a site assignation from an app\n         * @param {string} app \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerDismiss: async (app: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'app' is not null or undefined\n            assertParamExists('lifiAppsControllerDismiss', 'app', app)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiAppsControllerDismiss', 'site', site)\n            const localVarPath = `/lifi-apps/{app}/sites/{site}`\n                .replace(`{${\"app\"}}`, encodeURIComponent(String(app)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Find all apps\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/lifi-apps`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Find an app\n         * @param {string} app \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerFindOne: async (app: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'app' is not null or undefined\n            assertParamExists('lifiAppsControllerFindOne', 'app', app)\n            const localVarPath = `/lifi-apps/{app}`\n                .replace(`{${\"app\"}}`, encodeURIComponent(String(app)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all sites this app is assigned to.\n         * @param {string} app \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerGetAllSites: async (app: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'app' is not null or undefined\n            assertParamExists('lifiAppsControllerGetAllSites', 'app', app)\n            const localVarPath = `/lifi-apps/{app}/sites`\n                .replace(`{${\"app\"}}`, encodeURIComponent(String(app)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove an app\n         * @param {string} app \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerRemove: async (app: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'app' is not null or undefined\n            assertParamExists('lifiAppsControllerRemove', 'app', app)\n            const localVarPath = `/lifi-apps/{app}`\n                .replace(`{${\"app\"}}`, encodeURIComponent(String(app)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update an app\n         * @param {string} app \n         * @param {UpdateLifiAppDto} updateLifiAppDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerUpdate: async (app: string, updateLifiAppDto: UpdateLifiAppDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'app' is not null or undefined\n            assertParamExists('lifiAppsControllerUpdate', 'app', app)\n            // verify required parameter 'updateLifiAppDto' is not null or undefined\n            assertParamExists('lifiAppsControllerUpdate', 'updateLifiAppDto', updateLifiAppDto)\n            const localVarPath = `/lifi-apps/{app}`\n                .replace(`{${\"app\"}}`, encodeURIComponent(String(app)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiAppDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * AppsManagementApi - functional programming interface\n * @export\n */\nexport const AppsManagementApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = AppsManagementApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Assign an accessible site to an app\n         * @param {string} app \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiAppsControllerAssign(app: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiApp>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerAssign(app, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Create a new app\n         * @param {CreateLifiAppDto} createLifiAppDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiAppsControllerCreate(createLifiAppDto: CreateLifiAppDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerCreate(createLifiAppDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove a site assignation from an app\n         * @param {string} app \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiAppsControllerDismiss(app: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiApp>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerDismiss(app, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Find all apps\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiAppsControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerFindAll(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Find an app\n         * @param {string} app \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiAppsControllerFindOne(app: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerFindOne(app, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all sites this app is assigned to.\n         * @param {string} app \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiAppsControllerGetAllSites(app: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiSite>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerGetAllSites(app, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove an app\n         * @param {string} app \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiAppsControllerRemove(app: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerRemove(app, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Update an app\n         * @param {string} app \n         * @param {UpdateLifiAppDto} updateLifiAppDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiAppsControllerUpdate(app: string, updateLifiAppDto: UpdateLifiAppDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiAppsControllerUpdate(app, updateLifiAppDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * AppsManagementApi - factory interface\n * @export\n */\nexport const AppsManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = AppsManagementApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Assign an accessible site to an app\n         * @param {string} app \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerAssign(app: string, site: string, options?: any): AxiosPromise<LifiApp> {\n            return localVarFp.lifiAppsControllerAssign(app, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Create a new app\n         * @param {CreateLifiAppDto} createLifiAppDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerCreate(createLifiAppDto: CreateLifiAppDto, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiAppsControllerCreate(createLifiAppDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove a site assignation from an app\n         * @param {string} app \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerDismiss(app: string, site: string, options?: any): AxiosPromise<LifiApp> {\n            return localVarFp.lifiAppsControllerDismiss(app, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Find all apps\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerFindAll(options?: any): AxiosPromise<void> {\n            return localVarFp.lifiAppsControllerFindAll(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Find an app\n         * @param {string} app \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerFindOne(app: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiAppsControllerFindOne(app, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all sites this app is assigned to.\n         * @param {string} app \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerGetAllSites(app: string, options?: any): AxiosPromise<Array<LifiSite>> {\n            return localVarFp.lifiAppsControllerGetAllSites(app, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove an app\n         * @param {string} app \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerRemove(app: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiAppsControllerRemove(app, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update an app\n         * @param {string} app \n         * @param {UpdateLifiAppDto} updateLifiAppDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiAppsControllerUpdate(app: string, updateLifiAppDto: UpdateLifiAppDto, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiAppsControllerUpdate(app, updateLifiAppDto, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * AppsManagementApi - object-oriented interface\n * @export\n * @class AppsManagementApi\n * @extends {BaseAPI}\n */\nexport class AppsManagementApi extends BaseAPI {\n    /**\n     * \n     * @summary Assign an accessible site to an app\n     * @param {string} app \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppsManagementApi\n     */\n    public lifiAppsControllerAssign(app: string, site: string, options?: AxiosRequestConfig) {\n        return AppsManagementApiFp(this.configuration).lifiAppsControllerAssign(app, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Create a new app\n     * @param {CreateLifiAppDto} createLifiAppDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppsManagementApi\n     */\n    public lifiAppsControllerCreate(createLifiAppDto: CreateLifiAppDto, options?: AxiosRequestConfig) {\n        return AppsManagementApiFp(this.configuration).lifiAppsControllerCreate(createLifiAppDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove a site assignation from an app\n     * @param {string} app \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppsManagementApi\n     */\n    public lifiAppsControllerDismiss(app: string, site: string, options?: AxiosRequestConfig) {\n        return AppsManagementApiFp(this.configuration).lifiAppsControllerDismiss(app, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Find all apps\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppsManagementApi\n     */\n    public lifiAppsControllerFindAll(options?: AxiosRequestConfig) {\n        return AppsManagementApiFp(this.configuration).lifiAppsControllerFindAll(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Find an app\n     * @param {string} app \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppsManagementApi\n     */\n    public lifiAppsControllerFindOne(app: string, options?: AxiosRequestConfig) {\n        return AppsManagementApiFp(this.configuration).lifiAppsControllerFindOne(app, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all sites this app is assigned to.\n     * @param {string} app \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppsManagementApi\n     */\n    public lifiAppsControllerGetAllSites(app: string, options?: AxiosRequestConfig) {\n        return AppsManagementApiFp(this.configuration).lifiAppsControllerGetAllSites(app, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove an app\n     * @param {string} app \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppsManagementApi\n     */\n    public lifiAppsControllerRemove(app: string, options?: AxiosRequestConfig) {\n        return AppsManagementApiFp(this.configuration).lifiAppsControllerRemove(app, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update an app\n     * @param {string} app \n     * @param {UpdateLifiAppDto} updateLifiAppDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppsManagementApi\n     */\n    public lifiAppsControllerUpdate(app: string, updateLifiAppDto: UpdateLifiAppDto, options?: AxiosRequestConfig) {\n        return AppsManagementApiFp(this.configuration).lifiAppsControllerUpdate(app, updateLifiAppDto, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * AuthApi - axios parameter creator\n * @export\n */\nexport const AuthApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Change the user password\n         * @param {ChangePasswordDto} changePasswordDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerChangePassword: async (changePasswordDto: ChangePasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'changePasswordDto' is not null or undefined\n            assertParamExists('authControllerChangePassword', 'changePasswordDto', changePasswordDto)\n            const localVarPath = `/auth/change-password`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a CSRF token\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerGetCsrfToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/auth/csrf`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Fetch the signed user\\'s profile\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerGetProfile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/auth/profile`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a presigned url to a user\\'s profile picture\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerPresignedProfileImage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/auth/presignedProfileImage`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a user\\'s profile picture\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerProfileImage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/auth/profileImage`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Refresh the access token using the refresh token\n         * @param {RefreshTokenDto} refreshTokenDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerRefreshToken: async (refreshTokenDto: RefreshTokenDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'refreshTokenDto' is not null or undefined\n            assertParamExists('authControllerRefreshToken', 'refreshTokenDto', refreshTokenDto)\n            const localVarPath = `/auth/refresh`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Reset the user password\n         * @param {string} token \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerResetPassword: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'token' is not null or undefined\n            assertParamExists('authControllerResetPassword', 'token', token)\n            const localVarPath = `/auth/reset-password`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (token !== undefined) {\n                localVarQueryParameter['token'] = token;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Sign in an account\n         * @param {SignInDto} signInDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerSignIn: async (signInDto: SignInDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'signInDto' is not null or undefined\n            assertParamExists('authControllerSignIn', 'signInDto', signInDto)\n            const localVarPath = `/auth/signIn`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(signInDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Sign out from account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerSignOut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/auth/signOut`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Sign up a new account\n         * @param {CreateUserDto} createUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerSignUp: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createUserDto' is not null or undefined\n            assertParamExists('authControllerSignUp', 'createUserDto', createUserDto)\n            const localVarPath = `/auth/signUp`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Upload a profile picture\n         * @param {File} [file] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerUploadFile: async (file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/auth/upload`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();\n\n\n            if (file !== undefined) { \n                localVarFormParams.append('file', file as any);\n            }\n    \n    \n            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = localVarFormParams;\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Verify the user email\n         * @param {string} token \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerVerifyEmail: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'token' is not null or undefined\n            assertParamExists('authControllerVerifyEmail', 'token', token)\n            const localVarPath = `/auth/verify-email`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (token !== undefined) {\n                localVarQueryParameter['token'] = token;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * AuthApi - functional programming interface\n * @export\n */\nexport const AuthApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Change the user password\n         * @param {ChangePasswordDto} changePasswordDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerChangePassword(changePasswordDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get a CSRF token\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerGetCsrfToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetCsrfToken(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Fetch the signed user\\'s profile\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerGetProfile(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get a presigned url to a user\\'s profile picture\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerPresignedProfileImage(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerPresignedProfileImage(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get a user\\'s profile picture\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerProfileImage(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerProfileImage(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Refresh the access token using the refresh token\n         * @param {RefreshTokenDto} refreshTokenDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerRefreshToken(refreshTokenDto: RefreshTokenDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshToken(refreshTokenDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Reset the user password\n         * @param {string} token \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerResetPassword(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPassword(token, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Sign in an account\n         * @param {SignInDto} signInDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerSignIn(signInDto: SignInDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignIn(signInDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Sign out from account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerSignOut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignOut(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Sign up a new account\n         * @param {CreateUserDto} createUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerSignUp(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignUp(createUserDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Upload a profile picture\n         * @param {File} [file] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerUploadFile(file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerUploadFile(file, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Verify the user email\n         * @param {string} token \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authControllerVerifyEmail(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyEmail(token, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * AuthApi - factory interface\n * @export\n */\nexport const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = AuthApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Change the user password\n         * @param {ChangePasswordDto} changePasswordDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: any): AxiosPromise<void> {\n            return localVarFp.authControllerChangePassword(changePasswordDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a CSRF token\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerGetCsrfToken(options?: any): AxiosPromise<void> {\n            return localVarFp.authControllerGetCsrfToken(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Fetch the signed user\\'s profile\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerGetProfile(options?: any): AxiosPromise<User> {\n            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a presigned url to a user\\'s profile picture\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerPresignedProfileImage(options?: any): AxiosPromise<void> {\n            return localVarFp.authControllerPresignedProfileImage(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a user\\'s profile picture\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerProfileImage(options?: any): AxiosPromise<void> {\n            return localVarFp.authControllerProfileImage(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Refresh the access token using the refresh token\n         * @param {RefreshTokenDto} refreshTokenDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerRefreshToken(refreshTokenDto: RefreshTokenDto, options?: any): AxiosPromise<void> {\n            return localVarFp.authControllerRefreshToken(refreshTokenDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Reset the user password\n         * @param {string} token \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerResetPassword(token: string, options?: any): AxiosPromise<object> {\n            return localVarFp.authControllerResetPassword(token, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Sign in an account\n         * @param {SignInDto} signInDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerSignIn(signInDto: SignInDto, options?: any): AxiosPromise<void> {\n            return localVarFp.authControllerSignIn(signInDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Sign out from account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerSignOut(options?: any): AxiosPromise<void> {\n            return localVarFp.authControllerSignOut(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Sign up a new account\n         * @param {CreateUserDto} createUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerSignUp(createUserDto: CreateUserDto, options?: any): AxiosPromise<void> {\n            return localVarFp.authControllerSignUp(createUserDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Upload a profile picture\n         * @param {File} [file] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerUploadFile(file?: File, options?: any): AxiosPromise<object> {\n            return localVarFp.authControllerUploadFile(file, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Verify the user email\n         * @param {string} token \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authControllerVerifyEmail(token: string, options?: any): AxiosPromise<User> {\n            return localVarFp.authControllerVerifyEmail(token, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * AuthApi - object-oriented interface\n * @export\n * @class AuthApi\n * @extends {BaseAPI}\n */\nexport class AuthApi extends BaseAPI {\n    /**\n     * \n     * @summary Change the user password\n     * @param {ChangePasswordDto} changePasswordDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerChangePassword(changePasswordDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a CSRF token\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerGetCsrfToken(options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerGetCsrfToken(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Fetch the signed user\\'s profile\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerGetProfile(options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a presigned url to a user\\'s profile picture\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerPresignedProfileImage(options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerPresignedProfileImage(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a user\\'s profile picture\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerProfileImage(options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerProfileImage(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Refresh the access token using the refresh token\n     * @param {RefreshTokenDto} refreshTokenDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerRefreshToken(refreshTokenDto: RefreshTokenDto, options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerRefreshToken(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Reset the user password\n     * @param {string} token \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerResetPassword(token: string, options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerResetPassword(token, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Sign in an account\n     * @param {SignInDto} signInDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerSignIn(signInDto: SignInDto, options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerSignIn(signInDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Sign out from account\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerSignOut(options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerSignOut(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Sign up a new account\n     * @param {CreateUserDto} createUserDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerSignUp(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerSignUp(createUserDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Upload a profile picture\n     * @param {File} [file] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerUploadFile(file?: File, options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerUploadFile(file, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Verify the user email\n     * @param {string} token \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AuthApi\n     */\n    public authControllerVerifyEmail(token: string, options?: AxiosRequestConfig) {\n        return AuthApiFp(this.configuration).authControllerVerifyEmail(token, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * ComponentManagementApi - axios parameter creator\n * @export\n */\nexport const ComponentManagementApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Create a component\n         * @param {CreateLifiComponentDto} createLifiComponentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiComponentsControllerCreate: async (createLifiComponentDto: CreateLifiComponentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createLifiComponentDto' is not null or undefined\n            assertParamExists('lifiComponentsControllerCreate', 'createLifiComponentDto', createLifiComponentDto)\n            const localVarPath = `/lifi-components`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createLifiComponentDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all components\n         * @param {boolean} [assigned] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiComponentsControllerFindAll: async (assigned?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/lifi-components`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (assigned !== undefined) {\n                localVarQueryParameter['assigned'] = assigned;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a component\n         * @param {string} component \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiComponentsControllerFindOne: async (component: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'component' is not null or undefined\n            assertParamExists('lifiComponentsControllerFindOne', 'component', component)\n            const localVarPath = `/lifi-components/{component}`\n                .replace(`{${\"component\"}}`, encodeURIComponent(String(component)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove a component\n         * @param {string} component \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiComponentsControllerRemove: async (component: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'component' is not null or undefined\n            assertParamExists('lifiComponentsControllerRemove', 'component', component)\n            const localVarPath = `/lifi-components/{component}`\n                .replace(`{${\"component\"}}`, encodeURIComponent(String(component)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update a component\n         * @param {string} component \n         * @param {UpdateLifiComponentDto} updateLifiComponentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiComponentsControllerUpdate: async (component: string, updateLifiComponentDto: UpdateLifiComponentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'component' is not null or undefined\n            assertParamExists('lifiComponentsControllerUpdate', 'component', component)\n            // verify required parameter 'updateLifiComponentDto' is not null or undefined\n            assertParamExists('lifiComponentsControllerUpdate', 'updateLifiComponentDto', updateLifiComponentDto)\n            const localVarPath = `/lifi-components/{component}`\n                .replace(`{${\"component\"}}`, encodeURIComponent(String(component)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiComponentDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * ComponentManagementApi - functional programming interface\n * @export\n */\nexport const ComponentManagementApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = ComponentManagementApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Create a component\n         * @param {CreateLifiComponentDto} createLifiComponentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiComponentsControllerCreate(createLifiComponentDto: CreateLifiComponentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiComponentsControllerCreate(createLifiComponentDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all components\n         * @param {boolean} [assigned] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiComponentsControllerFindAll(assigned?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiComponent>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiComponentsControllerFindAll(assigned, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get a component\n         * @param {string} component \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiComponentsControllerFindOne(component: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiComponentsControllerFindOne(component, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove a component\n         * @param {string} component \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiComponentsControllerRemove(component: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiComponentsControllerRemove(component, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Update a component\n         * @param {string} component \n         * @param {UpdateLifiComponentDto} updateLifiComponentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiComponentsControllerUpdate(component: string, updateLifiComponentDto: UpdateLifiComponentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiComponentsControllerUpdate(component, updateLifiComponentDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * ComponentManagementApi - factory interface\n * @export\n */\nexport const ComponentManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = ComponentManagementApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Create a component\n         * @param {CreateLifiComponentDto} createLifiComponentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiComponentsControllerCreate(createLifiComponentDto: CreateLifiComponentDto, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiComponentsControllerCreate(createLifiComponentDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all components\n         * @param {boolean} [assigned] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiComponentsControllerFindAll(assigned?: boolean, options?: any): AxiosPromise<Array<LifiComponent>> {\n            return localVarFp.lifiComponentsControllerFindAll(assigned, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a component\n         * @param {string} component \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiComponentsControllerFindOne(component: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiComponentsControllerFindOne(component, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove a component\n         * @param {string} component \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiComponentsControllerRemove(component: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiComponentsControllerRemove(component, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update a component\n         * @param {string} component \n         * @param {UpdateLifiComponentDto} updateLifiComponentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiComponentsControllerUpdate(component: string, updateLifiComponentDto: UpdateLifiComponentDto, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiComponentsControllerUpdate(component, updateLifiComponentDto, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * ComponentManagementApi - object-oriented interface\n * @export\n * @class ComponentManagementApi\n * @extends {BaseAPI}\n */\nexport class ComponentManagementApi extends BaseAPI {\n    /**\n     * \n     * @summary Create a component\n     * @param {CreateLifiComponentDto} createLifiComponentDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ComponentManagementApi\n     */\n    public lifiComponentsControllerCreate(createLifiComponentDto: CreateLifiComponentDto, options?: AxiosRequestConfig) {\n        return ComponentManagementApiFp(this.configuration).lifiComponentsControllerCreate(createLifiComponentDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all components\n     * @param {boolean} [assigned] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ComponentManagementApi\n     */\n    public lifiComponentsControllerFindAll(assigned?: boolean, options?: AxiosRequestConfig) {\n        return ComponentManagementApiFp(this.configuration).lifiComponentsControllerFindAll(assigned, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a component\n     * @param {string} component \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ComponentManagementApi\n     */\n    public lifiComponentsControllerFindOne(component: string, options?: AxiosRequestConfig) {\n        return ComponentManagementApiFp(this.configuration).lifiComponentsControllerFindOne(component, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove a component\n     * @param {string} component \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ComponentManagementApi\n     */\n    public lifiComponentsControllerRemove(component: string, options?: AxiosRequestConfig) {\n        return ComponentManagementApiFp(this.configuration).lifiComponentsControllerRemove(component, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update a component\n     * @param {string} component \n     * @param {UpdateLifiComponentDto} updateLifiComponentDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ComponentManagementApi\n     */\n    public lifiComponentsControllerUpdate(component: string, updateLifiComponentDto: UpdateLifiComponentDto, options?: AxiosRequestConfig) {\n        return ComponentManagementApiFp(this.configuration).lifiComponentsControllerUpdate(component, updateLifiComponentDto, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * ContentManagementApi - axios parameter creator\n * @export\n */\nexport const ContentManagementApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Create a content in an hotspot\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {CreateLifiContentDto} createLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerCreate: async (hotspot: string, site: string, createLifiContentDto: CreateLifiContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiContentsControllerCreate', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiContentsControllerCreate', 'site', site)\n            // verify required parameter 'createLifiContentDto' is not null or undefined\n            assertParamExists('lifiContentsControllerCreate', 'createLifiContentDto', createLifiContentDto)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents`\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createLifiContentDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Download an attachment from a content\n         * @param {string} attachment \n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerDownloadAttachment: async (attachment: string, content: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'attachment' is not null or undefined\n            assertParamExists('lifiContentsControllerDownloadAttachment', 'attachment', attachment)\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiContentsControllerDownloadAttachment', 'content', content)\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiContentsControllerDownloadAttachment', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiContentsControllerDownloadAttachment', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}/attachments/{attachment}`\n                .replace(`{${\"attachment\"}}`, encodeURIComponent(String(attachment)))\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)))\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all contents in an hotspot\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerFindAll: async (hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiContentsControllerFindAll', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiContentsControllerFindAll', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents`\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a content in an hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerFindOne: async (content: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiContentsControllerFindOne', 'content', content)\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiContentsControllerFindOne', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiContentsControllerFindOne', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)))\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove a content from an hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerRemove: async (content: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiContentsControllerRemove', 'content', content)\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiContentsControllerRemove', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiContentsControllerRemove', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)))\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove an attachment from a content\n         * @param {string} attachment \n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerRemoveAttachment: async (attachment: string, content: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'attachment' is not null or undefined\n            assertParamExists('lifiContentsControllerRemoveAttachment', 'attachment', attachment)\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiContentsControllerRemoveAttachment', 'content', content)\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiContentsControllerRemoveAttachment', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiContentsControllerRemoveAttachment', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}/attachments/{attachment}`\n                .replace(`{${\"attachment\"}}`, encodeURIComponent(String(attachment)))\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)))\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update a content in an hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {UpdateLifiContentDto} updateLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerUpdate: async (content: string, hotspot: string, site: string, updateLifiContentDto: UpdateLifiContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiContentsControllerUpdate', 'content', content)\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiContentsControllerUpdate', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiContentsControllerUpdate', 'site', site)\n            // verify required parameter 'updateLifiContentDto' is not null or undefined\n            assertParamExists('lifiContentsControllerUpdate', 'updateLifiContentDto', updateLifiContentDto)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)))\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiContentDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Upload an attachment to a content\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {string} name \n         * @param {File} file \n         * @param {string} [accessibility] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerUploadAttachment: async (content: string, hotspot: string, site: string, name: string, file: File, accessibility?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiContentsControllerUploadAttachment', 'content', content)\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiContentsControllerUploadAttachment', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiContentsControllerUploadAttachment', 'site', site)\n            // verify required parameter 'name' is not null or undefined\n            assertParamExists('lifiContentsControllerUploadAttachment', 'name', name)\n            // verify required parameter 'file' is not null or undefined\n            assertParamExists('lifiContentsControllerUploadAttachment', 'file', file)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-contents/{content}/attachments`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)))\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n            if (name !== undefined) { \n                localVarFormParams.append('name', name as any);\n            }\n    \n            if (accessibility !== undefined) { \n                localVarFormParams.append('accessibility', accessibility as any);\n            }\n    \n            if (file !== undefined) { \n                localVarFormParams.append('file', file as any);\n            }\n    \n    \n            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = localVarFormParams;\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * ContentManagementApi - functional programming interface\n * @export\n */\nexport const ContentManagementApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = ContentManagementApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Create a content in an hotspot\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {CreateLifiContentDto} createLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiContentsControllerCreate(hotspot: string, site: string, createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerCreate(hotspot, site, createLifiContentDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Download an attachment from a content\n         * @param {string} attachment \n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiContentsControllerDownloadAttachment(attachment: string, content: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerDownloadAttachment(attachment, content, hotspot, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all contents in an hotspot\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiContentsControllerFindAll(hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerFindAll(hotspot, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get a content in an hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiContentsControllerFindOne(content: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerFindOne(content, hotspot, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove a content from an hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiContentsControllerRemove(content: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerRemove(content, hotspot, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove an attachment from a content\n         * @param {string} attachment \n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiContentsControllerRemoveAttachment(attachment: string, content: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerRemoveAttachment(attachment, content, hotspot, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Update a content in an hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {UpdateLifiContentDto} updateLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiContentsControllerUpdate(content: string, hotspot: string, site: string, updateLifiContentDto: UpdateLifiContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerUpdate(content, hotspot, site, updateLifiContentDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Upload an attachment to a content\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {string} name \n         * @param {File} file \n         * @param {string} [accessibility] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiContentsControllerUploadAttachment(content: string, hotspot: string, site: string, name: string, file: File, accessibility?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiContentsControllerUploadAttachment(content, hotspot, site, name, file, accessibility, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * ContentManagementApi - factory interface\n * @export\n */\nexport const ContentManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = ContentManagementApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Create a content in an hotspot\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {CreateLifiContentDto} createLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerCreate(hotspot: string, site: string, createLifiContentDto: CreateLifiContentDto, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.lifiContentsControllerCreate(hotspot, site, createLifiContentDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Download an attachment from a content\n         * @param {string} attachment \n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerDownloadAttachment(attachment: string, content: string, hotspot: string, site: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiContentsControllerDownloadAttachment(attachment, content, hotspot, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all contents in an hotspot\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerFindAll(hotspot: string, site: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiContentsControllerFindAll(hotspot, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a content in an hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerFindOne(content: string, hotspot: string, site: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiContentsControllerFindOne(content, hotspot, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove a content from an hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerRemove(content: string, hotspot: string, site: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiContentsControllerRemove(content, hotspot, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove an attachment from a content\n         * @param {string} attachment \n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerRemoveAttachment(attachment: string, content: string, hotspot: string, site: string, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.lifiContentsControllerRemoveAttachment(attachment, content, hotspot, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update a content in an hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {UpdateLifiContentDto} updateLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerUpdate(content: string, hotspot: string, site: string, updateLifiContentDto: UpdateLifiContentDto, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiContentsControllerUpdate(content, hotspot, site, updateLifiContentDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Upload an attachment to a content\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {string} name \n         * @param {File} file \n         * @param {string} [accessibility] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiContentsControllerUploadAttachment(content: string, hotspot: string, site: string, name: string, file: File, accessibility?: string, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.lifiContentsControllerUploadAttachment(content, hotspot, site, name, file, accessibility, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * ContentManagementApi - object-oriented interface\n * @export\n * @class ContentManagementApi\n * @extends {BaseAPI}\n */\nexport class ContentManagementApi extends BaseAPI {\n    /**\n     * \n     * @summary Create a content in an hotspot\n     * @param {string} hotspot \n     * @param {string} site \n     * @param {CreateLifiContentDto} createLifiContentDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContentManagementApi\n     */\n    public lifiContentsControllerCreate(hotspot: string, site: string, createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig) {\n        return ContentManagementApiFp(this.configuration).lifiContentsControllerCreate(hotspot, site, createLifiContentDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Download an attachment from a content\n     * @param {string} attachment \n     * @param {string} content \n     * @param {string} hotspot \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContentManagementApi\n     */\n    public lifiContentsControllerDownloadAttachment(attachment: string, content: string, hotspot: string, site: string, options?: AxiosRequestConfig) {\n        return ContentManagementApiFp(this.configuration).lifiContentsControllerDownloadAttachment(attachment, content, hotspot, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all contents in an hotspot\n     * @param {string} hotspot \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContentManagementApi\n     */\n    public lifiContentsControllerFindAll(hotspot: string, site: string, options?: AxiosRequestConfig) {\n        return ContentManagementApiFp(this.configuration).lifiContentsControllerFindAll(hotspot, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a content in an hotspot\n     * @param {string} content \n     * @param {string} hotspot \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContentManagementApi\n     */\n    public lifiContentsControllerFindOne(content: string, hotspot: string, site: string, options?: AxiosRequestConfig) {\n        return ContentManagementApiFp(this.configuration).lifiContentsControllerFindOne(content, hotspot, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove a content from an hotspot\n     * @param {string} content \n     * @param {string} hotspot \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContentManagementApi\n     */\n    public lifiContentsControllerRemove(content: string, hotspot: string, site: string, options?: AxiosRequestConfig) {\n        return ContentManagementApiFp(this.configuration).lifiContentsControllerRemove(content, hotspot, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove an attachment from a content\n     * @param {string} attachment \n     * @param {string} content \n     * @param {string} hotspot \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContentManagementApi\n     */\n    public lifiContentsControllerRemoveAttachment(attachment: string, content: string, hotspot: string, site: string, options?: AxiosRequestConfig) {\n        return ContentManagementApiFp(this.configuration).lifiContentsControllerRemoveAttachment(attachment, content, hotspot, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update a content in an hotspot\n     * @param {string} content \n     * @param {string} hotspot \n     * @param {string} site \n     * @param {UpdateLifiContentDto} updateLifiContentDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContentManagementApi\n     */\n    public lifiContentsControllerUpdate(content: string, hotspot: string, site: string, updateLifiContentDto: UpdateLifiContentDto, options?: AxiosRequestConfig) {\n        return ContentManagementApiFp(this.configuration).lifiContentsControllerUpdate(content, hotspot, site, updateLifiContentDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Upload an attachment to a content\n     * @param {string} content \n     * @param {string} hotspot \n     * @param {string} site \n     * @param {string} name \n     * @param {File} file \n     * @param {string} [accessibility] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContentManagementApi\n     */\n    public lifiContentsControllerUploadAttachment(content: string, hotspot: string, site: string, name: string, file: File, accessibility?: string, options?: AxiosRequestConfig) {\n        return ContentManagementApiFp(this.configuration).lifiContentsControllerUploadAttachment(content, hotspot, site, name, file, accessibility, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * FAQsManagementApi - axios parameter creator\n * @export\n */\nexport const FAQsManagementApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Create a FAQ\n         * @param {CreateFaqDto} createFaqDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerCreate: async (createFaqDto: CreateFaqDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createFaqDto' is not null or undefined\n            assertParamExists('faqControllerCreate', 'createFaqDto', createFaqDto)\n            const localVarPath = `/faq`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createFaqDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all FAQs\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/faq`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a FAQ\n         * @param {string} faq \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerFindOne: async (faq: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'faq' is not null or undefined\n            assertParamExists('faqControllerFindOne', 'faq', faq)\n            const localVarPath = `/faq/{faq}`\n                .replace(`{${\"faq\"}}`, encodeURIComponent(String(faq)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove a FAQ\n         * @param {string} faq \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerRemove: async (faq: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'faq' is not null or undefined\n            assertParamExists('faqControllerRemove', 'faq', faq)\n            const localVarPath = `/faq/{faq}`\n                .replace(`{${\"faq\"}}`, encodeURIComponent(String(faq)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update a FAQ\n         * @param {string} faq \n         * @param {UpdateFaqDto} updateFaqDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerUpdate: async (faq: string, updateFaqDto: UpdateFaqDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'faq' is not null or undefined\n            assertParamExists('faqControllerUpdate', 'faq', faq)\n            // verify required parameter 'updateFaqDto' is not null or undefined\n            assertParamExists('faqControllerUpdate', 'updateFaqDto', updateFaqDto)\n            const localVarPath = `/faq/{faq}`\n                .replace(`{${\"faq\"}}`, encodeURIComponent(String(faq)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateFaqDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * FAQsManagementApi - functional programming interface\n * @export\n */\nexport const FAQsManagementApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = FAQsManagementApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Create a FAQ\n         * @param {CreateFaqDto} createFaqDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async faqControllerCreate(createFaqDto: CreateFaqDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerCreate(createFaqDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all FAQs\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async faqControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Faq>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerFindAll(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get a FAQ\n         * @param {string} faq \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async faqControllerFindOne(faq: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Faq>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerFindOne(faq, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove a FAQ\n         * @param {string} faq \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async faqControllerRemove(faq: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerRemove(faq, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Update a FAQ\n         * @param {string} faq \n         * @param {UpdateFaqDto} updateFaqDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async faqControllerUpdate(faq: string, updateFaqDto: UpdateFaqDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Faq>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerUpdate(faq, updateFaqDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * FAQsManagementApi - factory interface\n * @export\n */\nexport const FAQsManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = FAQsManagementApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Create a FAQ\n         * @param {CreateFaqDto} createFaqDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerCreate(createFaqDto: CreateFaqDto, options?: any): AxiosPromise<void> {\n            return localVarFp.faqControllerCreate(createFaqDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all FAQs\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerFindAll(options?: any): AxiosPromise<Array<Faq>> {\n            return localVarFp.faqControllerFindAll(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a FAQ\n         * @param {string} faq \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerFindOne(faq: string, options?: any): AxiosPromise<Faq> {\n            return localVarFp.faqControllerFindOne(faq, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove a FAQ\n         * @param {string} faq \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerRemove(faq: string, options?: any): AxiosPromise<void> {\n            return localVarFp.faqControllerRemove(faq, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update a FAQ\n         * @param {string} faq \n         * @param {UpdateFaqDto} updateFaqDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerUpdate(faq: string, updateFaqDto: UpdateFaqDto, options?: any): AxiosPromise<Faq> {\n            return localVarFp.faqControllerUpdate(faq, updateFaqDto, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * FAQsManagementApi - object-oriented interface\n * @export\n * @class FAQsManagementApi\n * @extends {BaseAPI}\n */\nexport class FAQsManagementApi extends BaseAPI {\n    /**\n     * \n     * @summary Create a FAQ\n     * @param {CreateFaqDto} createFaqDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FAQsManagementApi\n     */\n    public faqControllerCreate(createFaqDto: CreateFaqDto, options?: AxiosRequestConfig) {\n        return FAQsManagementApiFp(this.configuration).faqControllerCreate(createFaqDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all FAQs\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FAQsManagementApi\n     */\n    public faqControllerFindAll(options?: AxiosRequestConfig) {\n        return FAQsManagementApiFp(this.configuration).faqControllerFindAll(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a FAQ\n     * @param {string} faq \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FAQsManagementApi\n     */\n    public faqControllerFindOne(faq: string, options?: AxiosRequestConfig) {\n        return FAQsManagementApiFp(this.configuration).faqControllerFindOne(faq, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove a FAQ\n     * @param {string} faq \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FAQsManagementApi\n     */\n    public faqControllerRemove(faq: string, options?: AxiosRequestConfig) {\n        return FAQsManagementApiFp(this.configuration).faqControllerRemove(faq, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update a FAQ\n     * @param {string} faq \n     * @param {UpdateFaqDto} updateFaqDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FAQsManagementApi\n     */\n    public faqControllerUpdate(faq: string, updateFaqDto: UpdateFaqDto, options?: AxiosRequestConfig) {\n        return FAQsManagementApiFp(this.configuration).faqControllerUpdate(faq, updateFaqDto, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * GuestAreaApi - axios parameter creator\n * @export\n */\nexport const GuestAreaApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Create a FAQ\n         * @param {CreateFaqDto} createFaqDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerCreate: async (createFaqDto: CreateFaqDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createFaqDto' is not null or undefined\n            assertParamExists('faqControllerCreate', 'createFaqDto', createFaqDto)\n            const localVarPath = `/faq`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createFaqDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a FAQ\n         * @param {string} faq \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerFindOne: async (faq: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'faq' is not null or undefined\n            assertParamExists('faqControllerFindOne', 'faq', faq)\n            const localVarPath = `/faq/{faq}`\n                .replace(`{${\"faq\"}}`, encodeURIComponent(String(faq)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * GuestAreaApi - functional programming interface\n * @export\n */\nexport const GuestAreaApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = GuestAreaApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Create a FAQ\n         * @param {CreateFaqDto} createFaqDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async faqControllerCreate(createFaqDto: CreateFaqDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerCreate(createFaqDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get a FAQ\n         * @param {string} faq \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async faqControllerFindOne(faq: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Faq>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.faqControllerFindOne(faq, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * GuestAreaApi - factory interface\n * @export\n */\nexport const GuestAreaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = GuestAreaApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Create a FAQ\n         * @param {CreateFaqDto} createFaqDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerCreate(createFaqDto: CreateFaqDto, options?: any): AxiosPromise<void> {\n            return localVarFp.faqControllerCreate(createFaqDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a FAQ\n         * @param {string} faq \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        faqControllerFindOne(faq: string, options?: any): AxiosPromise<Faq> {\n            return localVarFp.faqControllerFindOne(faq, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * GuestAreaApi - object-oriented interface\n * @export\n * @class GuestAreaApi\n * @extends {BaseAPI}\n */\nexport class GuestAreaApi extends BaseAPI {\n    /**\n     * \n     * @summary Create a FAQ\n     * @param {CreateFaqDto} createFaqDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestAreaApi\n     */\n    public faqControllerCreate(createFaqDto: CreateFaqDto, options?: AxiosRequestConfig) {\n        return GuestAreaApiFp(this.configuration).faqControllerCreate(createFaqDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a FAQ\n     * @param {string} faq \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestAreaApi\n     */\n    public faqControllerFindOne(faq: string, options?: AxiosRequestConfig) {\n        return GuestAreaApiFp(this.configuration).faqControllerFindOne(faq, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * GuestsAreaApi - axios parameter creator\n * @export\n */\nexport const GuestsAreaApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Get all hotspots in site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindAllHotspots: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('guestLifiContentsControllerFindAllHotspots', 'site', site)\n            const localVarPath = `/contents/{site}`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all active public contents from hotspot\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindAllPublicContents: async (hotspot: string, site: string, offline?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('guestLifiContentsControllerFindAllPublicContents', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('guestLifiContentsControllerFindAllPublicContents', 'site', site)\n            const localVarPath = `/contents/{site}/{hotspot}`\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            if (offline !== undefined) {\n                localVarQueryParameter['offline'] = offline;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all network type active public contents\n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindAllPublicNetworkContents: async (offline?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/contents/network`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            if (offline !== undefined) {\n                localVarQueryParameter['offline'] = offline;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all network type active public contents for specified site\n         * @param {string} site \n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindAllPublicNetworkContentsFromSite: async (site: string, offline?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('guestLifiContentsControllerFindAllPublicNetworkContentsFromSite', 'site', site)\n            const localVarPath = `/contents/{site}/network`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            if (offline !== undefined) {\n                localVarQueryParameter['offline'] = offline;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get single active public content from hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindOnePublicContent: async (content: string, hotspot: string, site: string, offline?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('guestLifiContentsControllerFindOnePublicContent', 'content', content)\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('guestLifiContentsControllerFindOnePublicContent', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('guestLifiContentsControllerFindOnePublicContent', 'site', site)\n            const localVarPath = `/contents/{site}/{hotspot}/{content}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)))\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            if (offline !== undefined) {\n                localVarQueryParameter['offline'] = offline;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get single network type active public content\n         * @param {string} content \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindOnePublicNetworkContent: async (content: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('guestLifiContentsControllerFindOnePublicNetworkContent', 'content', content)\n            const localVarPath = `/contents/network/{content}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get single network type active public content for specified site\n         * @param {string} content \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindOnePublicNetworkContentFromSite: async (content: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('guestLifiContentsControllerFindOnePublicNetworkContentFromSite', 'content', content)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('guestLifiContentsControllerFindOnePublicNetworkContentFromSite', 'site', site)\n            const localVarPath = `/contents/{site}/network/{content}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Locate a hotspot in a site\n         * @param {string} site \n         * @param {string} [componentId] \n         * @param {string} [lookup] \n         * @param {number} [latitude] \n         * @param {number} [longitude] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerLocate: async (site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiHotspotControllerLocate', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/locate`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (componentId !== undefined) {\n                localVarQueryParameter['componentId'] = componentId;\n            }\n\n            if (lookup !== undefined) {\n                localVarQueryParameter['lookup'] = lookup;\n            }\n\n            if (latitude !== undefined) {\n                localVarQueryParameter['latitude'] = latitude;\n            }\n\n            if (longitude !== undefined) {\n                localVarQueryParameter['longitude'] = longitude;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Locate a site near a given position\n         * @param {number} latitude \n         * @param {number} longitude \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerLocate: async (latitude: number, longitude: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'latitude' is not null or undefined\n            assertParamExists('lifiSitesControllerLocate', 'latitude', latitude)\n            // verify required parameter 'longitude' is not null or undefined\n            assertParamExists('lifiSitesControllerLocate', 'longitude', longitude)\n            const localVarPath = `/lifi-sites/locate`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            if (latitude !== undefined) {\n                localVarQueryParameter['latitude'] = latitude;\n            }\n\n            if (longitude !== undefined) {\n                localVarQueryParameter['longitude'] = longitude;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * GuestsAreaApi - functional programming interface\n * @export\n */\nexport const GuestsAreaApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = GuestsAreaApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Get all hotspots in site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async guestLifiContentsControllerFindAllHotspots(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiHotspot>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindAllHotspots(site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all active public contents from hotspot\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async guestLifiContentsControllerFindAllPublicContents(hotspot: string, site: string, offline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiContent>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindAllPublicContents(hotspot, site, offline, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all network type active public contents\n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async guestLifiContentsControllerFindAllPublicNetworkContents(offline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiContent>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindAllPublicNetworkContents(offline, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all network type active public contents for specified site\n         * @param {string} site \n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site: string, offline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiContent>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site, offline, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get single active public content from hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async guestLifiContentsControllerFindOnePublicContent(content: string, hotspot: string, site: string, offline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindOnePublicContent(content, hotspot, site, offline, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get single network type active public content\n         * @param {string} content \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async guestLifiContentsControllerFindOnePublicNetworkContent(content: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindOnePublicNetworkContent(content, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get single network type active public content for specified site\n         * @param {string} content \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Locate a hotspot in a site\n         * @param {string} site \n         * @param {string} [componentId] \n         * @param {string} [lookup] \n         * @param {number} [latitude] \n         * @param {number} [longitude] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiHotspot>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Locate a site near a given position\n         * @param {number} latitude \n         * @param {number} longitude \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerLocate(latitude: number, longitude: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerLocate(latitude, longitude, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * GuestsAreaApi - factory interface\n * @export\n */\nexport const GuestsAreaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = GuestsAreaApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Get all hotspots in site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindAllHotspots(site: string, options?: any): AxiosPromise<Array<LifiHotspot>> {\n            return localVarFp.guestLifiContentsControllerFindAllHotspots(site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all active public contents from hotspot\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindAllPublicContents(hotspot: string, site: string, offline?: boolean, options?: any): AxiosPromise<Array<LifiContent>> {\n            return localVarFp.guestLifiContentsControllerFindAllPublicContents(hotspot, site, offline, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all network type active public contents\n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindAllPublicNetworkContents(offline?: boolean, options?: any): AxiosPromise<Array<LifiContent>> {\n            return localVarFp.guestLifiContentsControllerFindAllPublicNetworkContents(offline, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all network type active public contents for specified site\n         * @param {string} site \n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site: string, offline?: boolean, options?: any): AxiosPromise<Array<LifiContent>> {\n            return localVarFp.guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site, offline, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get single active public content from hotspot\n         * @param {string} content \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {boolean} [offline] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindOnePublicContent(content: string, hotspot: string, site: string, offline?: boolean, options?: any): AxiosPromise<void> {\n            return localVarFp.guestLifiContentsControllerFindOnePublicContent(content, hotspot, site, offline, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get single network type active public content\n         * @param {string} content \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindOnePublicNetworkContent(content: string, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.guestLifiContentsControllerFindOnePublicNetworkContent(content, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get single network type active public content for specified site\n         * @param {string} content \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content: string, site: string, options?: any): AxiosPromise<void> {\n            return localVarFp.guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Locate a hotspot in a site\n         * @param {string} site \n         * @param {string} [componentId] \n         * @param {string} [lookup] \n         * @param {number} [latitude] \n         * @param {number} [longitude] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: any): AxiosPromise<LifiHotspot> {\n            return localVarFp.lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Locate a site near a given position\n         * @param {number} latitude \n         * @param {number} longitude \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerLocate(latitude: number, longitude: number, options?: any): AxiosPromise<LifiSite> {\n            return localVarFp.lifiSitesControllerLocate(latitude, longitude, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * GuestsAreaApi - object-oriented interface\n * @export\n * @class GuestsAreaApi\n * @extends {BaseAPI}\n */\nexport class GuestsAreaApi extends BaseAPI {\n    /**\n     * \n     * @summary Get all hotspots in site\n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestsAreaApi\n     */\n    public guestLifiContentsControllerFindAllHotspots(site: string, options?: AxiosRequestConfig) {\n        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindAllHotspots(site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all active public contents from hotspot\n     * @param {string} hotspot \n     * @param {string} site \n     * @param {boolean} [offline] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestsAreaApi\n     */\n    public guestLifiContentsControllerFindAllPublicContents(hotspot: string, site: string, offline?: boolean, options?: AxiosRequestConfig) {\n        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindAllPublicContents(hotspot, site, offline, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all network type active public contents\n     * @param {boolean} [offline] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestsAreaApi\n     */\n    public guestLifiContentsControllerFindAllPublicNetworkContents(offline?: boolean, options?: AxiosRequestConfig) {\n        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindAllPublicNetworkContents(offline, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all network type active public contents for specified site\n     * @param {string} site \n     * @param {boolean} [offline] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestsAreaApi\n     */\n    public guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site: string, offline?: boolean, options?: AxiosRequestConfig) {\n        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindAllPublicNetworkContentsFromSite(site, offline, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get single active public content from hotspot\n     * @param {string} content \n     * @param {string} hotspot \n     * @param {string} site \n     * @param {boolean} [offline] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestsAreaApi\n     */\n    public guestLifiContentsControllerFindOnePublicContent(content: string, hotspot: string, site: string, offline?: boolean, options?: AxiosRequestConfig) {\n        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindOnePublicContent(content, hotspot, site, offline, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get single network type active public content\n     * @param {string} content \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestsAreaApi\n     */\n    public guestLifiContentsControllerFindOnePublicNetworkContent(content: string, options?: AxiosRequestConfig) {\n        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindOnePublicNetworkContent(content, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get single network type active public content for specified site\n     * @param {string} content \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestsAreaApi\n     */\n    public guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content: string, site: string, options?: AxiosRequestConfig) {\n        return GuestsAreaApiFp(this.configuration).guestLifiContentsControllerFindOnePublicNetworkContentFromSite(content, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Locate a hotspot in a site\n     * @param {string} site \n     * @param {string} [componentId] \n     * @param {string} [lookup] \n     * @param {number} [latitude] \n     * @param {number} [longitude] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestsAreaApi\n     */\n    public lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: AxiosRequestConfig) {\n        return GuestsAreaApiFp(this.configuration).lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Locate a site near a given position\n     * @param {number} latitude \n     * @param {number} longitude \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof GuestsAreaApi\n     */\n    public lifiSitesControllerLocate(latitude: number, longitude: number, options?: AxiosRequestConfig) {\n        return GuestsAreaApiFp(this.configuration).lifiSitesControllerLocate(latitude, longitude, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * HotspotManagementApi - axios parameter creator\n * @export\n */\nexport const HotspotManagementApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Assign a component to a hotspot in a site\n         * @param {string} component \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerAssignComponent: async (component: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'component' is not null or undefined\n            assertParamExists('lifiHotspotControllerAssignComponent', 'component', component)\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiHotspotControllerAssignComponent', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiHotspotControllerAssignComponent', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-components/{component}`\n                .replace(`{${\"component\"}}`, encodeURIComponent(String(component)))\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Create a hotspot in a site\n         * @param {string} site \n         * @param {CreateLifiHotspotDto} createLifiHotspotDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerCreate: async (site: string, createLifiHotspotDto: CreateLifiHotspotDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiHotspotControllerCreate', 'site', site)\n            // verify required parameter 'createLifiHotspotDto' is not null or undefined\n            assertParamExists('lifiHotspotControllerCreate', 'createLifiHotspotDto', createLifiHotspotDto)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createLifiHotspotDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove a component from a hotspot in a site\n         * @param {string} component \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerDismissComponent: async (component: string, hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'component' is not null or undefined\n            assertParamExists('lifiHotspotControllerDismissComponent', 'component', component)\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiHotspotControllerDismissComponent', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiHotspotControllerDismissComponent', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-components/{component}`\n                .replace(`{${\"component\"}}`, encodeURIComponent(String(component)))\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all hotspots from a site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerFindAll: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiHotspotControllerFindAll', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all components assigned to a hotspot from a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerFindAssignedComponents: async (hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiHotspotControllerFindAssignedComponents', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiHotspotControllerFindAssignedComponents', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}/lifi-components`\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a hotspot in a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerFindOne: async (hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiHotspotControllerFindOne', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiHotspotControllerFindOne', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}`\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Locate a hotspot in a site\n         * @param {string} site \n         * @param {string} [componentId] \n         * @param {string} [lookup] \n         * @param {number} [latitude] \n         * @param {number} [longitude] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerLocate: async (site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiHotspotControllerLocate', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/locate`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (componentId !== undefined) {\n                localVarQueryParameter['componentId'] = componentId;\n            }\n\n            if (lookup !== undefined) {\n                localVarQueryParameter['lookup'] = lookup;\n            }\n\n            if (latitude !== undefined) {\n                localVarQueryParameter['latitude'] = latitude;\n            }\n\n            if (longitude !== undefined) {\n                localVarQueryParameter['longitude'] = longitude;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove a hotspot from a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerRemove: async (hotspot: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiHotspotControllerRemove', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiHotspotControllerRemove', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}`\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update a hotspot in a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {UpdateLifiHotspotDto} updateLifiHotspotDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerUpdate: async (hotspot: string, site: string, updateLifiHotspotDto: UpdateLifiHotspotDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'hotspot' is not null or undefined\n            assertParamExists('lifiHotspotControllerUpdate', 'hotspot', hotspot)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiHotspotControllerUpdate', 'site', site)\n            // verify required parameter 'updateLifiHotspotDto' is not null or undefined\n            assertParamExists('lifiHotspotControllerUpdate', 'updateLifiHotspotDto', updateLifiHotspotDto)\n            const localVarPath = `/lifi-sites/{site}/lifi-hotspots/{hotspot}`\n                .replace(`{${\"hotspot\"}}`, encodeURIComponent(String(hotspot)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiHotspotDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * HotspotManagementApi - functional programming interface\n * @export\n */\nexport const HotspotManagementApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = HotspotManagementApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Assign a component to a hotspot in a site\n         * @param {string} component \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiHotspotControllerAssignComponent(component: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiComponent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerAssignComponent(component, hotspot, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Create a hotspot in a site\n         * @param {string} site \n         * @param {CreateLifiHotspotDto} createLifiHotspotDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiHotspotControllerCreate(site: string, createLifiHotspotDto: CreateLifiHotspotDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiHotspot>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerCreate(site, createLifiHotspotDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove a component from a hotspot in a site\n         * @param {string} component \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiHotspotControllerDismissComponent(component: string, hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiComponent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerDismissComponent(component, hotspot, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all hotspots from a site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiHotspotControllerFindAll(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiHotspot>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerFindAll(site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all components assigned to a hotspot from a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiHotspotControllerFindAssignedComponents(hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiComponent>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerFindAssignedComponents(hotspot, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get a hotspot in a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiHotspotControllerFindOne(hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiHotspot>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerFindOne(hotspot, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Locate a hotspot in a site\n         * @param {string} site \n         * @param {string} [componentId] \n         * @param {string} [lookup] \n         * @param {number} [latitude] \n         * @param {number} [longitude] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiHotspot>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove a hotspot from a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiHotspotControllerRemove(hotspot: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerRemove(hotspot, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Update a hotspot in a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {UpdateLifiHotspotDto} updateLifiHotspotDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiHotspotControllerUpdate(hotspot: string, site: string, updateLifiHotspotDto: UpdateLifiHotspotDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiHotspotControllerUpdate(hotspot, site, updateLifiHotspotDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * HotspotManagementApi - factory interface\n * @export\n */\nexport const HotspotManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = HotspotManagementApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Assign a component to a hotspot in a site\n         * @param {string} component \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerAssignComponent(component: string, hotspot: string, site: string, options?: any): AxiosPromise<LifiComponent> {\n            return localVarFp.lifiHotspotControllerAssignComponent(component, hotspot, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Create a hotspot in a site\n         * @param {string} site \n         * @param {CreateLifiHotspotDto} createLifiHotspotDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerCreate(site: string, createLifiHotspotDto: CreateLifiHotspotDto, options?: any): AxiosPromise<LifiHotspot> {\n            return localVarFp.lifiHotspotControllerCreate(site, createLifiHotspotDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove a component from a hotspot in a site\n         * @param {string} component \n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerDismissComponent(component: string, hotspot: string, site: string, options?: any): AxiosPromise<LifiComponent> {\n            return localVarFp.lifiHotspotControllerDismissComponent(component, hotspot, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all hotspots from a site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerFindAll(site: string, options?: any): AxiosPromise<Array<LifiHotspot>> {\n            return localVarFp.lifiHotspotControllerFindAll(site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all components assigned to a hotspot from a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerFindAssignedComponents(hotspot: string, site: string, options?: any): AxiosPromise<Array<LifiComponent>> {\n            return localVarFp.lifiHotspotControllerFindAssignedComponents(hotspot, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a hotspot in a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerFindOne(hotspot: string, site: string, options?: any): AxiosPromise<LifiHotspot> {\n            return localVarFp.lifiHotspotControllerFindOne(hotspot, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Locate a hotspot in a site\n         * @param {string} site \n         * @param {string} [componentId] \n         * @param {string} [lookup] \n         * @param {number} [latitude] \n         * @param {number} [longitude] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: any): AxiosPromise<LifiHotspot> {\n            return localVarFp.lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove a hotspot from a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerRemove(hotspot: string, site: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiHotspotControllerRemove(hotspot, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update a hotspot in a site\n         * @param {string} hotspot \n         * @param {string} site \n         * @param {UpdateLifiHotspotDto} updateLifiHotspotDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiHotspotControllerUpdate(hotspot: string, site: string, updateLifiHotspotDto: UpdateLifiHotspotDto, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiHotspotControllerUpdate(hotspot, site, updateLifiHotspotDto, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * HotspotManagementApi - object-oriented interface\n * @export\n * @class HotspotManagementApi\n * @extends {BaseAPI}\n */\nexport class HotspotManagementApi extends BaseAPI {\n    /**\n     * \n     * @summary Assign a component to a hotspot in a site\n     * @param {string} component \n     * @param {string} hotspot \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HotspotManagementApi\n     */\n    public lifiHotspotControllerAssignComponent(component: string, hotspot: string, site: string, options?: AxiosRequestConfig) {\n        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerAssignComponent(component, hotspot, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Create a hotspot in a site\n     * @param {string} site \n     * @param {CreateLifiHotspotDto} createLifiHotspotDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HotspotManagementApi\n     */\n    public lifiHotspotControllerCreate(site: string, createLifiHotspotDto: CreateLifiHotspotDto, options?: AxiosRequestConfig) {\n        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerCreate(site, createLifiHotspotDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove a component from a hotspot in a site\n     * @param {string} component \n     * @param {string} hotspot \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HotspotManagementApi\n     */\n    public lifiHotspotControllerDismissComponent(component: string, hotspot: string, site: string, options?: AxiosRequestConfig) {\n        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerDismissComponent(component, hotspot, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all hotspots from a site\n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HotspotManagementApi\n     */\n    public lifiHotspotControllerFindAll(site: string, options?: AxiosRequestConfig) {\n        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerFindAll(site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all components assigned to a hotspot from a site\n     * @param {string} hotspot \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HotspotManagementApi\n     */\n    public lifiHotspotControllerFindAssignedComponents(hotspot: string, site: string, options?: AxiosRequestConfig) {\n        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerFindAssignedComponents(hotspot, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a hotspot in a site\n     * @param {string} hotspot \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HotspotManagementApi\n     */\n    public lifiHotspotControllerFindOne(hotspot: string, site: string, options?: AxiosRequestConfig) {\n        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerFindOne(hotspot, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Locate a hotspot in a site\n     * @param {string} site \n     * @param {string} [componentId] \n     * @param {string} [lookup] \n     * @param {number} [latitude] \n     * @param {number} [longitude] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HotspotManagementApi\n     */\n    public lifiHotspotControllerLocate(site: string, componentId?: string, lookup?: string, latitude?: number, longitude?: number, options?: AxiosRequestConfig) {\n        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerLocate(site, componentId, lookup, latitude, longitude, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove a hotspot from a site\n     * @param {string} hotspot \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HotspotManagementApi\n     */\n    public lifiHotspotControllerRemove(hotspot: string, site: string, options?: AxiosRequestConfig) {\n        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerRemove(hotspot, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update a hotspot in a site\n     * @param {string} hotspot \n     * @param {string} site \n     * @param {UpdateLifiHotspotDto} updateLifiHotspotDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HotspotManagementApi\n     */\n    public lifiHotspotControllerUpdate(hotspot: string, site: string, updateLifiHotspotDto: UpdateLifiHotspotDto, options?: AxiosRequestConfig) {\n        return HotspotManagementApiFp(this.configuration).lifiHotspotControllerUpdate(hotspot, site, updateLifiHotspotDto, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * IndexApi - axios parameter creator\n * @export\n */\nexport const IndexApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        appControllerVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/version`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * IndexApi - functional programming interface\n * @export\n */\nexport const IndexApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = IndexApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async appControllerVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerVersion(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * IndexApi - factory interface\n * @export\n */\nexport const IndexApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = IndexApiFp(configuration)\n    return {\n        /**\n         * \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        appControllerVersion(options?: any): AxiosPromise<void> {\n            return localVarFp.appControllerVersion(options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * IndexApi - object-oriented interface\n * @export\n * @class IndexApi\n * @extends {BaseAPI}\n */\nexport class IndexApi extends BaseAPI {\n    /**\n     * \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof IndexApi\n     */\n    public appControllerVersion(options?: AxiosRequestConfig) {\n        return IndexApiFp(this.configuration).appControllerVersion(options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * NetworkContentManagementApi - axios parameter creator\n * @export\n */\nexport const NetworkContentManagementApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Create a network content, unbound\n         * @param {CreateLifiContentDto} createLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerCreate: async (createLifiContentDto: CreateLifiContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createLifiContentDto' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerCreate', 'createLifiContentDto', createLifiContentDto)\n            const localVarPath = `/lifi-contents/network`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createLifiContentDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Create a network content, assigned to a site\n         * @param {string} site \n         * @param {CreateLifiContentDto} createLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerCreateWithSite: async (site: string, createLifiContentDto: CreateLifiContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerCreateWithSite', 'site', site)\n            // verify required parameter 'createLifiContentDto' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerCreateWithSite', 'createLifiContentDto', createLifiContentDto)\n            const localVarPath = `/lifi-sites/{site}/lifi-contents/network`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createLifiContentDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Download an attachment from a content\n         * @param {string} content \n         * @param {string} attachment \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerDownloadAttachment: async (content: string, attachment: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerDownloadAttachment', 'content', content)\n            // verify required parameter 'attachment' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerDownloadAttachment', 'attachment', attachment)\n            const localVarPath = `/lifi-contents/network/{content}/attachments/{attachment}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)))\n                .replace(`{${\"attachment\"}}`, encodeURIComponent(String(attachment)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all network contents\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/lifi-contents/network`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all network contents, filtered by site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerFindAllBySite: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerFindAllBySite', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/lifi-contents/network`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a network content\n         * @param {string} content \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerFindOne: async (content: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerFindOne', 'content', content)\n            const localVarPath = `/lifi-contents/network/{content}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove a network content\n         * @param {string} content \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerRemove: async (content: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerRemove', 'content', content)\n            const localVarPath = `/lifi-contents/network/{content}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove an attachment from a content\n         * @param {string} content \n         * @param {string} attachment \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerRemoveAttachment: async (content: string, attachment: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerRemoveAttachment', 'content', content)\n            // verify required parameter 'attachment' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerRemoveAttachment', 'attachment', attachment)\n            const localVarPath = `/lifi-contents/network/{content}/attachments/{attachment}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)))\n                .replace(`{${\"attachment\"}}`, encodeURIComponent(String(attachment)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update a network content\n         * @param {string} content \n         * @param {UpdateLifiContentDto} updateLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerUpdate: async (content: string, updateLifiContentDto: UpdateLifiContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerUpdate', 'content', content)\n            // verify required parameter 'updateLifiContentDto' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerUpdate', 'updateLifiContentDto', updateLifiContentDto)\n            const localVarPath = `/lifi-contents/network/{content}`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiContentDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Upload an attachment to a content\n         * @param {string} content \n         * @param {string} name \n         * @param {File} file \n         * @param {string} [accessibility] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerUploadAttachment: async (content: string, name: string, file: File, accessibility?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'content' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerUploadAttachment', 'content', content)\n            // verify required parameter 'name' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerUploadAttachment', 'name', name)\n            // verify required parameter 'file' is not null or undefined\n            assertParamExists('lifiNetworkContentsControllerUploadAttachment', 'file', file)\n            const localVarPath = `/lifi-contents/network/{content}/attachments`\n                .replace(`{${\"content\"}}`, encodeURIComponent(String(content)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n            if (name !== undefined) { \n                localVarFormParams.append('name', name as any);\n            }\n    \n            if (accessibility !== undefined) { \n                localVarFormParams.append('accessibility', accessibility as any);\n            }\n    \n            if (file !== undefined) { \n                localVarFormParams.append('file', file as any);\n            }\n    \n    \n            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = localVarFormParams;\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * NetworkContentManagementApi - functional programming interface\n * @export\n */\nexport const NetworkContentManagementApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = NetworkContentManagementApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Create a network content, unbound\n         * @param {CreateLifiContentDto} createLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiNetworkContentsControllerCreate(createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerCreate(createLifiContentDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Create a network content, assigned to a site\n         * @param {string} site \n         * @param {CreateLifiContentDto} createLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiNetworkContentsControllerCreateWithSite(site: string, createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerCreateWithSite(site, createLifiContentDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Download an attachment from a content\n         * @param {string} content \n         * @param {string} attachment \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiNetworkContentsControllerDownloadAttachment(content: string, attachment: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerDownloadAttachment(content, attachment, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all network contents\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiNetworkContentsControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiContent>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerFindAll(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all network contents, filtered by site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiNetworkContentsControllerFindAllBySite(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiContent>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerFindAllBySite(site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get a network content\n         * @param {string} content \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiNetworkContentsControllerFindOne(content: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerFindOne(content, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove a network content\n         * @param {string} content \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiNetworkContentsControllerRemove(content: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerRemove(content, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove an attachment from a content\n         * @param {string} content \n         * @param {string} attachment \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiNetworkContentsControllerRemoveAttachment(content: string, attachment: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerRemoveAttachment(content, attachment, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Update a network content\n         * @param {string} content \n         * @param {UpdateLifiContentDto} updateLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiNetworkContentsControllerUpdate(content: string, updateLifiContentDto: UpdateLifiContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerUpdate(content, updateLifiContentDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Upload an attachment to a content\n         * @param {string} content \n         * @param {string} name \n         * @param {File} file \n         * @param {string} [accessibility] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiNetworkContentsControllerUploadAttachment(content: string, name: string, file: File, accessibility?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiContent>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiNetworkContentsControllerUploadAttachment(content, name, file, accessibility, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * NetworkContentManagementApi - factory interface\n * @export\n */\nexport const NetworkContentManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = NetworkContentManagementApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Create a network content, unbound\n         * @param {CreateLifiContentDto} createLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerCreate(createLifiContentDto: CreateLifiContentDto, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.lifiNetworkContentsControllerCreate(createLifiContentDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Create a network content, assigned to a site\n         * @param {string} site \n         * @param {CreateLifiContentDto} createLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerCreateWithSite(site: string, createLifiContentDto: CreateLifiContentDto, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.lifiNetworkContentsControllerCreateWithSite(site, createLifiContentDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Download an attachment from a content\n         * @param {string} content \n         * @param {string} attachment \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerDownloadAttachment(content: string, attachment: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiNetworkContentsControllerDownloadAttachment(content, attachment, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all network contents\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerFindAll(options?: any): AxiosPromise<Array<LifiContent>> {\n            return localVarFp.lifiNetworkContentsControllerFindAll(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all network contents, filtered by site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerFindAllBySite(site: string, options?: any): AxiosPromise<Array<LifiContent>> {\n            return localVarFp.lifiNetworkContentsControllerFindAllBySite(site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a network content\n         * @param {string} content \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerFindOne(content: string, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.lifiNetworkContentsControllerFindOne(content, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove a network content\n         * @param {string} content \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerRemove(content: string, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.lifiNetworkContentsControllerRemove(content, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove an attachment from a content\n         * @param {string} content \n         * @param {string} attachment \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerRemoveAttachment(content: string, attachment: string, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.lifiNetworkContentsControllerRemoveAttachment(content, attachment, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update a network content\n         * @param {string} content \n         * @param {UpdateLifiContentDto} updateLifiContentDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerUpdate(content: string, updateLifiContentDto: UpdateLifiContentDto, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.lifiNetworkContentsControllerUpdate(content, updateLifiContentDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Upload an attachment to a content\n         * @param {string} content \n         * @param {string} name \n         * @param {File} file \n         * @param {string} [accessibility] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiNetworkContentsControllerUploadAttachment(content: string, name: string, file: File, accessibility?: string, options?: any): AxiosPromise<LifiContent> {\n            return localVarFp.lifiNetworkContentsControllerUploadAttachment(content, name, file, accessibility, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * NetworkContentManagementApi - object-oriented interface\n * @export\n * @class NetworkContentManagementApi\n * @extends {BaseAPI}\n */\nexport class NetworkContentManagementApi extends BaseAPI {\n    /**\n     * \n     * @summary Create a network content, unbound\n     * @param {CreateLifiContentDto} createLifiContentDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworkContentManagementApi\n     */\n    public lifiNetworkContentsControllerCreate(createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig) {\n        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerCreate(createLifiContentDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Create a network content, assigned to a site\n     * @param {string} site \n     * @param {CreateLifiContentDto} createLifiContentDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworkContentManagementApi\n     */\n    public lifiNetworkContentsControllerCreateWithSite(site: string, createLifiContentDto: CreateLifiContentDto, options?: AxiosRequestConfig) {\n        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerCreateWithSite(site, createLifiContentDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Download an attachment from a content\n     * @param {string} content \n     * @param {string} attachment \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworkContentManagementApi\n     */\n    public lifiNetworkContentsControllerDownloadAttachment(content: string, attachment: string, options?: AxiosRequestConfig) {\n        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerDownloadAttachment(content, attachment, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all network contents\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworkContentManagementApi\n     */\n    public lifiNetworkContentsControllerFindAll(options?: AxiosRequestConfig) {\n        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerFindAll(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all network contents, filtered by site\n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworkContentManagementApi\n     */\n    public lifiNetworkContentsControllerFindAllBySite(site: string, options?: AxiosRequestConfig) {\n        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerFindAllBySite(site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a network content\n     * @param {string} content \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworkContentManagementApi\n     */\n    public lifiNetworkContentsControllerFindOne(content: string, options?: AxiosRequestConfig) {\n        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerFindOne(content, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove a network content\n     * @param {string} content \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworkContentManagementApi\n     */\n    public lifiNetworkContentsControllerRemove(content: string, options?: AxiosRequestConfig) {\n        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerRemove(content, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove an attachment from a content\n     * @param {string} content \n     * @param {string} attachment \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworkContentManagementApi\n     */\n    public lifiNetworkContentsControllerRemoveAttachment(content: string, attachment: string, options?: AxiosRequestConfig) {\n        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerRemoveAttachment(content, attachment, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update a network content\n     * @param {string} content \n     * @param {UpdateLifiContentDto} updateLifiContentDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworkContentManagementApi\n     */\n    public lifiNetworkContentsControllerUpdate(content: string, updateLifiContentDto: UpdateLifiContentDto, options?: AxiosRequestConfig) {\n        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerUpdate(content, updateLifiContentDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Upload an attachment to a content\n     * @param {string} content \n     * @param {string} name \n     * @param {File} file \n     * @param {string} [accessibility] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworkContentManagementApi\n     */\n    public lifiNetworkContentsControllerUploadAttachment(content: string, name: string, file: File, accessibility?: string, options?: AxiosRequestConfig) {\n        return NetworkContentManagementApiFp(this.configuration).lifiNetworkContentsControllerUploadAttachment(content, name, file, accessibility, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * RegistryManagementApi - axios parameter creator\n * @export\n */\nexport const RegistryManagementApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Create the registry for the current user\n         * @param {CreateRegistryDto} createRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registryControllerCreate: async (createRegistryDto: CreateRegistryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createRegistryDto' is not null or undefined\n            assertParamExists('registryControllerCreate', 'createRegistryDto', createRegistryDto)\n            const localVarPath = `/registry`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createRegistryDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get the current user\\'s registry\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registryControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/registry`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Delete the registry for the current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registryControllerRemove: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/registry`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update the registry for the current user\n         * @param {UpdateRegistryDto} updateRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registryControllerUpdate: async (updateRegistryDto: UpdateRegistryDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'updateRegistryDto' is not null or undefined\n            assertParamExists('registryControllerUpdate', 'updateRegistryDto', updateRegistryDto)\n            const localVarPath = `/registry`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateRegistryDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * RegistryManagementApi - functional programming interface\n * @export\n */\nexport const RegistryManagementApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = RegistryManagementApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Create the registry for the current user\n         * @param {CreateRegistryDto} createRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async registryControllerCreate(createRegistryDto: CreateRegistryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.registryControllerCreate(createRegistryDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get the current user\\'s registry\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async registryControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.registryControllerFindAll(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Delete the registry for the current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async registryControllerRemove(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.registryControllerRemove(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Update the registry for the current user\n         * @param {UpdateRegistryDto} updateRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async registryControllerUpdate(updateRegistryDto: UpdateRegistryDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.registryControllerUpdate(updateRegistryDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * RegistryManagementApi - factory interface\n * @export\n */\nexport const RegistryManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = RegistryManagementApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Create the registry for the current user\n         * @param {CreateRegistryDto} createRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registryControllerCreate(createRegistryDto: CreateRegistryDto, options?: any): AxiosPromise<Registry> {\n            return localVarFp.registryControllerCreate(createRegistryDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get the current user\\'s registry\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registryControllerFindAll(options?: any): AxiosPromise<Registry> {\n            return localVarFp.registryControllerFindAll(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Delete the registry for the current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registryControllerRemove(options?: any): AxiosPromise<Registry> {\n            return localVarFp.registryControllerRemove(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update the registry for the current user\n         * @param {UpdateRegistryDto} updateRegistryDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registryControllerUpdate(updateRegistryDto: UpdateRegistryDto, options?: any): AxiosPromise<Registry> {\n            return localVarFp.registryControllerUpdate(updateRegistryDto, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * RegistryManagementApi - object-oriented interface\n * @export\n * @class RegistryManagementApi\n * @extends {BaseAPI}\n */\nexport class RegistryManagementApi extends BaseAPI {\n    /**\n     * \n     * @summary Create the registry for the current user\n     * @param {CreateRegistryDto} createRegistryDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RegistryManagementApi\n     */\n    public registryControllerCreate(createRegistryDto: CreateRegistryDto, options?: AxiosRequestConfig) {\n        return RegistryManagementApiFp(this.configuration).registryControllerCreate(createRegistryDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get the current user\\'s registry\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RegistryManagementApi\n     */\n    public registryControllerFindAll(options?: AxiosRequestConfig) {\n        return RegistryManagementApiFp(this.configuration).registryControllerFindAll(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Delete the registry for the current user\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RegistryManagementApi\n     */\n    public registryControllerRemove(options?: AxiosRequestConfig) {\n        return RegistryManagementApiFp(this.configuration).registryControllerRemove(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update the registry for the current user\n     * @param {UpdateRegistryDto} updateRegistryDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RegistryManagementApi\n     */\n    public registryControllerUpdate(updateRegistryDto: UpdateRegistryDto, options?: AxiosRequestConfig) {\n        return RegistryManagementApiFp(this.configuration).registryControllerUpdate(updateRegistryDto, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * SitesManagementApi - axios parameter creator\n * @export\n */\nexport const SitesManagementApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Assign a permission level to a user on an accessible site\n         * @param {string} site \n         * @param {AssignUserDto} assignUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerAssign: async (site: string, assignUserDto: AssignUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerAssign', 'site', site)\n            // verify required parameter 'assignUserDto' is not null or undefined\n            assertParamExists('lifiSitesControllerAssign', 'assignUserDto', assignUserDto)\n            const localVarPath = `/lifi-sites/{site}/users`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(assignUserDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new site with the given information\n         * @summary Create a new site\n         * @param {CreateLifiSiteDto} createLifiSiteDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerCreate: async (createLifiSiteDto: CreateLifiSiteDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createLifiSiteDto' is not null or undefined\n            assertParamExists('lifiSitesControllerCreate', 'createLifiSiteDto', createLifiSiteDto)\n            const localVarPath = `/lifi-sites`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createLifiSiteDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove a logo for this site\n         * @param {string} logo \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerDeleteLogo: async (logo: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'logo' is not null or undefined\n            assertParamExists('lifiSitesControllerDeleteLogo', 'logo', logo)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerDeleteLogo', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/logos/{logo}`\n                .replace(`{${\"logo\"}}`, encodeURIComponent(String(logo)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove a signify map for this site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerDeleteSignifyMap: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerDeleteSignifyMap', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/signify/map`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove an assignation to a user from an accessible site\n         * @param {string} user \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerDismiss: async (user: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'user' is not null or undefined\n            assertParamExists('lifiSitesControllerDismiss', 'user', user)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerDismiss', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/users/{user}`\n                .replace(`{${\"user\"}}`, encodeURIComponent(String(user)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Download a logo for this site\n         * @param {string} logo \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerDownloadLogo: async (logo: string, site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'logo' is not null or undefined\n            assertParamExists('lifiSitesControllerDownloadLogo', 'logo', logo)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerDownloadLogo', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/logos/{logo}`\n                .replace(`{${\"logo\"}}`, encodeURIComponent(String(logo)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Download a signify map for this site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerDownloadSignifyMap: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerDownloadSignifyMap', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/signify/map`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Find all accessible sites\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/lifi-sites`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Find an accessible site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerFindOne: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerFindOne', 'site', site)\n            const localVarPath = `/lifi-sites/{site}`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all users that has manager permission over an accessible site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerGetAllUsers: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerGetAllUsers', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/users`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Locate a site near a given position\n         * @param {number} latitude \n         * @param {number} longitude \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerLocate: async (latitude: number, longitude: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'latitude' is not null or undefined\n            assertParamExists('lifiSitesControllerLocate', 'latitude', latitude)\n            // verify required parameter 'longitude' is not null or undefined\n            assertParamExists('lifiSitesControllerLocate', 'longitude', longitude)\n            const localVarPath = `/lifi-sites/locate`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            if (latitude !== undefined) {\n                localVarQueryParameter['latitude'] = latitude;\n            }\n\n            if (longitude !== undefined) {\n                localVarQueryParameter['longitude'] = longitude;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Delete an accessible site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerRemove: async (site: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerRemove', 'site', site)\n            const localVarPath = `/lifi-sites/{site}`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update an accessible site\n         * @param {string} site \n         * @param {UpdateLifiSiteDto} updateLifiSiteDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerUpdate: async (site: string, updateLifiSiteDto: UpdateLifiSiteDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerUpdate', 'site', site)\n            // verify required parameter 'updateLifiSiteDto' is not null or undefined\n            assertParamExists('lifiSitesControllerUpdate', 'updateLifiSiteDto', updateLifiSiteDto)\n            const localVarPath = `/lifi-sites/{site}`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateLifiSiteDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Upload a logo for this site\n         * @param {string} logo \n         * @param {string} site \n         * @param {File} [file] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerUploadLogo: async (logo: string, site: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'logo' is not null or undefined\n            assertParamExists('lifiSitesControllerUploadLogo', 'logo', logo)\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerUploadLogo', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/logos/{logo}`\n                .replace(`{${\"logo\"}}`, encodeURIComponent(String(logo)))\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();\n\n\n            if (file !== undefined) { \n                localVarFormParams.append('file', file as any);\n            }\n    \n    \n            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = localVarFormParams;\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Upload a signify map for this site\n         * @param {string} site \n         * @param {File} [file] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerUploadSignifyMap: async (site: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'site' is not null or undefined\n            assertParamExists('lifiSitesControllerUploadSignifyMap', 'site', site)\n            const localVarPath = `/lifi-sites/{site}/signify/map`\n                .replace(`{${\"site\"}}`, encodeURIComponent(String(site)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();\n\n\n            if (file !== undefined) { \n                localVarFormParams.append('file', file as any);\n            }\n    \n    \n            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = localVarFormParams;\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * SitesManagementApi - functional programming interface\n * @export\n */\nexport const SitesManagementApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = SitesManagementApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Assign a permission level to a user on an accessible site\n         * @param {string} site \n         * @param {AssignUserDto} assignUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerAssign(site: string, assignUserDto: AssignUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSiteUserAbility>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerAssign(site, assignUserDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * Create a new site with the given information\n         * @summary Create a new site\n         * @param {CreateLifiSiteDto} createLifiSiteDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerCreate(createLifiSiteDto: CreateLifiSiteDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerCreate(createLifiSiteDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove a logo for this site\n         * @param {string} logo \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerDeleteLogo(logo: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerDeleteLogo(logo, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove a signify map for this site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerDeleteSignifyMap(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerDeleteSignifyMap(site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove an assignation to a user from an accessible site\n         * @param {string} user \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerDismiss(user: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSiteUserAbility>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerDismiss(user, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Download a logo for this site\n         * @param {string} logo \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerDownloadLogo(logo: string, site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerDownloadLogo(logo, site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Download a signify map for this site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerDownloadSignifyMap(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerDownloadSignifyMap(site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Find all accessible sites\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiSite>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerFindAll(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Find an accessible site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerFindOne(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerFindOne(site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all users that has manager permission over an accessible site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerGetAllUsers(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiSiteUserAbility>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerGetAllUsers(site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Locate a site near a given position\n         * @param {number} latitude \n         * @param {number} longitude \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerLocate(latitude: number, longitude: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerLocate(latitude, longitude, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Delete an accessible site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerRemove(site: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerRemove(site, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Update an accessible site\n         * @param {string} site \n         * @param {UpdateLifiSiteDto} updateLifiSiteDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerUpdate(site: string, updateLifiSiteDto: UpdateLifiSiteDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerUpdate(site, updateLifiSiteDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Upload a logo for this site\n         * @param {string} logo \n         * @param {string} site \n         * @param {File} [file] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerUploadLogo(logo: string, site: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerUploadLogo(logo, site, file, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Upload a signify map for this site\n         * @param {string} site \n         * @param {File} [file] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async lifiSitesControllerUploadSignifyMap(site: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifiSite>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lifiSitesControllerUploadSignifyMap(site, file, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * SitesManagementApi - factory interface\n * @export\n */\nexport const SitesManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = SitesManagementApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Assign a permission level to a user on an accessible site\n         * @param {string} site \n         * @param {AssignUserDto} assignUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerAssign(site: string, assignUserDto: AssignUserDto, options?: any): AxiosPromise<LifiSiteUserAbility> {\n            return localVarFp.lifiSitesControllerAssign(site, assignUserDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new site with the given information\n         * @summary Create a new site\n         * @param {CreateLifiSiteDto} createLifiSiteDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerCreate(createLifiSiteDto: CreateLifiSiteDto, options?: any): AxiosPromise<LifiSite> {\n            return localVarFp.lifiSitesControllerCreate(createLifiSiteDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove a logo for this site\n         * @param {string} logo \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerDeleteLogo(logo: string, site: string, options?: any): AxiosPromise<LifiSite> {\n            return localVarFp.lifiSitesControllerDeleteLogo(logo, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove a signify map for this site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerDeleteSignifyMap(site: string, options?: any): AxiosPromise<LifiSite> {\n            return localVarFp.lifiSitesControllerDeleteSignifyMap(site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove an assignation to a user from an accessible site\n         * @param {string} user \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerDismiss(user: string, site: string, options?: any): AxiosPromise<LifiSiteUserAbility> {\n            return localVarFp.lifiSitesControllerDismiss(user, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Download a logo for this site\n         * @param {string} logo \n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerDownloadLogo(logo: string, site: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiSitesControllerDownloadLogo(logo, site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Download a signify map for this site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerDownloadSignifyMap(site: string, options?: any): AxiosPromise<void> {\n            return localVarFp.lifiSitesControllerDownloadSignifyMap(site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Find all accessible sites\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerFindAll(options?: any): AxiosPromise<Array<LifiSite>> {\n            return localVarFp.lifiSitesControllerFindAll(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Find an accessible site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerFindOne(site: string, options?: any): AxiosPromise<LifiSite> {\n            return localVarFp.lifiSitesControllerFindOne(site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all users that has manager permission over an accessible site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerGetAllUsers(site: string, options?: any): AxiosPromise<Array<LifiSiteUserAbility>> {\n            return localVarFp.lifiSitesControllerGetAllUsers(site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Locate a site near a given position\n         * @param {number} latitude \n         * @param {number} longitude \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerLocate(latitude: number, longitude: number, options?: any): AxiosPromise<LifiSite> {\n            return localVarFp.lifiSitesControllerLocate(latitude, longitude, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Delete an accessible site\n         * @param {string} site \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerRemove(site: string, options?: any): AxiosPromise<LifiSite> {\n            return localVarFp.lifiSitesControllerRemove(site, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update an accessible site\n         * @param {string} site \n         * @param {UpdateLifiSiteDto} updateLifiSiteDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerUpdate(site: string, updateLifiSiteDto: UpdateLifiSiteDto, options?: any): AxiosPromise<LifiSite> {\n            return localVarFp.lifiSitesControllerUpdate(site, updateLifiSiteDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Upload a logo for this site\n         * @param {string} logo \n         * @param {string} site \n         * @param {File} [file] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerUploadLogo(logo: string, site: string, file?: File, options?: any): AxiosPromise<LifiSite> {\n            return localVarFp.lifiSitesControllerUploadLogo(logo, site, file, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Upload a signify map for this site\n         * @param {string} site \n         * @param {File} [file] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        lifiSitesControllerUploadSignifyMap(site: string, file?: File, options?: any): AxiosPromise<LifiSite> {\n            return localVarFp.lifiSitesControllerUploadSignifyMap(site, file, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * SitesManagementApi - object-oriented interface\n * @export\n * @class SitesManagementApi\n * @extends {BaseAPI}\n */\nexport class SitesManagementApi extends BaseAPI {\n    /**\n     * \n     * @summary Assign a permission level to a user on an accessible site\n     * @param {string} site \n     * @param {AssignUserDto} assignUserDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerAssign(site: string, assignUserDto: AssignUserDto, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerAssign(site, assignUserDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Create a new site with the given information\n     * @summary Create a new site\n     * @param {CreateLifiSiteDto} createLifiSiteDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerCreate(createLifiSiteDto: CreateLifiSiteDto, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerCreate(createLifiSiteDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove a logo for this site\n     * @param {string} logo \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerDeleteLogo(logo: string, site: string, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerDeleteLogo(logo, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove a signify map for this site\n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerDeleteSignifyMap(site: string, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerDeleteSignifyMap(site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove an assignation to a user from an accessible site\n     * @param {string} user \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerDismiss(user: string, site: string, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerDismiss(user, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Download a logo for this site\n     * @param {string} logo \n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerDownloadLogo(logo: string, site: string, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerDownloadLogo(logo, site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Download a signify map for this site\n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerDownloadSignifyMap(site: string, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerDownloadSignifyMap(site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Find all accessible sites\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerFindAll(options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerFindAll(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Find an accessible site\n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerFindOne(site: string, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerFindOne(site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all users that has manager permission over an accessible site\n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerGetAllUsers(site: string, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerGetAllUsers(site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Locate a site near a given position\n     * @param {number} latitude \n     * @param {number} longitude \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerLocate(latitude: number, longitude: number, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerLocate(latitude, longitude, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Delete an accessible site\n     * @param {string} site \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerRemove(site: string, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerRemove(site, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update an accessible site\n     * @param {string} site \n     * @param {UpdateLifiSiteDto} updateLifiSiteDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerUpdate(site: string, updateLifiSiteDto: UpdateLifiSiteDto, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerUpdate(site, updateLifiSiteDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Upload a logo for this site\n     * @param {string} logo \n     * @param {string} site \n     * @param {File} [file] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerUploadLogo(logo: string, site: string, file?: File, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerUploadLogo(logo, site, file, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Upload a signify map for this site\n     * @param {string} site \n     * @param {File} [file] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SitesManagementApi\n     */\n    public lifiSitesControllerUploadSignifyMap(site: string, file?: File, options?: AxiosRequestConfig) {\n        return SitesManagementApiFp(this.configuration).lifiSitesControllerUploadSignifyMap(site, file, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * UserManagementApi - axios parameter creator\n * @export\n */\nexport const UserManagementApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Create a user account\n         * @param {CreateUserDto} createUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerCreate: async (createUserDto: CreateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createUserDto' is not null or undefined\n            assertParamExists('usersControllerCreate', 'createUserDto', createUserDto)\n            const localVarPath = `/users`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all users\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/users`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Fetch a user account\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerFindOne: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'user' is not null or undefined\n            assertParamExists('usersControllerFindOne', 'user', user)\n            const localVarPath = `/users/{user}`\n                .replace(`{${\"user\"}}`, encodeURIComponent(String(user)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get all sites that this user has access to. This is for convenience purposes only.\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerGetAllUsers: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'user' is not null or undefined\n            assertParamExists('usersControllerGetAllUsers', 'user', user)\n            const localVarPath = `/users/{user}/sites`\n                .replace(`{${\"user\"}}`, encodeURIComponent(String(user)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Remove a user account\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerRemove: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'user' is not null or undefined\n            assertParamExists('usersControllerRemove', 'user', user)\n            const localVarPath = `/users/{user}`\n                .replace(`{${\"user\"}}`, encodeURIComponent(String(user)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update a user account\n         * @param {string} user \n         * @param {UpdateUserDto} updateUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerUpdate: async (user: string, updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'user' is not null or undefined\n            assertParamExists('usersControllerUpdate', 'user', user)\n            // verify required parameter 'updateUserDto' is not null or undefined\n            assertParamExists('usersControllerUpdate', 'updateUserDto', updateUserDto)\n            const localVarPath = `/users/{user}`\n                .replace(`{${\"user\"}}`, encodeURIComponent(String(user)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication bearer required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * UserManagementApi - functional programming interface\n * @export\n */\nexport const UserManagementApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = UserManagementApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Create a user account\n         * @param {CreateUserDto} createUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async usersControllerCreate(createUserDto: CreateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerCreate(createUserDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all users\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async usersControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindAll(options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Fetch a user account\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async usersControllerFindOne(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindOne(user, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get all sites that this user has access to. This is for convenience purposes only.\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async usersControllerGetAllUsers(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifiSiteUserAbility>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetAllUsers(user, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Remove a user account\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async usersControllerRemove(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerRemove(user, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Update a user account\n         * @param {string} user \n         * @param {UpdateUserDto} updateUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async usersControllerUpdate(user: string, updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUpdate(user, updateUserDto, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * UserManagementApi - factory interface\n * @export\n */\nexport const UserManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = UserManagementApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Create a user account\n         * @param {CreateUserDto} createUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerCreate(createUserDto: CreateUserDto, options?: any): AxiosPromise<void> {\n            return localVarFp.usersControllerCreate(createUserDto, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all users\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerFindAll(options?: any): AxiosPromise<Array<User>> {\n            return localVarFp.usersControllerFindAll(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Fetch a user account\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerFindOne(user: string, options?: any): AxiosPromise<void> {\n            return localVarFp.usersControllerFindOne(user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get all sites that this user has access to. This is for convenience purposes only.\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerGetAllUsers(user: string, options?: any): AxiosPromise<Array<LifiSiteUserAbility>> {\n            return localVarFp.usersControllerGetAllUsers(user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Remove a user account\n         * @param {string} user \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerRemove(user: string, options?: any): AxiosPromise<User> {\n            return localVarFp.usersControllerRemove(user, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update a user account\n         * @param {string} user \n         * @param {UpdateUserDto} updateUserDto \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        usersControllerUpdate(user: string, updateUserDto: UpdateUserDto, options?: any): AxiosPromise<User> {\n            return localVarFp.usersControllerUpdate(user, updateUserDto, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * UserManagementApi - object-oriented interface\n * @export\n * @class UserManagementApi\n * @extends {BaseAPI}\n */\nexport class UserManagementApi extends BaseAPI {\n    /**\n     * \n     * @summary Create a user account\n     * @param {CreateUserDto} createUserDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserManagementApi\n     */\n    public usersControllerCreate(createUserDto: CreateUserDto, options?: AxiosRequestConfig) {\n        return UserManagementApiFp(this.configuration).usersControllerCreate(createUserDto, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all users\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserManagementApi\n     */\n    public usersControllerFindAll(options?: AxiosRequestConfig) {\n        return UserManagementApiFp(this.configuration).usersControllerFindAll(options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Fetch a user account\n     * @param {string} user \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserManagementApi\n     */\n    public usersControllerFindOne(user: string, options?: AxiosRequestConfig) {\n        return UserManagementApiFp(this.configuration).usersControllerFindOne(user, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get all sites that this user has access to. This is for convenience purposes only.\n     * @param {string} user \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserManagementApi\n     */\n    public usersControllerGetAllUsers(user: string, options?: AxiosRequestConfig) {\n        return UserManagementApiFp(this.configuration).usersControllerGetAllUsers(user, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Remove a user account\n     * @param {string} user \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserManagementApi\n     */\n    public usersControllerRemove(user: string, options?: AxiosRequestConfig) {\n        return UserManagementApiFp(this.configuration).usersControllerRemove(user, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update a user account\n     * @param {string} user \n     * @param {UpdateUserDto} updateUserDto \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserManagementApi\n     */\n    public usersControllerUpdate(user: string, updateUserDto: UpdateUserDto, options?: AxiosRequestConfig) {\n        return UserManagementApiFp(this.configuration).usersControllerUpdate(user, updateUserDto, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n","import axios from \"axios\";\nimport React from \"react\";\nimport \"react-native-url-polyfill/auto\";\nimport {\n  AuthApi,\n  AuthApiFactory,\n  Configuration,\n  SignInDto,\n} from \"../generated\";\n\nconst config = new Configuration();\n\nconst axiosInstance = axios.create({\n  headers: { Authorization: \"YOUR_TOKEN\" },\n});\n\nconst basePath = \"https://new-tobebackend.herokuapp.com\";\n\nconst authApi = new AuthApi(config, basePath, axiosInstance);\n\nexport { authApi };\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * ToBe - API\n * Get Swagger in json OAS3 format <a target=\\\"_blank\\\" href=\\\"/api-json\\\" rel=\\\"noopener noreferrer\\\">here</a>        Esempio del formato GeoJSON utilizzato per la gestione delle aree di interesse:        {         \\\"type\\\": \\\"Point\\\",         \\\"coordinates\\\": [           35.859375,           35.17380831799959         ]       }\n *\n * The version of the OpenAPI document: 1.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface ConfigurationParameters {\n    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);\n    username?: string;\n    password?: string;\n    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);\n    basePath?: string;\n    baseOptions?: any;\n    formDataCtor?: new () => any;\n}\n\nexport class Configuration {\n    /**\n     * parameter for apiKey security\n     * @param name security name\n     * @memberof Configuration\n     */\n    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);\n    /**\n     * parameter for basic security\n     *\n     * @type {string}\n     * @memberof Configuration\n     */\n    username?: string;\n    /**\n     * parameter for basic security\n     *\n     * @type {string}\n     * @memberof Configuration\n     */\n    password?: string;\n    /**\n     * parameter for oauth2 security\n     * @param name security name\n     * @param scopes oauth2 scope\n     * @memberof Configuration\n     */\n    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);\n    /**\n     * override base path\n     *\n     * @type {string}\n     * @memberof Configuration\n     */\n    basePath?: string;\n    /**\n     * base options for axios calls\n     *\n     * @type {any}\n     * @memberof Configuration\n     */\n    baseOptions?: any;\n    /**\n     * The FormData constructor that will be used to create multipart form data\n     * requests. You can inject this here so that execution environments that\n     * do not support the FormData class can still run the generated client.\n     *\n     * @type {new () => FormData}\n     */\n    formDataCtor?: new () => any;\n\n    constructor(param: ConfigurationParameters = {}) {\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.baseOptions = param.baseOptions;\n        this.formDataCtor = param.formDataCtor;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\n","import { BottomSheet, Button, Dialog, ListItem } from \"@rneui/themed\";\nimport React, { useState } from \"react\";\nimport { StyleSheet } from \"react-native\";\nimport { SignInDto } from \"../generated\";\nimport { authApi } from \"./api\";\nimport Background from \"./Elements/Background\";\n\ntype BottomSheetComponentProps = {};\n\nconst BottomSheetComponent: React.FunctionComponent<\n  BottomSheetComponentProps\n> = () => {\n  const [isVisible, setIsVisible] = useState(false);\n  const list = [\n    { title: \"List Item 1\" },\n    { title: \"List Item 2\" },\n    {\n      title: \"Cancel\",\n      containerStyle: { backgroundColor: \"red\" },\n      titleStyle: { color: \"white\" },\n      onPress: () => setIsVisible(false),\n    },\n  ];\n\n  const login = async () => {\n    const data: SignInDto = {\n      email: \"molinari\",\n      password: \"andrea\",\n    };\n\n    try {\n      return await authApi.authControllerSignIn(data);\n    } catch (error) {\n      console.warn(\"errore signIn api !! ! ! !\");\n    }\n  };\n\n  const [visibleCosaSotto, setVisibleCosaSotto] = React.useState(false);\n\n  return (\n    <Background>\n      <TastoConModal visible={visibleCosaSotto} />\n\n      <Button onPress={login} title=\"forte\" />\n      <Button\n        title=\"Open Bottom Sheet\"\n        onPress={() => setIsVisible(true)}\n        buttonStyle={styles.button}\n      />\n      <BottomSheet modalProps={{}} isVisible={isVisible}>\n        {list.map((l, i) => (\n          <ListItem\n            key={i}\n            containerStyle={l.containerStyle}\n            onPress={l.onPress}\n          >\n            <ListItem.Content>\n              <ListItem.Title style={l.titleStyle}>{l.title}</ListItem.Title>\n            </ListItem.Content>\n          </ListItem>\n        ))}\n        <ListItem onPress={() => setVisibleCosaSotto((s) => !s)}>\n          <ListItem.Title>andasrea</ListItem.Title>\n        </ListItem>\n      </BottomSheet>\n    </Background>\n  );\n};\n\nconst TastoConModal: React.FC<{\n  visible: boolean;\n}> = (props) => {\n  const [isVisible, setIsVisible] = React.useState(false);\n  React.useEffect(() => {\n    setIsVisible(props.visible);\n  }, [props]);\n\n  return (\n    <Dialog\n      isVisible={isVisible}\n      onBackdropPress={() => setIsVisible((s) => !s)}\n    >\n      <Dialog.Title title=\"Bella pe me\" />\n    </Dialog>\n  );\n};\n\nconst styles = StyleSheet.create({\n  button: {\n    margin: 10,\n  },\n});\n\nexport default BottomSheetComponent;\n","import { NavigationContainer } from \"@react-navigation/native\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport React from \"react\";\nimport Header from \"../Elements/Header\";\nimport HomeView from \"../HomeView\";\nimport BottomSheetComponent from \"../LiFiZone\";\nimport * as Linking from \"expo-linking\";\nimport { Text } from \"@rneui/themed\";\n\nconst linking = {\n  prefixes: [\"lifi-zone://\", \"https://andreamolinari.github.io/test-pages/\"],\n};\nconst NavStack = createNativeStackNavigator();\n\nexport default () => {\n  const linking = {\n    prefixes: [prefix],\n  };\n  return (\n    <NavigationContainer linking={linking} fallback={<Text>Loading...</Text>}>\n      <NavStack.Navigator\n        initialRouteName=\"Home\"\n        screenOptions={{\n          header: () => <Header />,\n        }}\n      >\n        <NavStack.Screen component={HomeView} name=\"Home\" />\n        <NavStack.Screen component={BottomSheetComponent} name=\"BottomSheet\" />\n      </NavStack.Navigator>\n    </NavigationContainer>\n  );\n};\n","import { ThemeProvider } from \"@rneui/themed\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\nimport MainNavigator from \"./src/Navigator/Main.navigator\";\n\nconst theme = {\n  lightColors: {\n    primary: \"#333\",\n    background: \"#111\",\n    secondary: \"red\",\n    white: \"#000\",\n    black: \"#fff\",\n  },\n  darkColors: {\n    primary: \"#333\",\n    secondary: \"red\",\n    background: \"#111\",\n    white: \"black\",\n    black: \"white\",\n  },\n};\n\nconst App = () => {\n  return (\n    <SafeAreaProvider>\n      <ThemeProvider theme={theme}>\n        <MainNavigator />\n      </ThemeProvider>\n    </SafeAreaProvider>\n  );\n};\n\nexport default App;\n"],"sourceRoot":""}